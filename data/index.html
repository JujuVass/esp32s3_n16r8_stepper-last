<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Stepper Controller</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>‚öôÔ∏è</text></svg>">
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
      background: #f0f0f0;
    }
    .container {
      background: white;
      padding: 30px;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    h1 {
      color: #333;
      text-align: center;
      margin-bottom: 30px;
    }
    label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
      color: #555;
    }
    input[type="number"],
    select.select-input {
      width: 100%;
      padding: 10px;
      font-size: 12px;
      border: 2px solid #ddd;
      border-radius: 5px;
      box-sizing: border-box;
    }
    
    /* Override width for inline inputs in stacked groups */
    .form-group-compact > div > input[type="number"] {
      width: 140px;
      min-width: 140px;
    }
    
    input[type="number"]:focus,
    select.select-input:focus {
      outline: none;
      border-color: #2196F3;
    }
    .button {
      padding: 12px 30px;
      font-size: 16px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      margin: 5px;
      transition: all 0.3s;
    }
    .btn-primary {
      background: #2196F3;
      color: white;
    }
    .btn-primary:hover {
      background: #1976D2;
    }
    .btn-success {
      background: #4CAF50;
      color: white;
    }
    .btn-success:hover {
      background: #45a049;
    }
    .btn-success:disabled {
      background: #9E9E9E;
      cursor: not-allowed;
      opacity: 0.5;
    }
    .btn-warning {
      background: #FF9800;
      color: white;
    }
    .btn-warning:hover {
      background: #F57C00;
    }
    .btn-danger {
      background: #f44336;
      color: white;
    }
    .btn-danger:hover {
      background: #d32f2f;
    }
    .btn-secondary {
      background: #6c757d;
      color: white;
    }
    .btn-secondary:hover {
      background: #5a6268;
    }
    .btn-info {
      background: #17a2b8;
      color: white;
    }
    .btn-info:hover {
      background: #138496;
    }
    .btn-help {
      background: #d2ccb4;
      color: white;
    }
    .btn-help:hover {
      background: #c2b09f;
    }
    .button-group {
      text-align: center;
      margin: 20px 0;
    }
    .state-init { color: #9E9E9E; }
    .state-calibrating { color: #FF9800; }
    .state-ready { color: #4CAF50; }
    .state-running { color: #2196F3; }
    .state-paused { color: #FF9800; }
    .state-error { color: #f44336; }
    .overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      z-index: 9999;
      justify-content: center;
      align-items: center;
    }
    .overlay.active {
      display: flex;
    }
    .overlay-content {
      background: white;
      padding: 40px 60px;
      border-radius: 15px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.3);
      text-align: center;
      animation: fadeIn 0.3s ease-in;
    }
    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: scale(0.9);
      }
      to {
        opacity: 1;
        transform: scale(1);
      }
    }
    .overlay-icon {
      font-size: 60px;
      margin-bottom: 20px;
      animation: pulse 1.5s ease-in-out infinite;
    }
    @keyframes pulse {
      0%, 100% {
        transform: scale(1);
        opacity: 1;
      }
      50% {
        transform: scale(1.1);
        opacity: 0.8;
      }
    }
    .overlay-title {
      font-size: 24px;
      font-weight: bold;
      color: #333;
      margin-bottom: 10px;
    }
    .overlay-message {
      font-size: 16px;
      color: #666;
      margin-bottom: 20px;
    }
    .spinner {
      border: 4px solid #f3f3f3;
      border-top: 4px solid #2196F3;
      border-radius: 50%;
      width: 50px;
      height: 50px;
      animation: spin 1s linear infinite;
      margin: 20px auto;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    @keyframes milestone-pop {
      0% { transform: scale(1); }
      50% { transform: scale(1.4); }
      100% { transform: scale(1); }
    }
    
    .milestone-achievement {
      animation: milestone-pop 0.5s ease-out;
    }
    
    /* Tabs */
    .tabs {
      display: flex;
      border-bottom: 2px solid #2196F3;
      margin-bottom: 20px;
      gap: 5px;
    }
    .tabs.hidden-until-calibrated {
      display: none;
    }
    .tab {
      padding: 12px 24px;
      background: #f0f0f0;
      border: none;
      border-top-left-radius: 8px;
      border-top-right-radius: 8px;
      cursor: pointer;
      font-size: 16px;
      font-weight: 600;
      color: #666;
      transition: all 0.3s;
      border-bottom: 3px solid transparent;
    }
    .tab:hover {
      background: #e0e0e0;
      color: #333;
    }
    .tab.active {
      background: white;
      color: #2196F3;
      border-bottom: 3px solid #2196F3;
    }
    .tab-content {
      display: none;
    }
    .tab-content.active {
      display: block;
    }
    /* Hide all tabs content until calibrated (takes priority over .active) */
    .tab-content.hidden-until-calibrated {
      display: none !important;
    }
    /* Modal for mode change confirmation */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      z-index: 10000;
      justify-content: center;
      align-items: center;
    }
    .modal.active {
      display: flex;
    }
    .modal-content {
      background: white;
      padding: 30px;
      border-radius: 10px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.3);
      text-align: center;
      max-width: 500px;
      animation: fadeIn 0.3s ease-in;
    }
    .modal-title {
      font-size: 22px;
      font-weight: bold;
      color: #FF9800;
      margin-bottom: 15px;
    }
    .modal-message {
      font-size: 16px;
      color: #666;
      margin-bottom: 25px;
      line-height: 1.5;
    }
    .modal-buttons {
      display: flex;
      gap: 15px;
      justify-content: center;
    }
    
    /* Playlist Presets List - Custom Scrollbar */
    #playlistModal .modal-content > div:nth-child(3) {
      scrollbar-width: thin;
      scrollbar-color: #667eea #f0f0f0;
    }
    #playlistModal .modal-content > div:nth-child(3)::-webkit-scrollbar {
      width: 8px;
    }
    #playlistModal .modal-content > div:nth-child(3)::-webkit-scrollbar-track {
      background: #f0f0f0;
      border-radius: 4px;
    }
    #playlistModal .modal-content > div:nth-child(3)::-webkit-scrollbar-thumb {
      background: #667eea;
      border-radius: 4px;
    }
    #playlistModal .modal-content > div:nth-child(3)::-webkit-scrollbar-thumb:hover {
      background: #5568d3;
    }
    
    /* Playlist Preset Tooltips */
    .preset-item {
      cursor: pointer;
      transition: all 0.2s ease;
    }
    .preset-item:hover {
      background: #fff !important;
      box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      transform: translateX(2px);
    }
    
    /* Tooltip overlay - positioned in center of modal */
    #playlistTooltipOverlay {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 15px 20px;
      border-radius: 10px;
      font-size: 12px;
      white-space: pre-line;
      z-index: 10001;
      pointer-events: none;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease, visibility 0.3s ease;
      box-shadow: 0 8px 24px rgba(0,0,0,0.4);
      max-width: 400px;
      line-height: 1.5;
      border: 2px solid rgba(255,255,255,0.3);
    }
    #playlistTooltipOverlay.visible {
      opacity: 1;
      visibility: visible;
    }
    
    /* Playlist Search Input */
    #playlistSearchInput {
      transition: all 0.3s ease;
    }
    #playlistSearchInput:focus {
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
      border-color: #667eea !important;
    }
    
    /* Sequencer Active Line Highlight */
    .sequence-line-active {
      background: linear-gradient(90deg, #E3F2FD 0%, #BBDEFB 100%) !important;
      border-left: 4px solid #2196F3 !important;
      box-shadow: 0 0 12px rgba(33, 150, 243, 0.4);
      animation: pulse-line 1.5s ease-in-out infinite;
    }
    
    @keyframes pulse-line {
      0%, 100% { 
        box-shadow: 0 0 8px rgba(33, 150, 243, 0.3);
      }
      50% { 
        box-shadow: 0 0 16px rgba(33, 150, 243, 0.6);
      }
    }
    
    /* Phase 2: Drag & Drop Styles */
    .sequence-line-draggable {
      cursor: grab;
    }
    
    .sequence-line-draggable:active {
      cursor: grabbing;
    }
    
    .sequence-line-dragging {
      opacity: 0.3;
      background: #f0f0f0 !important;
    }
    
    /* Drop spacer - Real table row that creates space */
    .sequence-drop-spacer {
      height: 50px !important;
      animation: fade-in 0.2s ease;
    }
    
    .sequence-drop-spacer td {
      height: 50px !important;
      padding: 0 !important;
      border: none !important;
      background: transparent !important;
    }
    
    .sequence-drop-placeholder-inner {
      display: block !important;
      margin: 5px 8px !important;
      padding: 10px !important;
      height: 40px !important;
      background: linear-gradient(135deg, rgba(102, 126, 234, 0.15) 0%, rgba(118, 75, 162, 0.15) 100%) !important;
      border: 3px dashed #667eea !important;
      border-radius: 8px !important;
      text-align: center !important;
      line-height: 20px !important;
      font-size: 14px !important;
      color: #667eea !important;
      font-weight: 600 !important;
      box-sizing: border-box !important;
      animation: pulse-glow 1s ease-in-out infinite;
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
    }
    
    @keyframes pulse-glow {
      0%, 100% { 
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        border-color: #667eea;
      }
      50% { 
        box-shadow: 0 6px 20px rgba(102, 126, 234, 0.7);
        border-color: #764ba2;
      }
    }
    
    @keyframes fade-in {
      from { opacity: 0; transform: scaleY(0.3); }
      to { opacity: 1; transform: scaleY(1); }
    }
    
    @keyframes pulse-drop-zone {
      0%, 100% { opacity: 0.6; transform: scaleY(1); }
      50% { opacity: 1; transform: scaleY(1.5); }
    }
    
    /* Drop zone placeholder (dashed box preview) */
    .sequence-drop-placeholder {
      height: 40px;
      border: 2px dashed #667eea;
      background: linear-gradient(135deg, rgba(102, 126, 234, 0.05) 0%, rgba(118, 75, 162, 0.05) 100%);
      border-radius: 4px;
      margin: 4px 0;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #667eea;
      font-size: 12px;
      font-weight: 600;
      animation: fade-in 0.2s;
    }
    
    @keyframes fade-in {
      from { opacity: 0; transform: scaleY(0.5); }
      to { opacity: 1; transform: scaleY(1); }
    }
    
    /* Phase 2: Multi-Select Styles */
    .sequence-line-selected {
      background: linear-gradient(90deg, #E8EAF6 0%, #C5CAE9 100%) !important;
      border-left: 4px solid #667eea !important;
      box-shadow: 0 0 8px rgba(102, 126, 234, 0.3);
    }
    
    .sequence-batch-toolbar {
      display: none;
      position: sticky;
      top: 0;
      z-index: 100;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 10px 16px;
      border-radius: 8px;
      margin-bottom: 12px;
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }
    
    .sequence-batch-toolbar.visible {
      display: flex;
    }
    
    .sequence-batch-info {
      font-weight: 600;
      font-size: 13px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .sequence-batch-actions {
      display: flex;
      gap: 6px;
      align-items: center;
    }
    
    .sequence-batch-btn {
      background: rgba(255, 255, 255, 0.15);
      border: 1px solid rgba(255, 255, 255, 0.25);
      color: white;
      padding: 5px 10px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 11px;
      font-weight: 600;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      gap: 4px;
    }
    
    .sequence-batch-btn:hover {
      background: rgba(255, 255, 255, 0.25);
      transform: translateY(-1px);
    }
    
    /* Drag & Drop Trash Zone (toolbar version - kept for batch operations) */
    .sequence-trash-zone {
      background: linear-gradient(135deg, rgba(244, 67, 54, 0.1) 0%, rgba(233, 30, 99, 0.1) 100%);
      border: 2px dashed rgba(244, 67, 54, 0.3);
      border-radius: 6px;
      padding: 8px 16px;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      color: rgba(244, 67, 54, 0.8);
      font-weight: 600;
      transition: all 0.3s;
      min-width: 140px;
      justify-content: center;
    }
    
    .sequence-trash-zone .trash-icon {
      font-size: 18px;
      transition: transform 0.3s;
    }
    
    .sequence-trash-zone.drag-over {
      background: linear-gradient(135deg, rgba(244, 67, 54, 0.2) 0%, rgba(233, 30, 99, 0.2) 100%);
      border-color: #F44336;
      border-width: 3px;
      transform: scale(1.05);
      box-shadow: 0 4px 12px rgba(244, 67, 54, 0.4);
    }
    
    .sequence-trash-zone.drag-over .trash-icon {
      transform: scale(1.3) rotate(10deg);
      animation: shake-trash 0.5s infinite;
    }
    
    /* Permanent Trash Drop Zone (below table) */
    .sequence-trash-drop-zone {
      margin-top: 12px;
      padding: 16px;
      background: linear-gradient(135deg, rgba(244, 67, 54, 0.08) 0%, rgba(233, 30, 99, 0.08) 100%);
      border: 2px dashed rgba(244, 67, 54, 0.25);
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      font-size: 14px;
      color: rgba(244, 67, 54, 0.7);
      font-weight: 600;
      transition: all 0.25s ease;
      cursor: pointer;
    }
    
    .sequence-trash-drop-zone .trash-icon {
      font-size: 24px;
      transition: all 0.25s ease;
    }
    
    .sequence-trash-drop-zone.drag-active {
      background: linear-gradient(135deg, rgba(244, 67, 54, 0.12) 0%, rgba(233, 30, 99, 0.12) 100%);
      border-color: rgba(244, 67, 54, 0.5);
      border-width: 2px;
      box-shadow: 0 2px 8px rgba(244, 67, 54, 0.3);
    }
    
    .sequence-trash-drop-zone.drag-active .trash-icon {
      transform: scale(1.15);
    }
    
    @keyframes shake-trash {
      0%, 100% { transform: scale(1.3) rotate(8deg); }
      25% { transform: scale(1.3) rotate(12deg); }
      75% { transform: scale(1.3) rotate(6deg); }
    }
    
    /* Sequencer Edit Modal - Override global input styles */
    #editLineModal input[type="number"],
    #editLineModal input[type="text"],
    #editLineModal select {
      padding: 6px !important;
      font-size: 12px !important;
      border: 1px solid #ddd !important;
      border-radius: 4px !important;
    }
    
    #editLineModal label {
      font-size: 12px !important;
      font-weight: 500 !important;
      color: #333 !important;
    }
    
    #editLineModal input[type="checkbox"],
    #editLineModal input[type="radio"] {
      width: 16px !important;
      height: 16px !important;
    }
    
    /* Type selection inline layout */
    #editLineModal .type-selection-row {
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 15px;
    }
    
    #editLineModal .type-selection-row > label:first-child {
      margin-right: 10px;
    }
    
    #editLineModal .type-selection-buttons {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    
    #editLineModal .type-selection-buttons label {
      width: auto !important;
    }
    
    #editLineModal .type-selection-buttons input[type="radio"] {
      width: 16px !important;
    }
    
    /* Error Notification Toast */
    /* Unified notification system - supports info, warning, error */
    .notification {
      position: fixed;
      top: 80px;
      right: 20px;
      color: white;
      padding: 16px 24px;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
      font-size: 14px;
      font-weight: 500;
      max-width: 450px;
      line-height: 1.5;
      z-index: 10000;
      opacity: 0;
      transform: translateX(400px);
      transition: all 0.3s ease-in-out;
      white-space: pre-line;
      backdrop-filter: blur(10px);
    }
    .notification.show {
      opacity: 1;
      transform: translateX(0);
    }
    .notification.notification-success {
      background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
      border-left: 4px solid #2e7d32;
    }
    .notification.notification-info {
      background: linear-gradient(135deg, #2196F3 0%, #1976D2 100%);
      border-left: 4px solid #0d47a1;
    }
    .notification.notification-warning {
      background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%);
      border-left: 4px solid #e65100;
    }
    .notification.notification-error {
      background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);
      border-left: 4px solid #b71c1c;
    }
    
    /* Welcome message before calibration */
    .welcome-message {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 30px;
      border-radius: 10px;
      text-align: center;
      margin: 20px 0;
      box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
    }
    .welcome-message h2 {
      margin: 0 0 15px 0;
      font-size: 28px;
    }
    .welcome-message p {
      margin: 10px 0;
      font-size: 16px;
      line-height: 1.6;
    }
    .welcome-message.hidden {
      display: none;
    }
    
    /* Compact Status Bar Styles */
    .status-compact {
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      margin-bottom: 15px;
      overflow: hidden;
    }
    
    .btn-compact {
      padding: 4px 12px;
      font-size: 12px;
      font-weight: 600;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
      white-space: nowrap;
    }
    
    .btn-compact:hover {
      transform: translateY(-1px);
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    
    .btn-compact:active {
      transform: translateY(0);
    }
    
    .btn-icon {
      padding: 2px 6px;
      font-size: 13px;
      background: transparent;
      border: 1px solid #ddd;
      border-radius: 3px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .btn-icon:hover {
      background: #f0f0f0;
      border-color: #2196F3;
    }

    /* ============================================
       COMPACT FRAMEWORK - R√©utilisable
       ============================================ */

    /* Headers */
    .header-compact {
      padding: 10px 15px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border-radius: 8px 8px 0 0;
      margin-bottom: 15px;
    }

    .header-compact h2 {
      margin: 0;
      font-size: 18px;
      font-weight: 600;
    }

    /* Form Layouts */
    .form-row-compact {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 15px;
      margin-bottom: 12px;
    }

    .form-group-compact {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    /* Form group with label+input on one line, presets below */
    .form-group-stacked {
      display: block;
    }
    
    .form-group-stacked .input-line {
      display: inline-block;  /* Garde les √©l√©ments internes sur la m√™me ligne */
      width: 100%;            /* Mais force un bloc complet */
      margin-bottom: 8px;
    }

    /* Speed controls - stay on one line */
    .speed-control-inline {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: nowrap;
    }

    /* Labels */
    .label-inline {
      display: inline;
      min-width: 90px;
      font-size: 13px;
      font-weight: 500;
      color: #333;
    }

    .unit-label {
      font-size: 12px;
      color: #666;
      margin-left: 4px;
    }

    /* Inputs */
    .input-compact {
      width: 140px;
      padding: 6px 10px;
      font-size: 13px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }

    /* Preset Buttons */
    .preset-grid {
      display: flex;
      gap: 4px;
      flex-wrap: wrap;
    }

    .preset-btn-sm {
      min-width: 52px;
      padding: 5px 6px;
      font-size: 11px;
      background: #f0f0f0;
      border: 1px solid #ccc;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
      text-align: center;
      height: 28px;
      line-height: 16px;
      box-sizing: border-box;
    }

    .preset-btn-sm:hover {
      background: #667eea;
      color: white;
      border-color: #667eea;
    }

    /* Radio Inline */
    .radio-inline {
      display: flex;
      gap: 15px;
    }

    /* ========== NEW MODAL OPTIMIZATION CLASSES ========== */
    
    /* Grid 2 colonnes - remplace 28 occurrences */
    .grid-2col-12 {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-bottom: 10px;
    }
    
    /* Grid 4 colonnes pour patterns chaos */
    .grid-4col-patterns {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 6px;
      background: #f5f5f5;
      padding: 8px;
      border-radius: 5px;
      margin-top: 3px;
    }
    
    /* Input modal uniformis√© - remplace 50+ occurrences */
    .input-modal {
      width: auto !important;
      padding: 6px !important;
      border: 1px solid #ddd !important;
      border-radius: 4px;
      font-size: 12px !important;
      margin-top: 3px;
    }
    
    /* Radio label inline pour type selection */
    .radio-label-inline {
      display: inline-flex;
      align-items: center;
      gap: 5px;
      cursor: pointer;
      background: #f5f5f5;
      padding: 6px 10px;
      border-radius: 4px;
    }
    
    /* Checkbox label petit pour chaos patterns */
    .checkbox-label-sm {
      display: flex;
      align-items: center;
      gap: 4px;
      cursor: pointer;
      font-size: 11px;
    }
    
    /* Flex utilities */
    .flex-gap-10 { display: flex; gap: 10px; }
    .flex-gap-12 { display: flex; gap: 12px; }
    .flex-gap-15 { display: flex; gap: 15px; }
    .flex-end { justify-content: flex-end; }
    
    /* Spacing utilities */
    .mb-8 { margin-bottom: 8px; }
    .mb-10 { margin-bottom: 10px; }
    .mb-12 { margin-bottom: 12px; }
    .mb-15 { margin-bottom: 15px; }
    
    /* ========== END MODAL OPTIMIZATION CLASSES ========== */

    .radio-inline label {
      display: flex;
      align-items: center;
      gap: 5px;
      font-size: 13px;
      cursor: pointer;
    }

    /* Collapsible Sections */
    .section-collapsible {
      border: 1px solid #ddd;
      border-radius: 6px;
      margin-bottom: 12px;
      overflow: hidden;
    }

    .section-collapsible-header {
      padding: 10px 15px;
      background: #f8f9fa;
      font-weight: 600;
      font-size: 14px;
      cursor: pointer;
      user-select: none;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .section-collapsible-header:hover {
      background: #e9ecef;
    }

    .collapse-icon {
      transition: transform 0.3s;
    }

    .section-collapsible.collapsed .collapse-icon {
      transform: rotate(-90deg);
    }

    .section-collapsible-content {
      padding: 15px;
      max-height: 1000px;
      transition: max-height 0.3s ease-out;
    }

    .section-collapsible.collapsed .section-collapsible-content {
      max-height: 0;
      padding: 0 15px;
      overflow: hidden;
    }

    /* Canvas Compact */
    .canvas-compact {
      width: 100%;
      max-width: 300px;
      height: 100px;
      border: 1px solid #ddd;
      border-radius: 4px;
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <!-- Calibration Overlay -->
  <div class="overlay" id="calibrationOverlay">
    <div class="overlay-content">
      <div class="overlay-icon">üîç</div>
      <div class="overlay-title">Calibration en cours...</div>
      <div class="overlay-message">Veuillez patienter pendant la recherche des limites</div>
      <div class="spinner"></div>
      <div style="color: #999; font-size: 14px; margin-top: 15px;">
        Ne pas interrompre le processus
      </div>
    </div>
  </div>

  <!-- Playlist Management Modal -->
  <div class="modal" id="playlistModal" onclick="closePlaylistModalOnOverlayClick(event)">
    <div class="modal-content" style="max-width: 650px; max-height: 85vh; display: flex; flex-direction: column;" onclick="event.stopPropagation()">
      <div class="modal-title">üìã Playlist - <span id="playlistModalTitle">Mode</span></div>
      
      <!-- Sticky Current Config Preview -->
      <div id="playlistCurrentConfig" style="background: #E3F2FD; padding: 12px; border-radius: 6px; margin-bottom: 12px; flex-shrink: 0;">
        <div style="font-weight: 500; margin-bottom: 8px; font-size: 13px;">‚öôÔ∏è Configuration actuelle:</div>
        <div id="playlistCurrentConfigContent" style="font-size: 12px; color: #555;"></div>
        <button class="button btn-success" id="btnAddCurrentToPlaylist" style="margin-top: 8px; width: 100%; padding: 8px; font-size: 13px;">
          ‚ûï Ajouter √† la playlist
        </button>
      </div>
      
      <!-- Presets List with Scroll -->
      <div style="flex: 1; overflow-y: auto; overflow-x: visible; border-top: 2px solid #ddd; padding-top: 12px; min-height: 0;">
        <div style="font-weight: 500; margin-bottom: 10px; font-size: 13px; padding: 0 5px;">
          üì¶ Presets sauvegard√©s (<span id="playlistCount">0</span>/20):
        </div>
        
        <!-- Search Input -->
        <input type="text" id="playlistSearchInput" placeholder="üîç Rechercher un preset..." 
               oninput="filterPlaylistPresets(this.value)"
               style="width: 90%; margin: 0 0 10px 0; padding: 8px; border: 2px solid #ddd; border-radius: 6px; font-size: 12px;">
        
        <div id="playlistPresetsList" style="padding-right: 5px; overflow: visible;">
          <!-- Presets will be dynamically inserted here -->
          <div style="color: #999; font-style: italic; padding: 20px; text-align: center; font-size: 12px;">
            Aucun preset sauvegard√©
          </div>
        </div>
      </div>
      
      <!-- Sticky Close Button -->
      <div style="border-top: 2px solid #ddd; padding: 12px 0 0 0; margin-top: 12px; background: white; flex-shrink: 0;">
        <button class="button btn-secondary" onclick="closePlaylistModal()" style="width: 100%; padding: 10px; font-size: 14px;">
          ‚úñÔ∏è Fermer
        </button>
      </div>
    </div>
  </div>

  <!-- Playlist Tooltip Overlay -->
  <div id="playlistTooltipOverlay"></div>

  <!-- Mode Change Confirmation Modal -->
  <div class="modal" id="modeChangeModal">
    <div class="modal-content">
      <div class="modal-title">‚ö†Ô∏è Changement de mode</div>
      <div class="modal-message" id="modalMessage">
        Une op√©ration est en cours. Le changement de mode va arr√™ter le mouvement et lancer une recalibration.
        <br><br>
        <strong>Voulez-vous continuer ?</strong>
      </div>
      <div style="margin: 20px 0; padding: 15px; background: #FFF3E0; border-radius: 5px; border: 2px solid #FF9800;">
        <label style="display: flex; align-items: center; justify-content: center; cursor: pointer; font-weight: normal;">
          <input type="checkbox" id="bypassCalibrationCheckbox" style="margin-right: 10px; width: 18px; height: 18px; cursor: pointer;">
          <span style="color: #FF9800; font-weight: bold;">/!\ Bypasser la calibration compl√®te</span>
        </label>
        <div style="font-size: 12px; color: #666; margin-top: 8px; text-align: center;">
          (Retour rapide au contact d√©but uniquement)
        </div>
      </div>
      <div class="modal-buttons">
        <button class="button btn-danger" onclick="cancelModeChange()">Annuler</button>
        <button class="button btn-success" onclick="confirmModeChange()">Confirmer</button>
      </div>
    </div>
  </div>

  <!-- Stop Confirmation Modal -->
  <div class="modal" id="stopModal">
    <div class="modal-content">
      <div class="modal-title">‚èπÔ∏è Arr√™ter le mouvement</div>
      <div class="modal-message">
        Voulez-vous arr√™ter le mouvement en cours ?
      </div>
      <div style="margin: 20px 0; padding: 15px; background: #E3F2FD; border-radius: 5px; border: 2px solid #2196F3;">
        <label style="display: flex; align-items: center; justify-content: center; cursor: pointer; font-weight: normal;">
          <input type="checkbox" id="returnToStartCheckbox" checked style="margin-right: 10px; width: 18px; height: 18px; cursor: pointer;">
          <span style="color: #2196F3; font-weight: bold;">üè† Retour √† la position initiale (0mm)</span>
        </label>
        <div style="font-size: 12px; color: #666; margin-top: 8px; text-align: center;">
          (D√©sactiver pour rester √† la position actuelle)
        </div>
      </div>
      <div class="modal-buttons">
        <button class="button btn-secondary" onclick="cancelStopModal()">Annuler</button>
        <button class="button btn-danger" onclick="confirmStopModal()">‚èπÔ∏è Arr√™ter</button>
      </div>
    </div>
  </div>

  <!-- Modal for Sequencer Limit Warning -->
  <div class="modal" id="sequencerLimitModal">
    <div class="modal-content">
      <div class="modal-title">‚ö†Ô∏è Passage en Mode S√©quenceur</div>
      <div class="modal-message">
        <div style="background: #E3F2FD; padding: 15px; border-radius: 8px; border-left: 4px solid #2196F3; margin-bottom: 15px;">
          <div style="font-weight: bold; color: #1976D2; margin-bottom: 8px;">üìã Mode Expert Activ√©</div>
          <div style="font-size: 14px; color: #555;">
            La limitation de course active sera <strong>D√âSACTIV√âE</strong> :
          </div>
        </div>
        
        <div style="display: grid; grid-template-columns: auto 1fr; gap: 10px; margin: 15px 0; padding: 15px; background: #FFF3E0; border-radius: 8px;">
          <div style="font-weight: bold; color: #FF9800;">‚Ä¢ Actuel :</div>
          <div id="seqModalCurrentLimit" style="color: #FF9800; font-weight: bold;">--</div>
          <div style="font-weight: bold; color: #4CAF50;">‚Ä¢ Apr√®s :</div>
          <div id="seqModalAfterLimit" style="color: #4CAF50; font-weight: bold;">--</div>
        </div>
        
        <div style="background: #F5F5F5; padding: 12px; border-radius: 8px; margin-bottom: 15px;">
          <div style="font-weight: bold; margin-bottom: 8px;">üîß Raison :</div>
          <div style="font-size: 13px; color: #666; line-height: 1.5;">
            Le s√©quenceur peut contenir des lignes de calibration qui r√©initialisent cette limite.
          </div>
        </div>
        
        <div style="background: #E8F5E9; padding: 12px; border-radius: 8px; border-left: 4px solid #4CAF50;">
          <div style="font-weight: bold; color: #2E7D32; margin-bottom: 5px;">üí° En mode s√©quenceur :</div>
          <div style="font-size: 13px; color: #555;">
            Vous avez le <strong>contr√¥le total</strong> des valeurs de chaque ligne.
          </div>
        </div>
        
        <div style="margin-top: 20px; text-align: center; font-weight: bold; color: #333;">
          Continuer ?
        </div>
      </div>
      <div class="modal-buttons">
        <button class="button btn-danger" onclick="cancelSequencerLimitChange()">Annuler</button>
        <button class="button btn-success" onclick="confirmSequencerLimitChange()">Confirmer</button>
      </div>
    </div>
  </div>

  <div class="container">
    <!-- Common Status (COMPACT VERSION) -->
    <div class="status-compact" style="background:white; border-radius:8px; box-shadow:0 2px 8px rgba(0,0,0,0.1); margin-bottom:15px; overflow:hidden;">
      
      <!-- Header Row: √âtat + Actions -->
      <div style="display:flex; justify-content:space-between; align-items:center; padding:8px 15px; background:#E3F2FD; border-bottom:1px solid #BBDEFB;">
        <span style="font-weight:bold; font-size:15px; color:#1976D2;">
          √âtat: <span id="state" style="color:#333;">Initialisation...</span>
        </span>
        <div style="display:flex; gap:6px;">
          <button class="btn-compact btn-primary" id="btnCalibrateCommon" title="Calibrer les limites">üîç Calib</button>
          <button class="btn-compact btn-info" id="btnShowLogs" title="Afficher logs">üìã Logs</button>
          
          <button class="btn-compact btn-success" id="btnShowStats" title="Afficher statistiques">üìä Stats</button>
          <button class="btn-compact" id="btnShowSystem" title="Afficher statistiques syst√®me" style="background: #2196F3; color: white;">‚öôÔ∏è Sys</button>
        </div>
      </div>
      
      <!-- Row 2: Position + Course -->
      <div style="padding:6px 15px; font-size:13px; border-bottom:1px solid #f0f0f0;">
        üìç <strong>Position:</strong> <span id="position">0.0 mm (0 steps)</span>
        &nbsp;&nbsp;‚Ä¢&nbsp;&nbsp;
        <strong>Course:</strong> <span id="totalDist">-- mm</span>
        <button id="btnConfigMaxDist" class="btn-icon" title="Limiter course" style="padding:2px 6px; font-size:13px; background:transparent; border:1px solid #ddd; border-radius:3px; cursor:pointer; margin-left:4px;">‚öôÔ∏è</button>
      </div>
      
      <!-- Max Distance Config Panel (collapsible) -->
      <div id="maxDistConfigPanel" style="display:none; padding:10px 15px; background:#FFF3E0; border-bottom:1px solid #FFE0B2;">
        <div style="font-weight:bold; color:#FF9800; margin-bottom:6px; font-size:12px;">‚öôÔ∏è Limitation de course</div>
        <div style="font-size:11px; color:#666; margin-bottom:8px;">
          ‚ÑπÔ∏è Limite la zone utilisable sans recalibrer
        </div>
        <div style="display:flex; align-items:center; gap:8px; margin-bottom:6px;">
          <span style="font-size:11px; font-weight:bold; min-width:45px;">Limite:</span>
          <input type="range" id="maxDistLimitSlider" min="50" max="100" value="100" step="1" style="flex:1; height:6px;" disabled>
          <span id="maxDistLimitValue" style="font-weight:bold; font-size:12px; min-width:40px;">100%</span>
          <span id="maxDistLimitMM" style="color:#666; font-size:11px; min-width:70px;">(-- mm)</span>
        </div>
        <div style="display:flex; gap:6px;">
          <button id="btnApplyMaxDistLimit" class="btn-compact btn-success" disabled>‚úÖ OK</button>
          <button id="btnCancelMaxDistLimit" class="btn-compact btn-secondary">‚úï Annuler</button>
        </div>
        <div style="font-size:10px; color:#d32f2f; margin-top:6px; display:none;" id="maxDistLimitWarning">
          ‚ö†Ô∏è Modification en √©tat PR√äT uniquement
        </div>
      </div>
      
      <!-- Row 3: Vitesses -->
      <div style="padding:6px 15px; font-size:13px; border-bottom:1px solid #f0f0f0;">
        ‚ö° <strong>Vitesse:</strong> <span id="currentSpeed">‚ÜóÔ∏è --  ‚Ä¢  ‚ÜôÔ∏è --</span>
        <span style="color:#999; font-size:11px; margin-left:8px;">(-- c/min)</span>
      </div>
      
      <!-- Row 4: Distance + Progress Bar (colonnes fixes) -->
      <div style="padding:6px 15px; font-size:13px; display:grid; grid-template-columns: 280px 1fr 50px; gap:10px; align-items:center; border-bottom:1px solid #f0f0f0;">
        <div style="white-space:nowrap;">
          üìä <strong>Distance:</strong> <span id="milestoneIcon" style="font-size: 20px; margin-left: 8px; cursor: help; display: inline-block; transition: transform 0.3s;" title=""></span> <span id="totalTraveled">0.000 m</span> <button class="btn-icon" id="btnResetDistanceCommon" title="R√©initialiser distance" style="padding:2px 6px; font-size:13px; background:transparent; border:1px solid #ddd; border-radius:3px; cursor:pointer; margin-left:4px;">‚Üª</button>
          
        </div>
        <div style="height:8px; background:#e0e0e0; border-radius:4px; overflow:hidden;">
          <div id="progressMini" style="width:0%; height:100%; background:linear-gradient(90deg,#2196F3,#21CBF3); transition:width 0.3s;"></div>
        </div>
        <span id="progressPct" style="font-weight:bold; font-size:12px; text-align:right;">0.0%</span>
      </div>
      
      <!-- Pending Changes Alert (conditional) -->
      <div id="pendingChanges" style="display:none; padding:6px 15px; background:#FFF3E0; color:#FF9800; font-weight:bold; font-size:12px; border-bottom:1px solid #FFE0B2;">
        ‚è≥ Changements en attente (fin de cycle)
      </div>
      
    </div>

    <!-- Logs Panel (hidden by default) -->
    <div id="logsPanel" style="display: none; background: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); margin-bottom: 15px;">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; border-bottom: 2px solid #2196F3; padding-bottom: 8px;">
        <h3 style="margin: 0; color: #2196F3; font-size: 18px;">üìã Logs & Debug</h3>
        <button id="btnCloseLogs" style="background: #f44336; color: white; border: none; padding: 4px 10px; border-radius: 5px; cursor: pointer; font-size: 14px;">‚úï</button>
      </div>

      <!-- Log Console -->
      <div style="margin-bottom: 12px;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
          <label style="font-weight: bold; color: #333; font-size: 13px;">Console temps r√©el:</label>
          <div style="display: flex; gap: 6px;">
            <button class="button btn-secondary" id="btnClearLogsPanel" style="padding: 4px 10px; font-size: 11px;">üóëÔ∏è Effacer</button>
          </div>
        </div>
        <div id="logConsolePanel" style="height: 180px; overflow: auto; background: #1e1e1e; color: #d4d4d4; padding: 8px; border-radius: 4px; font-family: 'Courier New', monospace; font-size: 11px; white-space: pre-wrap; border: 1px solid #333;">(les logs appara√Ætront ici...)</div>
      </div>

      <!-- Debug Controls -->
      <div style="background: #f5f5f5; padding: 10px; border-radius: 6px; margin-bottom: 12px;">
        <label style="font-weight: bold; color: #333; display: block; margin-bottom: 8px; font-size: 13px;">‚öôÔ∏è Niveau de debug:</label>
        <div style="display: flex; gap: 8px; align-items: center;">
          <label style="display: flex; align-items: center; cursor: pointer;">
            <input type="checkbox" id="debugLevelCheckbox" style="width: 16px; height: 16px; margin-right: 6px;">
            <span style="font-size: 12px;">Activer logs DEBUG (verbose)</span>
          </label>
          <span style="color: #666; font-size: 11px; margin-left: auto;">‚ö†Ô∏è Peut ralentir</span>
        </div>
      </div>

      <!-- Historical Logs -->
      <div style="background: #fff3cd; padding: 10px; border-radius: 6px; border-left: 4px solid #ffc107;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
          <label style="font-weight: bold; color: #856404; font-size: 13px;">üìö Historique des logs:</label>
          <button class="button btn-danger" id="btnClearAllLogFiles" style="padding: 4px 10px; font-size: 11px;">üóëÔ∏è Nettoyer tout</button>
        </div>
        <div id="logFilesList" style="max-height: 130px; overflow-y: auto; background: white; padding: 8px; border-radius: 4px; border: 1px solid #ddd;">
          <div style="color: #999; font-style: italic; font-size: 11px;">Chargement de la liste...</div>
        </div>
      </div>
    </div>

    <!-- Statistics Panel -->
    <div id="statsPanel" style="display: none; background: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); margin-bottom: 15px;">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; border-bottom: 2px solid #4CAF50; padding-bottom: 8px;">
        <h3 style="margin: 0; color: #4CAF50; font-size: 18px;">üìä Statistiques</h3>
        <button id="btnCloseStats" style="background: #f44336; color: white; border: none; padding: 4px 10px; border-radius: 5px; cursor: pointer; font-size: 14px;">‚úï</button>
      </div>

      <!-- Stats Table -->
      <div style="margin-bottom: 20px; overflow-x: auto;">
        <table id="statsTable" style="width: 100%; border-collapse: collapse; font-size: 13px;">
          <thead>
            <tr style="background: #f5f5f5; border-bottom: 2px solid #4CAF50;">
              <th style="padding: 8px; text-align: left; font-weight: bold;">Date</th>
              <th style="padding: 8px; text-align: center; font-weight: bold;">Jour</th>
              <th style="padding: 8px; text-align: center; font-weight: bold;">üèÜ</th>
              <th style="padding: 8px; text-align: right; font-weight: bold;">Distance</th>
            </tr>
          </thead>
          <tbody id="statsTableBody">
            <tr>
              <td colspan="4" style="padding: 20px; text-align: center; color: #999; font-style: italic;">Aucune statistique disponible</td>
            </tr>
          </tbody>
          <tfoot>
            <tr style="background: #e8f5e9; border-top: 2px solid #4CAF50; font-weight: bold;">
              <td style="padding: 10px;">TOTAL</td>
              <td style="padding: 10px; text-align: center;">üèÜ</td>
              <td id="statsTotalMilestone" style="padding: 10px; text-align: center; font-size: 18px;">üéØ</td>
              <td id="statsTotalDistance" style="padding: 10px; text-align: right; color: #4CAF50; font-size: 15px;">0 km</td>
            </tr>
          </tfoot>
        </table>
      </div>

      <!-- Clear Stats Button -->
      <div style="margin-bottom: 20px; text-align: center;">
        <button id="btnClearStats" class="button btn-danger" style="padding: 8px 20px; font-size: 13px;">
          üóëÔ∏è Effacer toutes les statistiques
        </button>
      </div>

      <!-- Histogram -->
      <div style="background: #f9f9f9; padding: 12px; border-radius: 6px; border: 1px solid #ddd;">
        <h4 style="margin: 0 0 12px 0; color: #333; font-size: 14px;">üìà Historique (3 mois glissants)</h4>
        <canvas id="statsChart" style="max-height: 250px;"></canvas>
      </div>
    </div>

    <!-- System Stats Panel (hidden by default like Stats panel) -->
    <div id="systemPanel" style="display: none; background: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); margin-bottom: 15px;">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; border-bottom: 2px solid #2196F3; padding-bottom: 8px;">
        <h3 style="margin: 0; color: #2196F3; font-size: 18px;">‚öôÔ∏è Syst√®me</h3>
        <button id="btnCloseSystem" style="background: #f44336; color: white; border: none; padding: 4px 10px; border-radius: 5px; cursor: pointer; font-size: 14px;">‚úï</button>
      </div>

      <!-- System Stats Grid -->
      <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; font-size: 13px;">
        <div style="background: #f5f5f5; padding: 10px; border-radius: 6px;">
          <div style="color: #666; font-size: 11px; margin-bottom: 4px;">CPU</div>
          <div id="sysCpuFreq" style="font-weight: bold; color: #333; font-size: 15px;">-- MHz</div>
        </div>
        
        <div style="background: #f5f5f5; padding: 10px; border-radius: 6px;">
          <div style="color: #666; font-size: 11px; margin-bottom: 4px;">üå°Ô∏è Temp√©rature</div>
          <div id="sysTemp" style="font-weight: bold; color: #333; font-size: 15px;">-- ¬∞C</div>
        </div>
        
        <div style="background: #f5f5f5; padding: 10px; border-radius: 6px;">
          <div style="color: #666; font-size: 11px; margin-bottom: 4px;">üíæ RAM</div>
          <div id="sysRam" style="font-weight: bold; color: #333; font-size: 15px;">-- KB libre</div>
          <div id="sysRamPercent" style="font-size: 11px; color: #666; margin-top: 2px;">--% utilis√©</div>
        </div>
        
        <div style="background: #f5f5f5; padding: 10px; border-radius: 6px;">
          <div style="color: #666; font-size: 11px; margin-bottom: 4px;">üß† PSRAM</div>
          <div id="sysPsram" style="font-weight: bold; color: #333; font-size: 15px;">-- MB libre</div>
          <div id="sysPsramPercent" style="font-size: 11px; color: #666; margin-top: 2px;">--% utilis√©</div>
        </div>
        
        <div style="background: #f5f5f5; padding: 10px; border-radius: 6px;">
          <div style="color: #666; font-size: 11px; margin-bottom: 4px;">üì∂ WiFi</div>
          <div id="sysWifi" style="font-weight: bold; color: #333; font-size: 15px;">-- dBm</div>
          <div id="sysWifiQuality" style="font-size: 11px; color: #666; margin-top: 2px;">--</div>
        </div>
        
        <div style="background: #f5f5f5; padding: 10px; border-radius: 6px;">
          <div style="color: #666; font-size: 11px; margin-bottom: 4px;">‚ö° Uptime</div>
          <div id="sysUptime" style="font-weight: bold; color: #333; font-size: 15px;">--</div>
        </div>
      </div>
    </div>

    <!-- Welcome message (shown before first calibration) -->
    <div class="welcome-message" id="welcomeMessage">
      <h2>üëã Bienvenue!</h2>
      <p>üîß Avant de commencer, veuillez effectuer une calibration pour d√©tecter les limites de course.</p>
      <p>üëÜ Cliquez sur le bouton <strong>"üîç Calibrer"</strong> dans la section "Outils communs" ci-dessus.</p>
      <p style="font-size: 14px; opacity: 0.8; margin-top: 20px;">
        ‚öôÔ∏è Les modes de contr√¥le appara√Ætront automatiquement apr√®s la calibration.
      </p>
    </div>

    <!-- Tabs Navigation (after status) -->
    <div class="tabs hidden-until-calibrated" id="tabsContainer">
      <button class="tab active" data-tab="simple">üîÑ Simple</button>
      <button class="tab" data-tab="pursuit">üéØ Poursuite</button>
      <button class="tab" data-tab="oscillation">„Ä∞Ô∏è Oscillation</button>
      <button class="tab" data-tab="chaos">üé≤ Chaos</button>
      <button class="tab" data-tab="tableau">üìã S√©quenceur</button>
    </div>

    <!-- MODE SIMPLE Tab Content -->
    <div class="tab-content active hidden-until-calibrated" id="tabSimple">
      <div class="controls">
        
      <!-- Position/Distance - 2-Column Grid -->
      <div class="form-row-compact">
        <div class="form-group-compact" style="display: block;">
          <div>
            <label class="label-inline">Position d√©part:</label>
            <input type="number" id="startPosition" min="0" step="0.1" value="0" class="input-compact">
            <span class="unit-label">mm</span>
          </div>
          <div style="margin-top: 8px;">
            <button class="preset-btn-sm btn-preset" data-start="0">0mm</button>
            <button class="preset-btn-sm btn-preset" data-start="25">25mm</button>
            <button class="preset-btn-sm btn-preset" data-start="50">50mm</button>
            <button class="preset-btn-sm btn-preset" data-start="75">75mm</button>
            <button class="preset-btn-sm btn-preset" data-start="100">100mm</button>
          </div>
        </div>
        
        <div class="form-group-compact" style="display: block;">
          <div>
            <label class="label-inline">Distance:</label>
            <input type="number" id="distance" min="0" step="0.1" value="50" class="input-compact">
            <span class="unit-label">mm</span>
          </div>
          <div style="margin-top: 8px;">
            <button class="preset-btn-sm btn-preset" data-distance="25">25mm</button>
            <button class="preset-btn-sm btn-preset" data-distance="50">50mm</button>
            <button class="preset-btn-sm btn-preset" data-distance="75">75mm</button>
            <button class="preset-btn-sm btn-preset" data-distance="100">100mm</button>
            <button class="preset-btn-sm btn-preset" data-distance="125">125mm</button>
          </div>
        </div>
      </div>
      
      <!-- S√©parateur -->
      <div style="border-top: 1px solid #ddd; margin: 15px 0;"></div>
      
      <!-- Speed Mode Toggle - Radio Buttons -->
      <div class="form-group-compact" style="margin-bottom: 15px;">
        <label class="label-inline">‚öôÔ∏è Vitesse:</label>
        <div class="radio-inline">
          <label>
            <input type="radio" name="speedMode" id="speedModeUnified" checked>
            Unifi√©e
          </label>
          <label>
            <input type="radio" name="speedMode" id="speedModeSeparate">
            S√©par√©e
          </label>
        </div>
      </div>
      
      <!-- Unified Speed - Single Line -->
      <div id="speedUnifiedGroup" class="speed-control-inline" style="margin-bottom: 12px;">
        <label class="label-inline">Vitesse:</label>
        <input type="number" id="speedUnified" min="0" max="20" step="0.1" value="5" class="input-compact">
        <button class="preset-btn-sm btn-preset" data-speed-unified="0.5" title="Ultra lent">0.5 üêå</button>
        <button class="preset-btn-sm btn-preset" data-speed-unified="1" title="Tr√®s lent">1</button>
        <button class="preset-btn-sm btn-preset" data-speed-unified="2">2</button>
        <button class="preset-btn-sm btn-preset" data-speed-unified="3">3</button>
        <button class="preset-btn-sm btn-preset active" data-speed-unified="5" title="Normal">5 ‚úì</button>
        <button class="preset-btn-sm btn-preset" data-speed-unified="10">10</button>
        <button class="preset-btn-sm btn-preset" data-speed-unified="15">15</button>
        <button class="preset-btn-sm btn-preset" data-speed-unified="20" title="Maximum">20 ‚ö°</button>
      </div>
      
      <!-- Separate Speeds - Stacked -->
      <div id="speedSeparateGroup" style="display: none; margin-bottom: 12px;">
        <div class="speed-control-inline" style="margin-bottom: 8px;">
          <label class="label-inline">Aller:</label>
          <input type="number" id="speedForward" min="0" max="20" step="0.1" value="5" class="input-compact">
          <button class="preset-btn-sm btn-preset" data-speed-forward="0.5">0.5 üêå</button>
          <button class="preset-btn-sm btn-preset" data-speed-forward="1">1</button>
          <button class="preset-btn-sm btn-preset" data-speed-forward="2">2</button>
          <button class="preset-btn-sm btn-preset" data-speed-forward="3">3</button>
          <button class="preset-btn-sm btn-preset active" data-speed-forward="5">5 ‚úì</button>
          <button class="preset-btn-sm btn-preset" data-speed-forward="10">10</button>
          <button class="preset-btn-sm btn-preset" data-speed-forward="15">15</button>
          <button class="preset-btn-sm btn-preset" data-speed-forward="20">20 ‚ö°</button>
        </div>
        <div class="speed-control-inline">
          <label class="label-inline">Retour:</label>
          <input type="number" id="speedBackward" min="0" max="20" step="0.1" value="5" class="input-compact">
          <button class="preset-btn-sm btn-preset" data-speed-backward="0.5">0.5 üêå</button>
          <button class="preset-btn-sm btn-preset" data-speed-backward="1">1</button>
          <button class="preset-btn-sm btn-preset" data-speed-backward="2">2</button>
          <button class="preset-btn-sm btn-preset" data-speed-backward="3">3</button>
          <button class="preset-btn-sm btn-preset active" data-speed-backward="5">5 ‚úì</button>
          <button class="preset-btn-sm btn-preset" data-speed-backward="10">10</button>
          <button class="preset-btn-sm btn-preset" data-speed-backward="15">15</button>
          <button class="preset-btn-sm btn-preset" data-speed-backward="20">20 ‚ö°</button>
        </div>
      </div>

      <!-- S√©parateur -->
      <div style="border-top: 1px solid #ddd; margin: 15px 0;"></div>

      <!-- Deceleration - Collapsible Section -->
      <div class="section-collapsible collapsed" id="decelSection">
        <div class="section-collapsible-header" onclick="toggleDecelSection()">
          <span class="collapse-icon">‚ñº</span> <span id="decelHeaderText">üéØ D√©c√©l√©ration - d√©sactiv√©e</span>
        </div>
        
        <div class="section-collapsible-content">
          <!-- Zone -->
          <div class="speed-control-inline" style="margin-bottom: 10px;">
            <label class="label-inline">Zone:</label>
            <input type="number" id="decelZoneMM" min="10" max="200" step="5" value="50" class="input-compact">
            <span class="unit-label">mm</span>
            <button class="preset-btn-sm btn-preset" data-decel-zone="10">10</button>
            <button class="preset-btn-sm btn-preset" data-decel-zone="25">25</button>
            <button class="preset-btn-sm btn-preset active" data-decel-zone="50">50</button>
            <button class="preset-btn-sm btn-preset" data-decel-zone="75">75</button>
          </div>
          
          <!-- Mode, Effect, D√©but/Fin - All on one line -->
          <div class="speed-control-inline" style="margin-bottom: 10px;">
            <label class="label-inline">Mode:</label>
            <select id="decelModeSelect" style="width: 120px; padding: 6px; font-size: 13px; border: 1px solid #ddd; border-radius: 4px;">
              <option value="0">Lin√©aire</option>
              <option value="1" selected>Sinuso√Ødal</option>
              <option value="2">Triangle Inv.</option>
              <option value="3">Sinus Inv.</option>
            </select>
            
            <span style="margin-left: 10px; font-size: 13px; font-weight: 500;">Effet:</span>
            <input type="range" id="decelEffectPercent" min="0" max="100" step="5" value="75" style="width: 100px;">
            <span id="effectValue" style="font-weight: bold; min-width: 35px; font-size: 13px;">75%</span>
            
            <span style="margin-left: 10px; font-size: 13px;">-</span>
            <label style="margin-left: 5px; font-size: 13px;">
              <input type="checkbox" id="decelZoneStart" checked style="margin-right: 3px;">
              D√©but
            </label>
            <label style="margin-left: 10px; font-size: 13px;">
              <input type="checkbox" id="decelZoneEnd" checked style="margin-right: 3px;">
              Fin
            </label>
          </div>
          
          <!-- Canvas Preview -->
          <canvas id="decelPreview" class="canvas-compact" width="300" height="100"></canvas>
        </div>
      </div>

    <div class="button-group">
      <button class="button btn-success" id="btnStart">‚ñ∂ D√©marrer</button>
      <button class="button btn-warning" id="btnPause">‚è∏ Pause</button>
      <button class="button btn-danger" id="btnStop">‚èπ Arr√™ter</button>
      <button class="button btn-info" id="btnManagePlaylistSimple">
        üìã Playlist (0/20)
      </button>
    </div>
    

    </div>
    </div>
    <!-- END MODE SIMPLE -->

    <!-- MODE POURSUITE Tab Content -->
    <div class="tab-content hidden-until-calibrated" id="tabPursuit">
      <div class="controls">
        
        <!-- Pursuit Controls -->
        <div style="display: flex; gap: 30px; align-items: flex-start; margin-bottom: 20px;">
          
          <!-- Left Side: Gauge -->
          <div style="flex: 0 0 200px;">
            <div style="text-align: center; margin-bottom: 10px;">
              <strong style="color: #333;">Jauge de Position</strong>
            </div>
            
            <!-- Gauge Container -->
            <div id="gaugeContainer" style="position: relative; width: 120px; height: 500px; margin: 0 auto; background: linear-gradient(180deg, #f44336 0%, #FF9800 20%, #FFC107 40%, #4CAF50 60%, #2196F3 80%, #9C27B0 100%); border: 3px solid #333; border-radius: 10px; cursor: crosshair; box-shadow: 0 4px 10px rgba(0,0,0,0.2);">
              
              <!-- Target Cursor (user control) -->
              <div id="gaugeCursor" style="position: absolute; left: -5px; right: -5px; height: 8px; background: #FF5722; border: 3px solid white; border-radius: 4px; cursor: grab; box-shadow: 0 2px 8px rgba(0,0,0,0.5); transition: top 0.05s linear; z-index: 10;">
                <div style="position: absolute; right: -60px; top: -8px; background: #FF5722; color: white; padding: 4px 8px; border-radius: 4px; font-size: 11px; font-weight: bold; white-space: nowrap;">
                  CIBLE
                </div>
              </div>
              
              <!-- Current Position Indicator -->
              <div id="gaugePosition" style="position: absolute; left: 0; right: 0; height: 6px; background: #00E676; border: 2px solid white; border-radius: 3px; box-shadow: 0 2px 8px rgba(0,255,118,0.6); transition: top 0.1s linear; z-index: 5;">
                <div style="position: absolute; left: -60px; top: -8px; background: #00E676; color: white; padding: 4px 8px; border-radius: 4px; font-size: 11px; font-weight: bold; white-space: nowrap;">
                  R√âEL
                </div>
              </div>
              
              <!-- Software Limit Line (dynamically positioned if limit < 100%) -->
              <div id="gaugeLimitLine" style="position: absolute; left: -8px; right: -8px; height: 3px; background: #000; border-top: 2px dashed #FF5722; display: none; z-index: 15;">
                <div style="position: absolute; right: -90px; top: -10px; background: #000; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px; font-weight: bold; white-space: nowrap;">
                  üö´ LIMITE
                </div>
              </div>
              
              <!-- Scale markers -->
              <div style="position: absolute; right: -40px; top: 0; height: 100%; display: flex; flex-direction: column; justify-content: space-between; font-size: 11px; color: #666;">
                <span>FIN ‚ñ∂</span>
                <span>75% ‚ñ∂</span>
                <span>50% ‚ñ∂</span>
                <span>25% ‚ñ∂</span>
                <span>0mm ‚ñ∂</span>
              </div>
            </div>
            
            <div style="text-align: center; margin-top: 15px; font-size: 12px; color: #666;">
              <div><strong>Cible:</strong> <span id="targetPositionMM" style="color: #FF5722;">0.0</span> mm</div>
              <div><strong>Actuel:</strong> <span id="currentPositionMM" style="color: #00E676;">0.0</span> mm</div>
              <div><strong>√âcart:</strong> <span id="positionError" style="color: #666;">0.0</span> mm</div>
            </div>
          </div>
          
          <!-- Right Side: Settings -->
          <div style="flex: 1;">
            <!-- Checkbox Activer - COMPACT -->
            <div style="padding: 10px 15px; background: #E3F2FD; border-radius: 6px; margin-bottom: 15px;">
              <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                <input type="checkbox" id="pursuitActiveCheckbox" autocomplete="off">
                <span style="font-weight: 500; color: #1976D2;">üéØ Activer poursuite</span>
              </label>
              <small style="color: #666; display: block; margin-top: 4px; font-size: 11px; padding-left: 28px;">
                ‚ö†Ô∏è Le moteur suivra automatiquement le curseur
              </small>
            </div>
            
            <!-- Vitesse max - COMPACT -->
            <div class="form-group-compact" style="display: block;">
              <div>
                <label class="label-inline">Vitesse max:</label>
                <input type="number" id="pursuitMaxSpeed" min="0.5" max="20" step="0.5" value="10" class="input-compact">
                <span class="unit-label">(0-20)</span>
              </div>
              <div style="margin-top: 8px;">
                <button class="preset-btn-sm btn-preset" data-pursuit-speed="2">2üêå</button>
                <button class="preset-btn-sm btn-preset" data-pursuit-speed="5">5</button>
                <button class="preset-btn-sm btn-preset active" data-pursuit-speed="10">10‚úì</button>
                <button class="preset-btn-sm btn-preset" data-pursuit-speed="15">15</button>
                <button class="preset-btn-sm btn-preset" data-pursuit-speed="20">20‚ö°</button>
              </div>
            </div>
          </div>
        </div>

        <div class="button-group">
          <button class="button btn-success" id="btnActivatePursuit">‚ñ∂ D√©marrer</button>
          <button class="button btn-danger" id="btnStopPursuit">‚èπ Arr√™ter</button>
        </div>
      </div>
    </div>
    <!-- END MODE POURSUITE -->

    <!-- MODE OSCILLATION Tab Content -->
    <div class="tab-content hidden-until-calibrated" id="tabOscillation">
      <div class="controls">
        
        <!-- Help Section (masqu√©e par d√©faut) -->
        <div id="oscHelpSection" style="display: none; background: #fff3cd; border-left: 4px solid #ffc107; padding: 12px; margin-bottom: 15px; border-radius: 4px; font-size: 12px;">
          <strong style="color: #856404;">üí° Conseils d'utilisation:</strong>
          <ul style="margin: 8px 0 0 20px; color: #856404;">
            <li><strong>Forme sinuso√Ødale:</strong> Mouvement fluide et doux, id√©al pour tests m√©caniques (comme une vague üåä)</li>
            <li><strong>Forme triangle:</strong> Acc√©l√©ration/d√©c√©l√©ration lin√©aire constante (mouvement m√©canique)</li>
            <li><strong>Forme carr√©e:</strong> Changements de direction instantan√©s (attention aux contraintes m√©caniques!)</li>
            <li><strong>Rampes:</strong> √âvitent les √†-coups au d√©marrage/arr√™t en augmentant/r√©duisant progressivement l'amplitude</li>
            <li><strong>Limites auto:</strong> L'amplitude est automatiquement limit√©e aux bornes calibr√©es</li>
            <li><strong>Modification temps r√©el:</strong> Vous pouvez changer les param√®tres pendant l'oscillation!</li>
          </ul>
        </div>

        <!-- Configuration principale - COMPACT -->
        <div class="form-row-compact">
          <!-- Centre -->
          <div class="form-group-compact" style="display: block;">
            <div>
              <label class="label-inline">Centre:</label>
              <input type="number" id="oscCenter" min="0" step="0.1" value="0" class="input-compact">
              <span class="unit-label">mm</span>
            </div>
            <div style="margin-top: 8px;">
              <button class="preset-btn-sm btn-preset" data-osc-center="25">25mm</button>
              <button class="preset-btn-sm btn-preset" data-osc-center="50">50mm</button>
              <button class="preset-btn-sm btn-preset" data-osc-center="75">75mm</button>
              <button class="preset-btn-sm btn-preset" data-osc-center="110">110mm</button>
            </div>
          </div>
          
          <!-- Amplitude -->
          <div class="form-group-compact" style="display: block;">
            <div>
              <label class="label-inline">Amplitude ¬±:</label>
              <input type="number" id="oscAmplitude" min="1" step="0.1" value="20" class="input-compact">
              <span class="unit-label">mm</span>
            </div>
            <div style="margin-top: 8px;">
              <button class="preset-btn-sm btn-preset" data-osc-amplitude="10">10mm</button>
              <button class="preset-btn-sm btn-preset" data-osc-amplitude="25">25mm</button>
              <button class="preset-btn-sm btn-preset" data-osc-amplitude="50">50mm</button>
              <button class="preset-btn-sm btn-preset" data-osc-amplitude="75">75mm</button>
              <button class="preset-btn-sm btn-preset" data-osc-amplitude="100">100mm</button>
            </div>
          </div>
        </div>
        
        <!-- Warning limite (compact) -->
        <div id="oscLimitWarning" style="display:none; color: #f44336; font-size: 12px; padding: 5px 10px; background: #ffe5e5; border-radius: 4px; margin-bottom: 10px;">
          ‚ö†Ô∏è Limites d√©pass√©es! Ajuster centre ou amplitude.
        </div>
        
        <!-- S√©parateur -->
        <div style="border-top: 1px solid #ddd; margin: 15px 0;"></div>
        
        <!-- Forme + Fr√©quence inline -->
        <div class="speed-control-inline" style="margin-bottom: 12px;">
          <label class="label-inline">Forme:</label>
          <select id="oscWaveform" style="width: 150px; padding: 5px; font-size: 12px; border: 2px solid #ddd; border-radius: 4px;">
            <option value="0">Sinuso√Ødale</option>
            <option value="1">Triangle</option>
            <option value="2">Carr√©e</option>
          </select>
          <label class="label-inline" style="margin-left: 15px;">Fr√©quence:</label>
          <input type="number" id="oscFrequency" min="0.01" max="10" step="0.01" value="0.5" class="input-compact">
          <span class="unit-label">Hz</span>
          <button class="preset-btn-sm btn-preset" data-osc-frequency="0.1">0.1Hz</button>
          <button class="preset-btn-sm btn-preset" data-osc-frequency="0.25">0.25Hz</button>
          <button class="preset-btn-sm btn-preset" data-osc-frequency="0.5">0.5Hz</button>
          <button class="preset-btn-sm btn-preset" data-osc-frequency="1">1Hz</button>
          <button class="preset-btn-sm btn-preset" data-osc-frequency="2">2Hz</button>
        </div>
        
        <!-- S√©parateur -->
        <div style="border-top: 1px solid #ddd; margin: 15px 0;"></div>

        <!-- Rampes inline (pas d'accordion) -->
        <div class="speed-control-inline" style="margin-bottom: 10px;">
          <label style="display: flex; align-items: center; cursor: pointer;">
            <input type="checkbox" id="oscRampInEnable" checked style="width: auto; margin-right: 5px;">
            <span style="font-size: 12px;">Rampe entr√©e:</span>
          </label>
          <input type="number" id="oscRampInDuration" min="100" step="100" value="2000" class="input-compact" style="width: 70px;">
          <span class="unit-label">ms</span>
          
          <label style="display: flex; align-items: center; cursor: pointer; margin-left: 20px;">
            <input type="checkbox" id="oscRampOutEnable" checked style="width: auto; margin-right: 5px;">
            <span style="font-size: 12px;">Rampe sortie:</span>
          </label>
          <input type="number" id="oscRampOutDuration" min="100" step="100" value="2000" class="input-compact" style="width: 70px;">
          <span class="unit-label">ms</span>
        </div>
        
        <!-- Cycles + Retour centre inline -->
        <div class="speed-control-inline" style="margin-bottom: 12px;">
          <label class="label-inline">Cycles:</label>
          <input type="number" id="oscCycleCount" min="0" step="1" value="0" class="input-compact" style="width: 60px;">
          <span class="unit-label" style="font-size: 11px;">(0=Infini)</span>
          
          <label style="display: flex; align-items: center; cursor: pointer; margin-left: 20px;">
            <input type="checkbox" id="oscReturnCenter" checked style="width: auto; margin-right: 5px;">
            <span style="font-size: 12px;">Retour centre</span>
          </label>
        </div>
        
        <!-- S√©parateur -->
        <div style="border-top: 1px solid #ddd; margin: 15px 0;"></div>

        <!-- √âtat temps r√©el - COMPACT -->
        <div style="background: #e3f2fd; padding: 10px; border-radius: 4px; margin-bottom: 15px;">
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 12px;">
            <div>
              <strong>Amplitude:</strong>
              <span id="oscCurrentAmplitude" style="color: #f5576c; font-weight: bold;">--</span> mm
            </div>
            <div>
              <strong>Cycles:</strong>
              <span id="oscCompletedCycles" style="color: #f5576c; font-weight: bold;">0</span>
            </div>
            <div>
              <strong>Rampe:</strong>
              <span id="oscRampStatus" style="color: #666;">--</span>
            </div>
            <div>
              <strong>Limites:</strong>
              <span id="oscLimitStatus" style="font-weight: bold;">--</span>
            </div>
          </div>
        </div>
        
        <!-- Boutons de contr√¥le (comme Simple - en bas) -->
        <div class="button-group">
          <button class="button btn-success" id="btnStartOscillation">‚ñ∂Ô∏è D√©marrer</button>
          <button class="button btn-warning" id="btnPauseOscillation">‚è∏ Pause</button>
          <button class="button btn-danger" id="btnStopOscillation">‚èπÔ∏è Arr√™ter</button>
          <button class="button btn-info" id="btnManagePlaylistOscillation">
            üìã Playlist (0/20)
          </button>
          <button class="button btn-help" onclick="toggleOscHelp()" style="padding: 12px 20px;">‚ùì</button>
        </div>
        

      </div>
    </div>
    <!-- END MODE OSCILLATION -->

    <!-- MODE CHAOS Tab Content -->
    <div class="tab-content hidden-until-calibrated" id="tabChaos">
      <div class="controls">
        
        <!-- Help Section (masqu√©e par d√©faut) -->
        <div id="chaosHelpSection" style="display: none; background: #fff3cd; border-left: 4px solid #ffc107; padding: 12px; margin-bottom: 15px; border-radius: 4px; font-size: 12px;">
          <strong style="color: #856404;">üí° Patterns Chaos (11 patterns):</strong>
          <p style="margin: 8px 0 0 0; color: #856404; font-weight: bold;">üåä Patterns DOUX (mouvements continus - 45%):</p>
          <ul style="margin: 5px 0 10px 20px; color: #856404;">
            <li><strong>WAVE:</strong> Vagues lentes et continues, fluide, 25-75% vitesse, 4-8s</li>
            <li><strong>PENDULUM:</strong> Balancier r√©gulier, oscillations douces, 30-90% vitesse, 3-6s</li>
            <li><strong>SPIRAL:</strong> Spirale progressive expansion/contraction, 20-75% vitesse, 5-10s</li>
            <li><strong>BREATHING:</strong> Respiration apaisante, petites amplitudes 10-50%, pauses al√©atoires, 15-60% vitesse, 2-5s</li>
          </ul>
          <p style="margin: 8px 0 0 0; color: #856404; font-weight: bold;">‚ö° Patterns DYNAMIQUES (sauts de position - 55%):</p>
          <ul style="margin: 5px 0 10px 20px; color: #856404;">
            <li><strong>ZIGZAG:</strong> Va-et-vient mod√©r√©s, sauts max 60%, 40-100% vitesse, 1-2.5s</li>
            <li><strong>SWEEP:</strong> Balayages bout-√†-bout, 30-90% vitesse, 2-4s</li>
            <li><strong>PULSE:</strong> Impulsions depuis centre ¬±40%, 50-100% vitesse, 0.8-1.5s</li>
            <li><strong>DRIFT:</strong> D√©rive micro-changements 25%, 20-70% vitesse, 3-6s</li>
            <li><strong>BURST:</strong> Sauts ultrarapides 70%, 60-100% vitesse, 0.6-1.2s</li>
            <li><strong>BRUTE FORCE:</strong> B√©lier 3 phases: entr√©e rapide 70-100%, sortie lente 20-30%, pause 200-1500ms</li>
            <li><strong>LIBERATOR:</strong> Extraction 3 phases: entr√©e lente 20-30%, sortie rapide 70-100%, pause 200-1500ms</li>
          </ul>
          <p style="margin: 8px 0 0 0; color: #856404;">
            ‚ú® <strong>45% doux, 55% dynamiques.</strong> Degr√© de folie module vitesse/dur√©e/sauts/pauses.
          </p>
        </div>

        <!-- Configuration principale -->
        <div class="form-row-compact">
          <div class="form-group-compact" style="display: block;">
            <div>
              <label class="label-inline">Centre:</label>
              <input type="number" id="chaosCenterPos" min="0" step="0.1" value="110" class="input-compact">
              <span class="unit-label">mm</span>
            </div>
            <div style="margin-top: 8px;">
              <button class="preset-btn-sm btn-preset" data-chaos-center="25">25mm</button>
              <button class="preset-btn-sm btn-preset" data-chaos-center="50">50mm</button>
              <button class="preset-btn-sm btn-preset" data-chaos-center="75">75mm</button>
              <button class="preset-btn-sm btn-preset" data-chaos-center="110">110mm</button>
            </div>
          </div>
          <div class="form-group-compact" style="display: block;">
            <div>
              <label class="label-inline">Amplitude ¬±:</label>
              <input type="number" id="chaosAmplitude" min="1" step="0.1" value="50" class="input-compact">
              <span class="unit-label">mm</span>
            </div>
            <div style="margin-top: 8px;">
              <button class="preset-btn-sm btn-preset" data-chaos-amplitude="10">10mm</button>
              <button class="preset-btn-sm btn-preset" data-chaos-amplitude="25">25mm</button>
              <button class="preset-btn-sm btn-preset" data-chaos-amplitude="50">50mm</button>
              <button class="preset-btn-sm btn-preset" data-chaos-amplitude="75">75mm</button>
              <button class="preset-btn-sm btn-preset" data-chaos-amplitude="100">100mm</button>
            </div>
          </div>
        </div>

        <!-- S√©parateur -->
        <div style="border-top: 1px solid #ddd; margin: 15px 0;"></div>

        <!-- Vitesse max -->
        <div class="speed-control-inline" style="margin-bottom: 12px;">
          <label class="label-inline">Vitesse max:</label>
          <input type="number" id="chaosMaxSpeed" min="0.5" max="20" step="0.5" value="10" class="input-compact">
          <button class="preset-btn-sm btn-preset" data-chaos-speed="0.5">0.5 üêå</button>
          <button class="preset-btn-sm btn-preset" data-chaos-speed="1">1</button>
          <button class="preset-btn-sm btn-preset" data-chaos-speed="2">2</button>
          <button class="preset-btn-sm btn-preset" data-chaos-speed="5">5 ‚úì</button>
          <button class="preset-btn-sm btn-preset" data-chaos-speed="10">10</button>
          <button class="preset-btn-sm btn-preset" data-chaos-speed="15">15</button>
          <button class="preset-btn-sm btn-preset" data-chaos-speed="20">20 ‚ö°</button>
        </div>

        <!-- Degr√© de folie -->
        <div class="speed-control-inline" style="margin-bottom: 12px;">
          <label class="label-inline">üî• Degr√© folie: <span id="crazinessValue" style="font-weight: bold; color: #C850C0;">50</span>%</label>
          <input type="range" id="chaosCraziness" min="0" max="100" step="5" value="50" style="width: 180px; margin-left: 10px;">
          <button class="preset-btn-sm btn-preset" data-chaos-craziness="0">0% üò¥</button>
          <button class="preset-btn-sm btn-preset" data-chaos-craziness="25">25%</button>
          <button class="preset-btn-sm btn-preset" data-chaos-craziness="50">50% ‚úì</button>
          <button class="preset-btn-sm btn-preset" data-chaos-craziness="75">75%</button>
          <button class="preset-btn-sm btn-preset" data-chaos-craziness="100">100% üî•</button>
        </div>

        <!-- Dur√©e -->
        <div class="speed-control-inline" style="margin-bottom: 12px;">
          <label class="label-inline">Dur√©e:</label>
          <input type="number" id="chaosDuration" min="0" step="1" value="0" class="input-compact" style="width: 70px;">
          <span class="unit-label">s (0=Infini)</span>
          <button class="preset-btn-sm btn-preset" data-chaos-duration="30">30s</button>
          <button class="preset-btn-sm btn-preset" data-chaos-duration="60">60s</button>
          <button class="preset-btn-sm btn-preset" data-chaos-duration="120">120s</button>
          <button class="preset-btn-sm btn-preset" data-chaos-duration="0">‚àû</button>
        </div>

        <!-- S√©parateur -->
        <div style="border-top: 1px solid #ddd; margin: 15px 0;"></div>

        <!-- Accordion: Options avanc√©es -->
        <details style="margin-bottom: 15px; border: 1px solid #ddd; border-radius: 4px; padding: 10px; background: #f9f9f9;">
          <summary style="cursor: pointer; font-weight: bold; font-size: 13px; color: #333;">‚ñº Options avanc√©es</summary>
          
          <!-- Patterns actifs -->
          <div style="margin-top: 10px; padding: 10px; background: #e8f5e9; border-radius: 4px; border-left: 3px solid #4caf50;">
            <label style="font-weight: bold; font-size: 12px; display: block; margin-bottom: 8px;">‚úÖ Patterns actifs:</label>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px; margin-bottom: 8px;">
              <label style="display: flex; align-items: center; background: white; padding: 5px; border-radius: 3px; cursor: pointer; font-size: 11px;">
                <input type="checkbox" id="patternWave" checked style="margin-right: 5px; transform: scale(1.1);">
                <span>üåä WAVE</span>
              </label>
              <label style="display: flex; align-items: center; background: white; padding: 5px; border-radius: 3px; cursor: pointer; font-size: 11px;">
                <input type="checkbox" id="patternPendulum" checked style="margin-right: 5px; transform: scale(1.1);">
                <span>üéØ PENDULUM</span>
              </label>
              <label style="display: flex; align-items: center; background: white; padding: 5px; border-radius: 3px; cursor: pointer; font-size: 11px;">
                <input type="checkbox" id="patternSpiral" checked style="margin-right: 5px; transform: scale(1.1);">
                <span>üåÄ SPIRAL</span>
              </label>
              <label style="display: flex; align-items: center; background: white; padding: 5px; border-radius: 3px; cursor: pointer; font-size: 11px;">
                <input type="checkbox" id="patternZigzag" checked style="margin-right: 5px; transform: scale(1.1);">
                <span>‚ö° ZIGZAG</span>
              </label>
              <label style="display: flex; align-items: center; background: white; padding: 5px; border-radius: 3px; cursor: pointer; font-size: 11px;">
                <input type="checkbox" id="patternSweep" checked style="margin-right: 5px; transform: scale(1.1);">
                <span>‚ÜîÔ∏è SWEEP</span>
              </label>
              <label style="display: flex; align-items: center; background: white; padding: 5px; border-radius: 3px; cursor: pointer; font-size: 11px;">
                <input type="checkbox" id="patternPulse" checked style="margin-right: 5px; transform: scale(1.1);">
                <span>üí´ PULSE</span>
              </label>
              <label style="display: flex; align-items: center; background: white; padding: 5px; border-radius: 3px; cursor: pointer; font-size: 11px;">
                <input type="checkbox" id="patternDrift" checked style="margin-right: 5px; transform: scale(1.1);">
                <span>üå´Ô∏è DRIFT</span>
              </label>
              <label style="display: flex; align-items: center; background: white; padding: 5px; border-radius: 3px; cursor: pointer; font-size: 11px;">
                <input type="checkbox" id="patternBurst" checked style="margin-right: 5px; transform: scale(1.1);">
                <span>üî• BURST</span>
              </label>
              <label style="display: flex; align-items: center; background: white; padding: 5px; border-radius: 3px; cursor: pointer; font-size: 11px;">
                <input type="checkbox" id="patternCalm" checked style="margin-right: 5px; transform: scale(1.1);">
                <span>üòå BREATHING</span>
              </label>
              <label style="display: flex; align-items: center; background: white; padding: 5px; border-radius: 3px; cursor: pointer; font-size: 11px;">
                <input type="checkbox" id="patternBruteForce" checked style="margin-right: 5px; transform: scale(1.1);">
                <span>üî® BRUTE FORCE</span>
              </label>
              <label style="display: flex; align-items: center; background: white; padding: 5px; border-radius: 3px; cursor: pointer; font-size: 11px;">
                <input type="checkbox" id="patternLiberator" checked style="margin-right: 5px; transform: scale(1.1);">
                <span>üîì LIBERATOR</span>
              </label>
            </div>
            <div style="display: flex; gap: 5px; margin-top: 8px;">
              <button class="preset-btn-sm btn-preset" id="btnEnableAllPatterns" style="flex: 1; font-size: 10px; padding: 4px;">‚úÖ Tout</button>
              <button class="preset-btn-sm btn-preset" id="btnEnableSoftPatterns" style="flex: 1; font-size: 10px; padding: 4px;">üåä Doux</button>
              <button class="preset-btn-sm btn-preset" id="btnEnableDynamicPatterns" style="flex: 1; font-size: 10px; padding: 4px;">‚ö° Dynamiques</button>
            </div>
          </div>

          <!-- Seed (optionnel) -->
          <div style="margin-top: 10px;">
            <label class="label-inline" style="font-size: 12px;">Seed (optionnel):</label>
            <input type="number" id="chaosSeed" min="0" step="1" value="0" class="input-compact" style="width: 90px;">
            <span class="unit-label" style="font-size: 11px;">(0=al√©atoire)</span>
          </div>
        </details>

        <!-- S√©parateur -->
        <div style="border-top: 1px solid #ddd; margin: 15px 0;"></div>

        <!-- Real-time Stats Section -->
        <div id="chaosStats" style="display: none; background: #e3f2fd; padding: 10px; border-radius: 4px; margin-bottom: 15px;">
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 12px;">
            <div><strong>Pattern:</strong> <span id="statPattern" style="color: #C850C0;">--</span></div>
            <div><strong>Position:</strong> <span id="statPosition" style="color: #2196F3;">--</span> mm</div>
            <div><strong>Plage:</strong> <span id="statRange" style="color: #2196F3;">--</span> mm</div>
            <div><strong>Patterns:</strong> <span id="statCount" style="color: #2196F3;">0</span></div>
          </div>
          <div id="statTimer" style="margin-top: 8px; text-align: center; font-size: 12px;">
            ‚è±Ô∏è Temps: <span id="statElapsed">0</span>s
          </div>
        </div>

        <!-- Boutons de contr√¥le -->
        <div class="button-group">
          <button class="button btn-success" id="btnStartChaos">‚ñ∂Ô∏è D√©marrer</button>
          <button class="button btn-warning" id="btnPauseChaos">‚è∏ Pause</button>
          <button class="button btn-danger" id="btnStopChaos">‚èπÔ∏è Arr√™ter</button>
          <button class="button btn-info" id="btnManagePlaylistChaos">
            üìã Playlist (0/20)
          </button>
          <button class="button btn-help" onclick="toggleChaosHelp()" style="padding: 12px 20px;">‚ùì</button>
        </div>
      </div>
    </div>
    <!-- END MODE CHAOS -->

    <!-- MODE S√©quenceur Tab Content -->
    <div class="tab-content hidden-until-calibrated" id="tabTableau">
      <div class="controls">
        
        <!-- Toolbar -->
        <div style="display: flex; gap: 8px; margin-bottom: 12px; flex-wrap: wrap;">
          <button class="button btn-success" id="btnAddLine" style="flex: 1; min-width: 110px; padding: 8px; font-size: 13px;">‚ûï Ajouter</button>
          <button class="button btn-warning" id="btnClearAll" style="flex: 1; min-width: 110px; padding: 8px; font-size: 13px;">üóëÔ∏è Effacer</button>
          <button class="button btn-primary" id="btnImportSeq" style="flex: 1; min-width: 110px; padding: 8px; font-size: 13px;">üì• Import</button>
          <button class="button btn-primary" id="btnExportSeq" style="flex: 1; min-width: 110px; padding: 8px; font-size: 13px;">üì§ Export</button>
          <button class="button btn-info" id="btnDownloadTemplate" style="flex: 1; min-width: 110px; padding: 8px; font-size: 13px; background: #17a2b8;" title="T√©l√©charger un template JSON avec exemples">üìÑ Template</button>
        </div>

        <!-- Phase 2: Batch Operations Toolbar (hidden by default) -->
        <div id="sequenceBatchToolbar" class="sequence-batch-toolbar">
          <div class="sequence-batch-info">
            <span id="batchSelectionCount">0 ligne(s) s√©lectionn√©e(s)</span>
          </div>
          <div class="sequence-batch-actions">
            <button class="sequence-batch-btn" onclick="batchEnableLines(true)">
              <span>‚úì</span> Activer
            </button>
            <button class="sequence-batch-btn" onclick="batchEnableLines(false)">
              <span>‚úó</span> D√©sactiver
            </button>
            <div id="sequenceTrashZone" class="sequence-trash-zone">
              <span class="trash-icon">üóëÔ∏è</span>
              <span>Glisser ici</span>
            </div>
            <button class="sequence-batch-btn" onclick="clearSelection()">
              <span>‚úñ</span> Annuler
            </button>
          </div>
        </div>

        <!-- Sequence Table Container -->
        <div style="overflow-x: auto; margin-bottom: 20px; border: 2px solid #ddd; border-radius: 8px; background: white; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
          <table id="sequenceTable" style="width: 100%; border-collapse: collapse; font-size: 11px;">
            <thead>
              <tr style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                <th style="padding: 8px 4px; text-align: center; border-right: 1px solid rgba(255,255,255,0.2); width: 30px;">‚úì</th>
                <th style="padding: 8px 4px; text-align: center; border-right: 1px solid rgba(255,255,255,0.2); width: 30px;">#</th>
                <th style="padding: 8px 4px; text-align: center; border-right: 1px solid rgba(255,255,255,0.2); width: 40px;">Type</th>
                <th style="padding: 8px 6px; text-align: center; border-right: 1px solid rgba(255,255,255,0.2);">D√©but<br><small style="font-size: 9px;">(mm)</small></th>
                <th style="padding: 8px 6px; text-align: center; border-right: 1px solid rgba(255,255,255,0.2);">Dist.<br><small style="font-size: 9px;">(mm)</small></th>
                <th style="padding: 8px 6px; text-align: center; border-right: 1px solid rgba(255,255,255,0.2);">Vitesses<br><small style="font-size: 9px;">A/R</small></th>
                <th style="padding: 8px 6px; text-align: center; border-right: 1px solid rgba(255,255,255,0.2);">D√©cel.</th>
                <th style="padding: 8px 4px; text-align: center; border-right: 1px solid rgba(255,255,255,0.2); width: 45px;">Cycles</th>
                <th style="padding: 8px 4px; text-align: center; border-right: 1px solid rgba(255,255,255,0.2); width: 50px;">‚è±Ô∏è<br><small style="font-size: 9px;">(s)</small></th>
                <th style="padding: 8px 4px; text-align: center;">Actions</th>
              </tr>
            </thead>
            <tbody id="sequenceTableBody">
              <tr>
                <td colspan="10" style="padding: 40px; text-align: center; color: #999;">
                  <div style="font-size: 48px; margin-bottom: 10px;">üìã</div>
                  <div style="font-size: 16px;">Aucune ligne - Cliquez sur "‚ûï Ajouter ligne" pour commencer</div>
                </td>
              </tr>
            </tbody>
          </table>
        </div>

        <!-- Permanent Trash Drop Zone -->
        <div id="sequenceTrashDropZone" class="sequence-trash-drop-zone">
          <span class="trash-icon">üóëÔ∏è</span>
          <span>Glisser une ligne ici pour la supprimer</span>
        </div>

        <!-- Execution Controls -->
        <div style="background: #f5f5f5; padding: 12px; border-radius: 8px; margin-bottom: 15px;">
          <div style="display: flex; gap: 8px; margin-bottom: 12px; flex-wrap: wrap;">
            <button class="button btn-success" id="btnStartSequence" style="flex: 1; min-width: 130px; font-size: 14px; padding: 10px;">
              ‚ñ∂Ô∏è Unique
            </button>
            <button class="button btn-primary" id="btnLoopSequence" style="flex: 1; min-width: 130px; font-size: 14px; padding: 10px; background: #FF9800;">
              üîÅ Boucle
            </button>
            <button class="button btn-warning" id="btnPauseSequence" style="flex: 1; min-width: 90px; font-size: 14px; padding: 10px;" disabled>
              ‚è∏Ô∏è Pause
            </button>
            <button class="button btn-danger" id="btnStopSequence" style="flex: 1; min-width: 90px; font-size: 14px; padding: 10px;" disabled>
              ‚èπÔ∏è Stop
            </button>
            <button class="button btn-primary" id="btnSkipLine" style="flex: 1; min-width: 110px; font-size: 14px; padding: 10px; background: #9C27B0;" disabled>
              ‚è≠Ô∏è Suivant
            </button>
          </div>

          <!-- Sequence Status - COMPACT -->
          <div style="display: flex; gap: 20px; flex-wrap: wrap; font-size: 12px; padding: 10px 15px; background: white; border-radius: 6px; border: 1px solid #ddd;">
            <div><span style="color: #666;">Mode:</span> <strong id="seqMode" style="color: #333;">Arr√™t√©</strong></div>
            <div><span style="color: #666;">Ligne:</span> <strong id="seqCurrentLine" style="color: #2196F3;">-- / --</strong></div>
            <div><span style="color: #666;">Cycle:</span> <strong id="seqLineCycle" style="color: #4CAF50;">--</strong></div>
            <div><span style="color: #666;">Boucles:</span> <strong id="seqLoopCount" style="color: #FF9800;">0</strong></div>
            <div><span style="color: #666;">‚è±Ô∏è Pause:</span> <strong id="seqPauseRemaining" style="color: #9C27B0;">-- ms</strong></div>
          </div>
        </div>

      </div>
    </div>
    <!-- END MODE S√©quenceur -->

    <!-- Modal for Line Editing -->
    <div id="editLineModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); z-index: 9999; overflow-y: auto;" onclick="closeEditLineModalOnOverlayClick(event)">
      <div style="max-width: 600px; margin: 50px auto; background: white; border-radius: 10px; box-shadow: 0 10px 40px rgba(0,0,0,0.3); overflow: hidden;" onclick="event.stopPropagation()">
        
        <!-- Modal Header -->
        <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; display: flex; justify-content: space-between; align-items: center;">
          <h3 style="margin: 0; font-size: 20px;">‚úèÔ∏è √âditer la ligne #<span id="editLineNumber">--</span></h3>
          <button id="btnCloseModal" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 24px; cursor: pointer; width: 35px; height: 35px; border-radius: 50%; line-height: 1;">√ó</button>
        </div>

        <!-- Modal Body -->
        <div style="padding: 25px;">
          <form id="editLineForm">
            
            <!-- Movement Type Selection -->
            <div class="type-selection-row">
              <label class="label-inline">üéõÔ∏è Type:</label>
              <div class="type-selection-buttons">
                <label class="radio-label-inline">
                  <input type="radio" name="movementType" id="editTypeVaet" value="0" checked style="width: auto;">
                  <span>üîÑ Va-et-vient</span>
                </label>
                <label class="radio-label-inline">
                  <input type="radio" name="movementType" id="editTypeOsc" value="1" style="width: auto;">
                  <span>„Ä∞Ô∏è Oscillation</span>
                </label>
                <label class="radio-label-inline">
                  <input type="radio" name="movementType" id="editTypeChaos" value="2" style="width: auto;">
                  <span>üåÄ Chaos</span>
                </label>
                <label class="radio-label-inline">
                  <input type="radio" name="movementType" id="editTypeCalibration" value="4" style="width: auto;">
                  <span>üìè Calibration</span>
                </label>
              </div>
            </div>

            <!-- PLAYLIST PRESETS LOADING (for all modes) -->
            <div id="playlistLoaderSimple" style="background: #E3F2FD; padding: 12px; margin: 15px 0; border-radius: 6px; border: 2px solid #2196F3;">
              <label style="font-weight: 500; color: #1976D2; display: block; margin-bottom: 8px;">üìã Charger un preset Simple:</label>
              <div style="display: flex; gap: 8px; margin-bottom: 8px;">
                <select id="editSimplePresetSelect" onchange="previewSequencerPreset('simple', this.value)" style="flex: 1; padding: 8px; border: 1px solid #2196F3; border-radius: 4px;">
                  <option value="">-- S√©lectionner un preset --</option>
                </select>
                <button type="button" onclick="previewSequencerPreset('simple', document.getElementById('editSimplePresetSelect').value)" style="padding: 8px 12px; background: #64B5F6; color: white; border: none; border-radius: 4px; cursor: pointer;" title="Voir les d√©tails">
                  üëÅÔ∏è
                </button>
              </div>
              <button type="button" onclick="loadPresetIntoSequencerModal('simple')" style="width: 100%; padding: 8px; background: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 500;">
                ‚¨áÔ∏è Charger les valeurs
              </button>
            </div>

            <div id="playlistLoaderOscillation" style="background: #FFF3E0; padding: 12px; margin: 15px 0; border-radius: 6px; border: 2px solid #FF9800; display: none;">
              <label style="font-weight: 500; color: #F57C00; display: block; margin-bottom: 8px;">üìã Charger un preset Oscillation:</label>
              <div style="display: flex; gap: 8px; margin-bottom: 8px;">
                <select id="editOscillationPresetSelect" onchange="previewSequencerPreset('oscillation', this.value)" style="flex: 1; padding: 8px; border: 1px solid #FF9800; border-radius: 4px;">
                  <option value="">-- S√©lectionner un preset --</option>
                </select>
                <button type="button" onclick="previewSequencerPreset('oscillation', document.getElementById('editOscillationPresetSelect').value)" style="padding: 8px 12px; background: #FFB74D; color: white; border: none; border-radius: 4px; cursor: pointer;" title="Voir les d√©tails">
                  üëÅÔ∏è
                </button>
              </div>
              <button type="button" onclick="loadPresetIntoSequencerModal('oscillation')" style="width: 100%; padding: 8px; background: #FF9800; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 500;">
                ‚¨áÔ∏è Charger les valeurs
              </button>
            </div>

            <div id="playlistLoaderChaos" style="background: #FCE4EC; padding: 12px; margin: 15px 0; border-radius: 6px; border: 2px solid #E91E63; display: none;">
              <label style="font-weight: 500; color: #C2185B; display: block; margin-bottom: 8px;">üìã Charger un preset Chaos:</label>
              <div style="display: flex; gap: 8px; margin-bottom: 8px;">
                <select id="editChaosPresetSelect" onchange="previewSequencerPreset('chaos', this.value)" style="flex: 1; padding: 8px; border: 1px solid #E91E63; border-radius: 4px;">
                  <option value="">-- S√©lectionner un preset --</option>
                </select>
                <button type="button" onclick="previewSequencerPreset('chaos', document.getElementById('editChaosPresetSelect').value)" style="padding: 8px 12px; background: #F06292; color: white; border: none; border-radius: 4px; cursor: pointer;" title="Voir les d√©tails">
                  üëÅÔ∏è
                </button>
              </div>
              <button type="button" onclick="loadPresetIntoSequencerModal('chaos')" style="width: 100%; padding: 8px; background: #E91E63; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 500;">
                ‚¨áÔ∏è Charger les valeurs
              </button>
            </div>

            <!-- VA-ET-VIENT FIELDS -->
            <div id="vaetFields">
              <!-- Position & Distance -->
              <div class="grid-2col-12">
                <div>
                  <label class="label-inline">Position d√©part:</label>
                  <input type="number" name="startPositionMM" id="editStartPos" step="0.1" min="0" class="input-modal">
                </div>
                <div>
                  <label class="label-inline">Distance (mm):</label>
                  <input type="number" name="distanceMM" id="editDistance" step="0.1" min="1" class="input-modal">
                </div>
              </div>

              <!-- Speeds -->
              <div class="grid-2col-12">
                <div>
                  <label class="label-inline">Vitesse aller (/20):</label>
                  <input type="number" name="speedForward" id="editSpeedFwd" min="0" max="20" step="0.1" value="5.0" class="input-modal">
                </div>
                <div>
                  <label class="label-inline">Vitesse retour (/20):</label>
                  <input type="number" name="speedBackward" id="editSpeedBack" min="0" max="20" step="0.1" value="5.0" class="input-modal">
                </div>
              </div>

              <!-- Deceleration Section -->
              <fieldset style="border: 1px solid #667eea; border-radius: 6px; padding: 10px; margin-bottom: 10px;">
                <legend style="color: #667eea; font-weight: 500; padding: 0 8px; font-size: 12px;">D√©c√©l√©ration</legend>
                
                <div class="flex-gap-15 mb-8" style="font-size: 12px;">
                  <label style="display: flex; align-items: center; gap: 4px; cursor: pointer;">
                    <input type="checkbox" name="decelStartEnabled" id="editDecelStart" style="width: 16px; height: 16px;">
                    <span>Activer D√âBUT</span>
                  </label>
                  <label style="display: flex; align-items: center; gap: 4px; cursor: pointer;">
                    <input type="checkbox" name="decelEndEnabled" id="editDecelEnd" style="width: 16px; height: 16px;" checked>
                    <span>Activer FIN</span>
                  </label>
                </div>

                <div class="grid-2col-12" style="margin-bottom: 8px; gap: 10px;">
                  <div>
                    <label class="label-inline">Zone (mm):</label>
                    <input type="number" name="decelZoneMM" id="editDecelZone" min="10" max="200" step="5" value="20" class="input-modal">
                  </div>
                  <div>
                    <label class="label-inline">Effet (%): <span id="editEffectValue" style="font-weight: bold; color: #667eea;">50</span></label>
                    <input type="range" name="decelEffectPercent" id="editDecelEffect" min="0" max="100" step="5" value="50" style="width: 100%; margin-top: 3px;">
                  </div>
                </div>

                <div>
                  <label class="label-inline">Mode courbe:</label>
                  <select name="decelMode" id="editDecelMode" class="input-modal">
                    <option value="0">Lin√©aire</option>
                    <option value="1" selected>Sinuso√Ødal</option>
                    <option value="2">Triangle Invers√©</option>
                    <option value="3">Sinus Invers√©</option>
                  </select>
                </div>
              </fieldset>
            </div>
            
            <!-- END VA-ET-VIENT FIELDS -->

            <!-- OSCILLATION FIELDS -->
            <div id="oscFields" style="display: none;">
              
              <!-- Center & Amplitude -->
              <div class="grid-2col-12">
                <div>
                  <label class="label-inline">Centre (mm):</label>
                  <input type="number" name="oscCenterPositionMM" id="editOscCenter" step="0.1" min="0" value="100" class="input-modal">
                </div>
                <div>
                  <label class="label-inline">Amplitude (mm):</label>
                  <input type="number" name="oscAmplitudeMM" id="editOscAmplitude" step="0.1" min="1" value="50" class="input-modal">
                </div>
              </div>

              <!-- Waveform & Frequency -->
              <div class="grid-2col-12">
                <div>
                  <label class="label-inline">Forme d'onde:</label>
                  <select name="oscWaveform" id="editOscWaveform" class="input-modal">
                    <option value="0">„Ä∞Ô∏è Sinuso√Ødal</option>
                    <option value="1">üìê Triangle</option>
                    <option value="2">‚¨ú Carr√©</option>
                  </select>
                </div>
                <div>
                  <label class="label-inline">Fr√©quence (Hz):</label>
                  <input type="number" name="oscFrequencyHz" id="editOscFrequency" step="0.01" min="0.01" max="10" value="0.5" class="input-modal">
                </div>
              </div>

              <!-- Ramping -->
              <div class="flex-gap-12" style="flex-direction: column; font-size: 12px; margin-bottom: 12px;">
                <label style="display: flex; align-items: center; gap: 4px; cursor: pointer;">
                  <input type="checkbox" name="oscEnableRampIn" id="editOscRampIn" style="width: 16px; height: 16px;">
                  <span>Rampe entr√©e</span>
                </label>
                <label style="display: flex; align-items: center; gap: 4px; cursor: pointer;">
                  <input type="checkbox" name="oscEnableRampOut" id="editOscRampOut" style="width: 16px; height: 16px;">
                  <span>Rampe sortie</span>
                </label>
              </div>

              <!-- Ramp Durations -->
              <div class="grid-2col-12">
                <div>
                  <label class="label-inline">Dur√©e rampe IN (ms):</label>
                  <input type="number" name="oscRampInDurationMs" id="editOscRampInDur" min="100" max="10000" step="100" value="1000" class="input-modal">
                </div>
                <div>
                  <label class="label-inline">Dur√©e rampe OUT (ms):</label>
                  <input type="number" name="oscRampOutDurationMs" id="editOscRampOutDur" min="100" max="10000" step="100" value="1000" class="input-modal">
                </div>
              </div>

            </div>
            <!-- END OSCILLATION FIELDS -->

            <!-- CHAOS FIELDS -->
            <div id="chaosFields" style="display: none;">
              
              <!-- Center & Amplitude -->
              <div class="grid-2col-12">
                <div>
                  <label class="label-inline">Centre (mm):</label>
                  <input type="number" name="chaosCenterPositionMM" id="editChaosCenter" step="0.1" min="0" value="110" class="input-modal">
                </div>
                <div>
                  <label class="label-inline">Amplitude (mm):</label>
                  <input type="number" name="chaosAmplitudeMM" id="editChaosAmplitude" step="0.1" min="1" value="50" class="input-modal">
                </div>
              </div>

              <!-- Speed & Craziness -->
              <div class="grid-2col-12">
                <div>
                  <label class="label-inline">Vitesse max (/20):</label>
                  <input type="number" name="chaosMaxSpeedLevel" id="editChaosSpeed" min="1" max="20" step="0.5" value="10" class="input-modal">
                </div>
                <div>
                  <label class="label-inline">üé≤ Folie (%):</label>
                  <input type="number" name="chaosCrazinessPercent" id="editChaosCraziness" min="0" max="100" step="5" value="50" class="input-modal">
                </div>
              </div>

              <!-- Duration & Seed -->
              <div class="grid-2col-12">
                <div>
                  <label class="label-inline">‚è±Ô∏è Dur√©e (s) 5-600:</label>
                  <input type="number" name="chaosDurationSeconds" id="editChaosDuration" min="5" max="600" step="5" value="30" class="input-modal">
                </div>
                <div>
                  <label class="label-inline">üå± Seed (0=al√©a):</label>
                  <input type="number" name="chaosSeed" id="editChaosSeed" min="0" max="9999999" step="1" value="0" class="input-modal">
                </div>
              </div>

              <!-- Patterns Selection -->
              <div class="mb-10">
                <label class="label-inline">üé≠ Patterns actifs:</label>
                <div class="grid-4col-patterns">
                  <label class="checkbox-label-sm">
                    <input type="checkbox" name="chaosPattern0" checked style="width: 14px; height: 14px;">
                    <span>‚ö° ZigZag</span>
                  </label>
                  <label class="checkbox-label-sm">
                    <input type="checkbox" name="chaosPattern1" checked style="width: 14px; height: 14px;">
                    <span>üìä Sweep</span>
                  </label>
                  <label class="checkbox-label-sm">
                    <input type="checkbox" name="chaosPattern2" checked style="width: 14px; height: 14px;">
                    <span>üí• Pulse</span>
                  </label>
                  <label class="checkbox-label-sm">
                    <input type="checkbox" name="chaosPattern3" checked style="width: 14px; height: 14px;">
                    <span>üåä Drift</span>
                  </label>
                  <label class="checkbox-label-sm">
                    <input type="checkbox" name="chaosPattern4" checked style="width: 14px; height: 14px;">
                    <span>üí® Burst</span>
                  </label>
                  <label class="checkbox-label-sm">
                    <input type="checkbox" name="chaosPattern5" checked style="width: 14px; height: 14px;">
                    <span>„Ä∞Ô∏è Wave</span>
                  </label>
                  <label class="checkbox-label-sm">
                    <input type="checkbox" name="chaosPattern6" checked style="width: 14px; height: 14px;">
                    <span>‚öñÔ∏è Pendul</span>
                  </label>
                  <label class="checkbox-label-sm">
                    <input type="checkbox" name="chaosPattern7" checked style="width: 14px; height: 14px;">
                    <span>üåÄ Spiral</span>
                  </label>
                  <label class="checkbox-label-sm">
                    <input type="checkbox" name="chaosPattern8" checked style="width: 14px; height: 14px;">
                    <span>üòå Breathing</span>
                  </label>
                  <label class="checkbox-label-sm">
                    <input type="checkbox" name="chaosPattern9" checked style="width: 14px; height: 14px;">
                    <span>üî® BruteForce</span>
                  </label>
                  <label class="checkbox-label-sm">
                    <input type="checkbox" name="chaosPattern10" checked style="width: 14px; height: 14px;">
                    <span>üîì Liberator</span>
                  </label>
                </div>
              </div>

            </div>
            <!-- END CHAOS FIELDS -->

            <!-- COMMON FIELDS (Cycles & Pause) -->
            <!-- Cycles & Pause -->
            <div class="grid-2col-12 mb-12">
              <div id="cyclesFieldDiv">
                <label class="label-inline">Cycles (1-1000):</label>
                <input type="number" name="cycleCount" id="editCycles" min="1" max="1000" step="1" value="1" class="input-modal">
              </div>
              <div id="pauseFieldDiv">
                <label class="label-inline">‚è±Ô∏è Pause (s) 0-60:</label>
                <input type="number" name="pauseAfterSec" id="editPause" min="0" max="60" step="0.1" value="0" class="input-modal">
              </div>
            </div>

            <!-- Validation Error Display -->
            <div id="editValidationErrors" style="display: none; margin-bottom: 10px; padding: 10px; background: #ffebee; border-left: 4px solid #f44336; border-radius: 5px; font-size: 12px;">
              <div style="font-weight: bold; color: #d32f2f; margin-bottom: 5px;">‚ùå Erreurs de validation :</div>
              <ul id="editValidationErrorsList" style="margin: 0; padding-left: 20px; color: #c62828; font-size: 13px;">
              </ul>
            </div>

            <!-- Action Buttons -->
            <div class="flex-gap-10 flex-end">
              <button type="submit" id="btnSaveEdit" class="button btn-success" style="padding: 10px 24px; font-size: 14px;">
                üíæ Enregistrer
              </button>
              <button type="button" id="btnCancelEdit" class="button btn-secondary" style="padding: 10px 24px; font-size: 14px; background: #999;">
                ‚ùå Annuler
              </button>
            </div>

          </form>
        </div>
      </div>
    </div>
    <!-- END EDIT MODAL -->

  </div>

  <script>
    // ========================================================================
    // GLOBAL APPLICATION STATE
    // ========================================================================
    // Centralized state management to avoid namespace pollution
    const AppState = {
      // WebSocket connection
      ws: null,
      
      // Editing state
      editing: {
        input: null,           // Currently edited input field
        oscField: null,        // Specific oscillation field being edited
        lineId: null           // Sequence line being edited (moved from separate variable)
      },
      
      // Pursuit mode state
      pursuit: {
        totalDistanceMM: 0,    // Total calibrated distance
        currentPositionMM: 0,  // Current stepper position
        targetMM: 0,           // Target position from gauge
        isDragging: false,     // Is user dragging gauge cursor
        lastCommandTime: 0,    // Last command sent timestamp
        active: false          // Is pursuit mode active
      },
      
      // System state
      system: {
        currentState: 0,       // Current system state (use SystemState enum)
        canStart: false,       // Can start operations (calibration done)
        currentMode: 'simple', // Current active mode/tab
        pendingModeSwitch: null // Pending mode change during operation
      },
      
      // UI initialization flags
      flags: {
        patternsInitialized: false,  // Chaos pattern checkboxes initialized
        domCacheReady: false          // DOM cache initialized
      },
      
      // Milestone tracking
      milestone: {
        current: null,  // Current milestone object
        lastThreshold: 0  // Last threshold passed (for notifications)
      }
    };
    
    // ========================================================================
    // PLAYLIST STATE - Preset Management
    // ========================================================================
    const PlaylistState = {
      simple: [],
      oscillation: [],
      chaos: [],
      loaded: false
    };
    
    // Load playlists from backend
    function loadPlaylists(callback) {
      fetch('/api/playlists')
        .then(response => response.json())
        .then(data => {
          PlaylistState.simple = data.simple || [];
          PlaylistState.oscillation = data.oscillation || [];
          PlaylistState.chaos = data.chaos || [];
          PlaylistState.loaded = true;
          
          // Update button counters
          updatePlaylistButtonCounters();
          
          console.log('üìã Playlists loaded:', 
            'Simple=' + PlaylistState.simple.length,
            'Oscillation=' + PlaylistState.oscillation.length,
            'Chaos=' + PlaylistState.chaos.length);
          
          // Execute callback if provided
          if (callback && typeof callback === 'function') {
            callback();
          }
        })
        .catch(error => {
          console.error('‚ùå Error loading playlists:', error);
          PlaylistState.loaded = false;
        });
    }
    
    // Update playlist button counters
    function updatePlaylistButtonCounters() {
      const btnSimple = document.getElementById('btnManagePlaylistSimple');
      const btnOsc = document.getElementById('btnManagePlaylistOscillation');
      const btnChaos = document.getElementById('btnManagePlaylistChaos');
      
      if (btnSimple) {
        btnSimple.innerHTML = 'üìã Playlist (' + PlaylistState.simple.length + '/20)';
      }
      if (btnOsc) {
        btnOsc.innerHTML = 'üìã Playlist (' + PlaylistState.oscillation.length + '/20)';
      }
      if (btnChaos) {
        btnChaos.innerHTML = 'üìã Playlist (' + PlaylistState.chaos.length + '/20)';
      }
    }
    
    // ========================================================================
    // MILESTONES - Distance Achievement Tracking
    // ========================================================================
    // Sorted by threshold (meters) ascending for efficient lookup
    const MILESTONES = [
  { threshold: 0, emoji: "üêú", name: "", location: "Global" },
  { threshold: 0.65, emoji: "üêï", name: "Chien (berger allemand)", location: "Global" },
  { threshold: 1.8, emoji: "üßç‚Äç‚ôÇÔ∏è", name: "Humain adulte moyen", location: "Global" },
  { threshold: 3.3, emoji: "üêò", name: "√âl√©phant d‚ÄôAfrique", location: "Afrique subsaharienne" },
  { threshold: 5.5, emoji: "ü¶í", name: "Girafe", location: "Afrique" },
  { threshold: 6.5, emoji: "üêç", name: "Serpent (python r√©ticul√©)", location: "Asie du Sud-Est" },
  { threshold: 8, emoji: "üè†", name: "Maison standard", location: "-" },
  { threshold: 10, emoji: "üè°", name: "Maison avec jardin", location: "-" },
  { threshold: 18, emoji: "üóø", name: "Mont Rushmore", location: "Dakota du Sud, USA" },
  { threshold: 24, emoji: "üè∞", name: "Ch√¢teau de Versailles", location: "Versailles, France" },
  { threshold: 26, emoji: "‚õ≤", name: "Fontaine de Trevi", location: "Rome, Italie" },
  { threshold: 30, emoji: "üêã", name: "Baleine bleue", location: "Oc√©ans du globe" },
  { threshold: 58, emoji: "üèØ", name: "Ch√¢teau d'Osaka", location: "Osaka, Japon" },
  { threshold: 64, emoji: "üïå", name: "Mosqu√©e Bleue", location: "Istanbul, Turquie" },
  { threshold: 65, emoji: "üõï", name: "Angkor Wat", location: "Cambodge" },
  { threshold: 68, emoji: "üèüÔ∏è", name: "Stade olympique de P√©kin", location: "P√©kin, Chine" },
  { threshold: 73, emoji: "‚úàÔ∏è", name: "Avion long-courrier (Airbus A380)", location: "Global" },
  { threshold: 88, emoji: "üèõÔ∏è", name: "Capitole des √âtats-Unis", location: "Washington D.C., USA" },
  { threshold: 93, emoji: "üóΩ", name: "Statue de la Libert√©", location: "New York, USA" },
  { threshold: 157, emoji: "üïç", name: "Cath√©drale de Cologne", location: "Cologne, Allemagne" },
  { threshold: 172, emoji: "‚õ™", name: "Sagrada Fam√≠lia", location: "Barcelone, Espagne" },
  { threshold: 300, emoji: "üóº", name: "Tour Eiffel", location: "Paris, France" },
  { threshold: 321, emoji: "üè®", name: "Burj Al Arab", location: "Duba√Ø, EAU" },
  { threshold: 360, emoji: "üö¢", name: "Navire (porte-conteneurs / paquebot)", location: "Global" },
  { threshold: 367, emoji: "üè¶", name: "Banque de Chine", location: "Hong Kong" },
  { threshold: 381, emoji: "üè¢", name: "Empire State Building", location: "New York, USA" },
  { threshold: 553, emoji: "üèóÔ∏è", name: "CN Tower", location: "Toronto, Canada" },
  { threshold: 634, emoji: "üóº", name: "Tokyo Skytree", location: "Tokyo, Japon" },
  { threshold: 828, emoji: "üèôÔ∏è", name: "Burj Khalifa", location: "Duba√Ø, EAU" },
  { threshold: 1200, emoji: "üóºüóºüóºüóº", name: "4x Tour Eiffel", location: "Paris, France" },
  { threshold: 3911, emoji: "üåâ", name: "Pont Akashi Kaiky≈ç", location: "Japon" },
  { threshold: 8848, emoji: "üèîÔ∏è", name: "Mont Everest", location: "N√©pal / Chine" },
  { threshold: 9966, emoji: "üåã", name: "Mauna Kea (base-sommet)", location: "Hawa√Ø, USA" },
  { threshold: 10000, emoji: "üåÜ", name: "M√©tropole / Skyline", location: "Variable" },
  { threshold: 100000, emoji: "üöÄ", name: "Ligne de K√°rm√°n (espace)", location: "Espace" },
  { threshold: 200000, emoji: "üõ∞Ô∏è", name: "Satellite orbital (LEO)", location: "Orbite terrestre" },
  { threshold: 164800, emoji: "üåâ", name: "Pont Danyang‚ÄìKunshan", location: "Chine" },
  { threshold: 425000, emoji: "üöù", name: "Ligne TGV Paris‚ÄìLyon", location: "France" },
  { threshold: 3474000, emoji: "üåï", name: "Lune (diam√®tre)", location: "Syst√®me Terre-Lune" },
  { threshold: 7821000, emoji: "üõ£Ô∏è", name: "Trans-canadienne", location: "Canada" },
  { threshold: 21196000, emoji: "üß±", name: "Grande Muraille de Chine", location: "Chine" },
  { threshold: 12742000, emoji: "üåç", name: "Terre (diam√®tre)", location: "Syst√®me solaire" },
  { threshold: 384400000, emoji: "üåå", name: "Distance Terre‚ÄìLune", location: "Espace" },
  { threshold: 1391000000, emoji: "üåû", name: "Soleil (diam√®tre)", location: "Syst√®me solaire" }
];
    
    /**
     * Get milestone info for given distance
     * @param {number} distanceMeters - Distance traveled in meters
     * @returns {object} Milestone object with emoji, name, threshold, next milestone, and progress
     */
    function getMilestoneInfo(distanceMeters) {
      let current = null;
      let next = MILESTONES[0]; // Default: first milestone
      
      // Find current and next milestones
      for (let i = 0; i < MILESTONES.length; i++) {
        if (distanceMeters >= MILESTONES[i].threshold) {
          current = MILESTONES[i];
          next = (i + 1 < MILESTONES.length) ? MILESTONES[i + 1] : null;
        } else {
          if (!current) {
            next = MILESTONES[i]; // Still working towards first milestone
          }
          break;
        }
      }
      
      // Calculate progress to next milestone
      let progressPercent = 0;
      if (next) {
        const previousThreshold = current ? current.threshold : 0;
        const range = next.threshold - previousThreshold;
        const traveled = distanceMeters - previousThreshold;
        progressPercent = Math.min(100, (traveled / range) * 100);
      } else {
        progressPercent = 100; // Beyond last milestone
      }
      
      return {
        current: current,
        next: next,
        progressPercent: progressPercent.toFixed(1)
      };
    }
    
    
    // ========================================================================
    // GLOBAL STATE - Position Tracking
    // ========================================================================
    let currentPositionMM = 0; // Current motor position in millimeters
    
    // ========================================================================
    // MAXGLOSPE GLOBAL STATE (MAX_SPEED_LEVEL) - Max speed level (don't forget to update .ino if changed))
    // ========================================================================
    let maxSpeedLevel = 35; // Max speed level in mm/s

    // Initialize speed input max attributes based on maxSpeedLevel
    function initSpeedLimits() {
      const speedInputs = [
        'speedUnified',
        'speedForward', 
        'speedBackward',
        'pursuitMaxSpeed',
        'chaosMaxSpeed',
        'editSpeedFwd',
        'editSpeedBack',
        'editChaosSpeed'
      ];
      
      speedInputs.forEach(id => {
        const input = document.getElementById(id);
        if (input) {
          input.setAttribute('max', maxSpeedLevel);
        }
      });
      
      // Update labels that show the max value
      const maxLabels = document.querySelectorAll('.unit-label');
      maxLabels.forEach(label => {
        if (label.textContent.includes('0-20')) {
          label.textContent = `(0-${maxSpeedLevel})`;
        }
        if (label.textContent.includes('/20')) {
          label.textContent = label.textContent.replace('/20', `/${maxSpeedLevel}`);
        }
      });
    }

    // ========================================================================
    // DOM CACHE - Performance Optimization
    // ========================================================================
    // Cache frequently accessed DOM elements to avoid repeated getElementById() calls
    const DOM = {};
    
    function initDOMCache() {
      // Status elements (updated ~50 times/second via WebSocket)
      DOM.state = document.getElementById('state');
      DOM.position = document.getElementById('position');
      DOM.currentStep = document.getElementById('currentStep');
      DOM.totalDist = document.getElementById('totalDist');
      DOM.totalTraveled = document.getElementById('totalTraveled');
      DOM.milestoneIcon = document.getElementById('milestoneIcon');
      DOM.progress = document.getElementById('progress');
      DOM.debugMovement = document.getElementById('debugMovement');
      
      // Input fields
      DOM.startPosition = document.getElementById('startPosition');
      DOM.distance = document.getElementById('distance');
      DOM.speedUnified = document.getElementById('speedUnified');
      DOM.speedForward = document.getElementById('speedForward');
      DOM.speedBackward = document.getElementById('speedBackward');
      
      // Info displays (removed in compact mode)
      DOM.speedUnifiedInfo = document.getElementById('speedUnifiedInfo'); // Removed
      DOM.speedForwardInfo = document.getElementById('speedForwardInfo'); // Removed
      DOM.speedBackwardInfo = document.getElementById('speedBackwardInfo'); // Removed
      DOM.maxStart = document.getElementById('maxStart'); // Removed in compact mode
      DOM.maxDist = document.getElementById('maxDist'); // Removed in compact mode
      
      // Buttons
      DOM.btnStart = document.getElementById('btnStart');
      DOM.btnCalibrateCommon = document.getElementById('btnCalibrateCommon');
      
      // Pursuit elements
      DOM.gaugePosition = document.getElementById('gaugePosition');
      DOM.gaugeCursor = document.getElementById('gaugeCursor');
      DOM.gaugeContainer = document.getElementById('gaugeContainer');
      DOM.gaugeLimitLine = document.getElementById('gaugeLimitLine');
      DOM.currentPositionMM = document.getElementById('currentPositionMM');
      DOM.targetPositionMM = document.getElementById('targetPositionMM');
      DOM.positionError = document.getElementById('positionError');
      DOM.pursuitActiveCheckbox = document.getElementById('pursuitActiveCheckbox');
      DOM.btnActivatePursuit = document.getElementById('btnActivatePursuit');
      
      // Max distance limit elements
      DOM.btnConfigMaxDist = document.getElementById('btnConfigMaxDist');
      DOM.maxDistConfigPanel = document.getElementById('maxDistConfigPanel');
      DOM.maxDistLimitSlider = document.getElementById('maxDistLimitSlider');
      DOM.maxDistLimitValue = document.getElementById('maxDistLimitValue');
      DOM.maxDistLimitMM = document.getElementById('maxDistLimitMM');
      DOM.btnApplyMaxDistLimit = document.getElementById('btnApplyMaxDistLimit');
      DOM.btnCancelMaxDistLimit = document.getElementById('btnCancelMaxDistLimit');
      DOM.maxDistLimitWarning = document.getElementById('maxDistLimitWarning');
      
      // Oscillation elements
      DOM.oscCurrentAmplitude = document.getElementById('oscCurrentAmplitude');
      DOM.oscCompletedCycles = document.getElementById('oscCompletedCycles');
      DOM.oscRampStatus = document.getElementById('oscRampStatus');
      DOM.oscCenter = document.getElementById('oscCenter');
      DOM.oscAmplitude = document.getElementById('oscAmplitude');
      DOM.oscWaveform = document.getElementById('oscWaveform');
      DOM.oscFrequency = document.getElementById('oscFrequency');
      DOM.oscRampInDuration = document.getElementById('oscRampInDuration');
      DOM.oscRampOutDuration = document.getElementById('oscRampOutDuration');
      DOM.oscCycleCount = document.getElementById('oscCycleCount');
      DOM.oscRampInEnable = document.getElementById('oscRampInEnable');
      DOM.oscRampOutEnable = document.getElementById('oscRampOutEnable');
      DOM.oscReturnCenter = document.getElementById('oscReturnCenter');
      // DOM.oscRampInConfig = document.getElementById('oscRampInConfig'); // Removed in compact mode
      // DOM.oscRampOutConfig = document.getElementById('oscRampOutConfig'); // Removed in compact mode
      DOM.oscLimitWarning = document.getElementById('oscLimitWarning');
      DOM.oscLimitStatus = document.getElementById('oscLimitStatus');
      DOM.btnStartOscillation = document.getElementById('btnStartOscillation');
      
      // Logs panel
      DOM.logConsolePanel = document.getElementById('logConsolePanel');
      DOM.logsPanel = document.getElementById('logsPanel');
      DOM.btnShowLogs = document.getElementById('btnShowLogs');
      DOM.logFilesList = document.getElementById('logFilesList');
      
      // Sequencer
      DOM.seqMode = document.getElementById('seqMode');
      DOM.seqCurrentLine = document.getElementById('seqCurrentLine');
      DOM.seqLineCycle = document.getElementById('seqLineCycle');
      DOM.seqLoopCount = document.getElementById('seqLoopCount');
      DOM.seqPauseRemaining = document.getElementById('seqPauseRemaining');
      DOM.btnStartSequence = document.getElementById('btnStartSequence');
      DOM.btnLoopSequence = document.getElementById('btnLoopSequence');
      DOM.btnPauseSequence = document.getElementById('btnPauseSequence');
      DOM.btnStopSequence = document.getElementById('btnStopSequence');
      DOM.btnSkipLine = document.getElementById('btnSkipLine');
      
      // Pending changes
      DOM.pendingChanges = document.getElementById('pendingChanges');
      
      // Calibration overlay
      DOM.calibrationOverlay = document.getElementById('calibrationOverlay');
      
      // Chaos stats
      DOM.chaosStats = document.getElementById('chaosStats');
      DOM.btnStartChaos = document.getElementById('btnStartChaos');
      DOM.btnStopChaos = document.getElementById('btnStopChaos');
      
      // Preset buttons (querySelectorAll cache for performance)
      DOM.presetStartButtons = document.querySelectorAll('[data-start]');
      DOM.presetDistanceButtons = document.querySelectorAll('[data-distance]');
      
      console.log('‚úÖ DOM cache initialized (' + Object.keys(DOM).length + ' elements)');
    }
    
    // ========================================================================
    // MODE S√©quenceur - Global Variables
    // ========================================================================
    let sequenceLines = [];
    let editingLineId = null;
    let isLoadingEditForm = false;  // Flag to prevent validation during initial load
    let currentLineIdMap = {};  // Map table index to lineId
    
    // Phase 2: Drag & Drop state
    let draggedLineId = null;
    let draggedLineIndex = null;
    let lastDragEnterTime = 0; // Throttle dragenter to avoid flicker
    
    // Phase 2: Multi-select state
    let selectedLineIds = new Set();
    let lastSelectedIndex = null;
    
    // ========================================================================
    // MODE S√©quenceur - Sequence Table Management
    // ========================================================================
    
    // Validate sequencer line against effectiveMaxDistanceMM
    function validateSequencerLine(line, movementType) {
      const effectiveMax = AppState.pursuit.effectiveMaxDistMM || AppState.pursuit.totalDistanceMM || 0;
      const errors = [];
      
      if (movementType === 0) {
        // VA-ET-VIENT validation
        const endPosition = line.startPositionMM + line.distanceMM;
        
        // Position d√©part
        if (line.startPositionMM < 0) {
          errors.push('‚ö†Ô∏è Position de d√©part ne peut pas √™tre n√©gative');
        }
        if (line.startPositionMM > effectiveMax) {
          errors.push(`‚ö†Ô∏è Position de d√©part (${line.startPositionMM.toFixed(1)}mm) d√©passe la course disponible (${effectiveMax.toFixed(1)}mm)`);
        }
        
        // Distance
        if (line.distanceMM <= 0) {
          errors.push('‚ö†Ô∏è Distance doit √™tre positive');
        }
        if (endPosition > effectiveMax) {
          errors.push(`‚ö†Ô∏è Position finale (${endPosition.toFixed(1)}mm) d√©passe la course disponible (${effectiveMax.toFixed(1)}mm)`);
        }
        
        // Vitesses
        if (line.speedForward < 0 || line.speedForward > 20) {
          errors.push('‚ö†Ô∏è Vitesse aller doit √™tre entre 0 et 20');
        }
        if (line.speedBackward < 0 || line.speedBackward > 20) {
          errors.push('‚ö†Ô∏è Vitesse retour doit √™tre entre 0 et 20');
        }
        
        // Zone d√©c√©l√©ration
        if (line.decelZoneMM < 10 || line.decelZoneMM > 200) {
          errors.push('‚ö†Ô∏è Zone de d√©c√©l√©ration doit √™tre entre 10 et 200 mm');
        }
        
      } else if (movementType === 1) {
        // OSCILLATION validation
        const minPos = line.oscCenterPositionMM - line.oscAmplitudeMM;
        const maxPos = line.oscCenterPositionMM + line.oscAmplitudeMM;
        
        // Centre & Amplitude
        if (minPos < 0) {
          errors.push(`‚ö†Ô∏è Position min (${minPos.toFixed(1)}mm) est n√©gative`);
        }
        if (maxPos > effectiveMax) {
          errors.push(`‚ö†Ô∏è Position max (${maxPos.toFixed(1)}mm) d√©passe la course disponible (${effectiveMax.toFixed(1)}mm)`);
        }
        if (line.oscAmplitudeMM <= 0) {
          errors.push('‚ö†Ô∏è Amplitude doit √™tre positive');
        }
        
        // Fr√©quence
        if (line.oscFrequencyHz < 0.01 || line.oscFrequencyHz > 10) {
          errors.push('‚ö†Ô∏è Fr√©quence doit √™tre entre 0.01 et 10 Hz');
        }
        
        // Dur√©e rampes
        if (line.oscRampInDurationMs < 100 || line.oscRampInDurationMs > 10000) {
          errors.push('‚ö†Ô∏è Dur√©e rampe IN doit √™tre entre 100 et 10000 ms');
        }
        if (line.oscRampOutDurationMs < 100 || line.oscRampOutDurationMs > 10000) {
          errors.push('‚ö†Ô∏è Dur√©e rampe OUT doit √™tre entre 100 et 10000 ms');
        }
        
      } else if (movementType === 2) {
        // CHAOS validation
        const minPos = line.chaosCenterPositionMM - line.chaosAmplitudeMM;
        const maxPos = line.chaosCenterPositionMM + line.chaosAmplitudeMM;
        
        // Centre & Amplitude
        if (minPos < 0) {
          errors.push(`‚ö†Ô∏è Position min (${minPos.toFixed(1)}mm) est n√©gative`);
        }
        if (maxPos > effectiveMax) {
          errors.push(`‚ö†Ô∏è Position max (${maxPos.toFixed(1)}mm) d√©passe la course disponible (${effectiveMax.toFixed(1)}mm)`);
        }
        if (line.chaosAmplitudeMM <= 0) {
          errors.push('‚ö†Ô∏è Amplitude doit √™tre positive');
        }
        
        // Vitesse max
        if (line.chaosMaxSpeedLevel < 1 || line.chaosMaxSpeedLevel > 20) {
          errors.push('‚ö†Ô∏è Vitesse max doit √™tre entre 1 et 20');
        }
        
        // Degr√© de folie
        if (line.chaosCrazinessPercent < 0 || line.chaosCrazinessPercent > 100) {
          errors.push('‚ö†Ô∏è Degr√© de folie doit √™tre entre 0 et 100%');
        }
        
        // Dur√©e
        if (line.chaosDurationSeconds < 5 || line.chaosDurationSeconds > 600) {
          errors.push('‚ö†Ô∏è Dur√©e doit √™tre entre 5 et 600 secondes');
        }
        
        // Seed
        if (line.chaosSeed < 0 || line.chaosSeed > 9999999) {
          errors.push('‚ö†Ô∏è Seed doit √™tre entre 0 et 9999999');
        }
      } else if (movementType === 4) {
        // CALIBRATION - no validation needed (no parameters)
      }
      
      // Validation commune (Cycles & Pause)
      if (movementType !== 2 && movementType !== 4) {  // CHAOS uses duration, CALIBRATION force 1 cycle
        if (line.cycleCount < 1 || line.cycleCount > 1000) {
          errors.push('‚ö†Ô∏è Nombre de cycles doit √™tre entre 1 et 1000');
        }
      }
      
      if (line.pauseAfterMs < 0 || line.pauseAfterMs > 60000) {
        errors.push('‚ö†Ô∏è Pause doit √™tre entre 0 et 60 secondes');
      }
      
      return errors;
    }
    
    function addSequenceLine() {
      const effectiveMax = AppState.pursuit.effectiveMaxDistMM || AppState.pursuit.totalDistanceMM || 0;
      const center = effectiveMax / 2;
      
      const newLine = {
        enabled: true,
        movementType: 0,  // Default to VA-ET-VIENT
        
        // VA-ET-VIENT fields - use safe defaults
        startPositionMM: 0,
        distanceMM: Math.min(100, effectiveMax),  // Cap at effective max
        speedForward: 5.0,
        speedBackward: 5.0,
        decelStartEnabled: false,
        decelEndEnabled: true,
        decelZoneMM: 20,
        decelEffectPercent: 50,
        decelMode: 1,
        
        // OSCILLATION fields - center on effective max
        oscCenterPositionMM: center,
        oscAmplitudeMM: Math.min(50.0, center),  // Cap at center
        oscWaveform: 0,  // SINE
        oscFrequencyHz: 0.5,
        oscEnableRampIn: false,
        oscEnableRampOut: false,
        oscRampInDurationMs: 1000.0,
        oscRampOutDurationMs: 1000.0,
        
        // CHAOS fields - center on effective max
        chaosCenterPositionMM: center,
        chaosAmplitudeMM: Math.min(50.0, center),  // Cap at center
        chaosMaxSpeedLevel: 10.0,
        chaosCrazinessPercent: 50.0,
        chaosDurationSeconds: 30,
        chaosSeed: 0,
        chaosPatternsEnabled: [true, true, true, true, true, true, true, true, true, true, true],
        
        // COMMON fields
        cycleCount: 1,
        pauseAfterMs: 0
      };
      
      // Validate before sending
      const errors = validateSequencerLine(newLine, newLine.movementType);
      if (errors.length > 0) {
        alert('‚ùå Impossible d\'ajouter la ligne :\n\n' + errors.join('\n'));
        return;
      }
      
      sendCommand('addSequenceLine', newLine);
    }
    
    function deleteSequenceLine(lineId) {
      if (confirm('Supprimer cette ligne?')) {
        sendCommand('deleteSequenceLine', { lineId: lineId });
      }
    }
    
    function editSequenceLine(lineId) {
      console.log('üîç editSequenceLine called with lineId:', lineId);
      console.log('üìã Available lines:', sequenceLines.map(l => ({id: l.lineId, start: l.startPositionMM})));
      
      const line = sequenceLines.find(l => l.lineId === lineId);
      if (!line) {
        console.error('‚ùå Line not found! lineId:', lineId);
        return;
      }
      
      console.log('‚úÖ Found line:', line);
      editingLineId = lineId;
      isLoadingEditForm = true;  // Disable validation during load
      
      // Clear any previous validation errors before loading
      clearErrorFields();
      const errorContainer = document.getElementById('editValidationErrors');
      if (errorContainer) errorContainer.style.display = 'none';
      
      // Populate form
      document.getElementById('editLineNumber').textContent = sequenceLines.indexOf(line) + 1;
      
      // Movement type (default to VAET if not set)
      const movementType = line.movementType !== undefined ? line.movementType : 0;
      if (movementType === 0) {
        document.getElementById('editTypeVaet').checked = true;
      } else if (movementType === 1) {
        document.getElementById('editTypeOsc').checked = true;
      } else if (movementType === 2) {
        document.getElementById('editTypeChaos').checked = true;
      } else if (movementType === 4) {
        document.getElementById('editTypeCalibration').checked = true;
      }
      updateMovementTypeFields();  // Show/hide appropriate fields
      
      // VA-ET-VIENT fields
      document.getElementById('editStartPos').value = line.startPositionMM || 0;
      document.getElementById('editDistance').value = line.distanceMM || 100;
      document.getElementById('editSpeedFwd').value = line.speedForward || 5.0;
      document.getElementById('editSpeedBack').value = line.speedBackward || 5.0;
      document.getElementById('editDecelStart').checked = line.decelStartEnabled || false;
      document.getElementById('editDecelEnd').checked = line.decelEndEnabled !== undefined ? line.decelEndEnabled : true;
      document.getElementById('editDecelZone').value = line.decelZoneMM || 20;
      document.getElementById('editDecelEffect').value = line.decelEffectPercent || 50;
      document.getElementById('editEffectValue').textContent = line.decelEffectPercent || 50;
      document.getElementById('editDecelMode').value = line.decelMode !== undefined ? line.decelMode : 1;
      
      // OSCILLATION fields
      document.getElementById('editOscCenter').value = line.oscCenterPositionMM || 100;
      document.getElementById('editOscAmplitude').value = line.oscAmplitudeMM || 50;
      document.getElementById('editOscWaveform').value = line.oscWaveform !== undefined ? line.oscWaveform : 0;
      document.getElementById('editOscFrequency').value = line.oscFrequencyHz || 0.5;
      document.getElementById('editOscRampIn').checked = line.oscEnableRampIn || false;
      document.getElementById('editOscRampOut').checked = line.oscEnableRampOut || false;
      document.getElementById('editOscRampInDur').value = line.oscRampInDurationMs || 1000;
      document.getElementById('editOscRampOutDur').value = line.oscRampOutDurationMs || 1000;
      
      // CHAOS fields
      document.getElementById('editChaosCenter').value = line.chaosCenterPositionMM || 110;
      document.getElementById('editChaosAmplitude').value = line.chaosAmplitudeMM || 50;
      document.getElementById('editChaosSpeed').value = line.chaosMaxSpeedLevel || 10;
      document.getElementById('editChaosCraziness').value = line.chaosCrazinessPercent || 50;
      document.getElementById('editChaosDuration').value = line.chaosDurationSeconds || 30;
      document.getElementById('editChaosSeed').value = line.chaosSeed || 0;
      
      // Load chaos patterns (array of 8 booleans)
      if (line.chaosPatternsEnabled && line.chaosPatternsEnabled.length === 11) {
        for (let i = 0; i < 11; i++) {
          const checkbox = document.querySelector(`input[name="chaosPattern${i}"]`);
          if (checkbox) checkbox.checked = line.chaosPatternsEnabled[i];
        }
      }
      
      // COMMON fields
      document.getElementById('editCycles').value = line.cycleCount || 1;
      document.getElementById('editPause').value = ((line.pauseAfterMs || 0) / 1000).toFixed(1);  // Convert ms to seconds
      
      // Populate playlist dropdowns if playlists are loaded
      if (PlaylistState.loaded) {
        populateSequencerDropdown('simple');
        populateSequencerDropdown('oscillation');
        populateSequencerDropdown('chaos');
      }
      
      // Show modal
      document.getElementById('editLineModal').style.display = 'block';
      
      // Re-enable validation after form is fully loaded
      isLoadingEditForm = false;
    }
    
    function saveLineEdit(event) {
      event.preventDefault();
      
      const form = document.getElementById('editLineForm');
      const movementType = parseInt(form.movementType.value);
      
      const updatedLine = {
        lineId: editingLineId,
        enabled: true,  // Keep enabled when editing
        movementType: movementType,
        
        // VA-ET-VIENT fields
        startPositionMM: parseFloat(form.startPositionMM.value),
        distanceMM: parseFloat(form.distanceMM.value),
        speedForward: parseFloat(form.speedForward.value),
        speedBackward: parseFloat(form.speedBackward.value),
        decelStartEnabled: form.decelStartEnabled.checked,
        decelEndEnabled: form.decelEndEnabled.checked,
        decelZoneMM: parseFloat(form.decelZoneMM.value),
        decelEffectPercent: parseFloat(form.decelEffectPercent.value),
        decelMode: parseInt(form.decelMode.value),
        
        // OSCILLATION fields
        oscCenterPositionMM: parseFloat(form.oscCenterPositionMM.value),
        oscAmplitudeMM: parseFloat(form.oscAmplitudeMM.value),
        oscWaveform: parseInt(form.oscWaveform.value),
        oscFrequencyHz: parseFloat(form.oscFrequencyHz.value),
        oscEnableRampIn: form.oscEnableRampIn.checked,
        oscEnableRampOut: form.oscEnableRampOut.checked,
        oscRampInDurationMs: parseFloat(form.oscRampInDurationMs.value),
        oscRampOutDurationMs: parseFloat(form.oscRampOutDurationMs.value),
        
        // CHAOS fields
        chaosCenterPositionMM: parseFloat(form.chaosCenterPositionMM.value),
        chaosAmplitudeMM: parseFloat(form.chaosAmplitudeMM.value),
        chaosMaxSpeedLevel: parseFloat(form.chaosMaxSpeedLevel.value),
        chaosCrazinessPercent: parseFloat(form.chaosCrazinessPercent.value),
        chaosDurationSeconds: parseInt(form.chaosDurationSeconds.value),
        chaosSeed: parseInt(form.chaosSeed.value),
        chaosPatternsEnabled: [
          form.chaosPattern0.checked,
          form.chaosPattern1.checked,
          form.chaosPattern2.checked,
          form.chaosPattern3.checked,
          form.chaosPattern4.checked,
          form.chaosPattern5.checked,
          form.chaosPattern6.checked,
          form.chaosPattern7.checked,
          form.chaosPattern8.checked,
          form.chaosPattern9.checked,
          form.chaosPattern10.checked
        ],
        
        // COMMON fields
        cycleCount: parseInt(form.cycleCount.value),
        pauseAfterMs: Math.round(parseFloat(form.pauseAfterSec.value) * 1000)  // Convert seconds to ms
      };
      
      // Validate before sending (should already be validated by real-time validation)
      const errors = validateSequencerLine(updatedLine, movementType);
      if (errors.length > 0) {
        // This shouldn't happen if validation is working, but just in case
        console.error('Validation errors on save:', errors);
        validateEditForm();  // Update UI
        return; // Don't close modal, let user fix
      }
      
      sendCommand('updateSequenceLine', updatedLine);
      closeEditModal();
    }
    
    // Validate edit form in real-time
    function validateEditForm() {
      // Skip validation during initial form load
      if (isLoadingEditForm) return;
      
      const form = document.getElementById('editLineForm');
      const movementType = parseInt(form.movementType.value);
      
      // Check for empty fields (indicates invalid character like "√©" was typed)
      const emptyFieldErrors = [];
      
      // VA-ET-VIENT fields
      if (movementType === 0) {
        if (form.startPositionMM.value.trim() === '') emptyFieldErrors.push('‚ö†Ô∏è Position de d√©part est incorrect');
        if (form.distanceMM.value.trim() === '') emptyFieldErrors.push('‚ö†Ô∏è Distance est incorrect');
        if (form.speedForward.value.trim() === '') emptyFieldErrors.push('‚ö†Ô∏è Vitesse aller est incorrect');
        if (form.speedBackward.value.trim() === '') emptyFieldErrors.push('‚ö†Ô∏è Vitesse retour est incorrect');
        if (form.decelZoneMM.value.trim() === '') emptyFieldErrors.push('‚ö†Ô∏è Zone d√©c√©l√©ration est incorrect');
      }
      
      // OSCILLATION fields
      if (movementType === 1) {
        if (form.oscCenterPositionMM.value.trim() === '') emptyFieldErrors.push('‚ö†Ô∏è Centre oscillation est incorrect');
        if (form.oscAmplitudeMM.value.trim() === '') emptyFieldErrors.push('‚ö†Ô∏è Amplitude oscillation est incorrect');
        if (form.oscFrequencyHz.value.trim() === '') emptyFieldErrors.push('‚ö†Ô∏è Fr√©quence est incorrect');
        if (form.oscRampInDurationMs.value.trim() === '') emptyFieldErrors.push('‚ö†Ô∏è Dur√©e rampe IN est incorrect');
        if (form.oscRampOutDurationMs.value.trim() === '') emptyFieldErrors.push('‚ö†Ô∏è Dur√©e rampe OUT est incorrect');
      }
      
      // CHAOS fields
      if (movementType === 2) {
        if (form.chaosCenterPositionMM.value.trim() === '') emptyFieldErrors.push('‚ö†Ô∏è Centre chaos est incorrect');
        if (form.chaosAmplitudeMM.value.trim() === '') emptyFieldErrors.push('‚ö†Ô∏è Amplitude chaos est incorrect');
        if (form.chaosMaxSpeedLevel.value.trim() === '') emptyFieldErrors.push('‚ö†Ô∏è Vitesse max chaos est incorrect');
        if (form.chaosCrazinessPercent.value.trim() === '') emptyFieldErrors.push('‚ö†Ô∏è Degr√© de folie est incorrect');
        if (form.chaosDurationSeconds.value.trim() === '') emptyFieldErrors.push('‚ö†Ô∏è Dur√©e chaos est incorrect');
        if (form.chaosSeed.value.trim() === '') emptyFieldErrors.push('‚ö†Ô∏è Seed est incorrect');
      }
      
      // COMMON fields (for all types except CALIBRATION)
      if (movementType !== 4) {
        if (movementType !== 2 && form.cycleCount.value.trim() === '') {
          emptyFieldErrors.push('‚ö†Ô∏è Nombre de cycles est incorrect');
        }
        if (form.pauseAfterSec.value.trim() === '') {
          emptyFieldErrors.push('‚ö†Ô∏è Pause est incorrect');
        }
      }
      
      // Build line object from current form values (ALL fields for complete validation)
      const line = {
        movementType: movementType,
        
        // VA-ET-VIENT
        startPositionMM: parseFloat(form.startPositionMM.value) || 0,
        distanceMM: parseFloat(form.distanceMM.value) || 0,
        speedForward: parseFloat(form.speedForward.value) || 0,
        speedBackward: parseFloat(form.speedBackward.value) || 0,
        decelZoneMM: parseFloat(form.decelZoneMM.value) || 0,
        
        // OSCILLATION
        oscCenterPositionMM: parseFloat(form.oscCenterPositionMM.value) || 0,
        oscAmplitudeMM: parseFloat(form.oscAmplitudeMM.value) || 0,
        oscFrequencyHz: parseFloat(form.oscFrequencyHz.value) || 0,
        oscRampInDurationMs: parseFloat(form.oscRampInDurationMs.value) || 0,
        oscRampOutDurationMs: parseFloat(form.oscRampOutDurationMs.value) || 0,
        
        // CHAOS
        chaosCenterPositionMM: parseFloat(form.chaosCenterPositionMM.value) || 0,
        chaosAmplitudeMM: parseFloat(form.chaosAmplitudeMM.value) || 0,
        chaosMaxSpeedLevel: parseFloat(form.chaosMaxSpeedLevel.value) || 0,
        chaosCrazinessPercent: parseFloat(form.chaosCrazinessPercent.value) || 0,
        chaosDurationSeconds: parseInt(form.chaosDurationSeconds.value) || 0,
        chaosSeed: parseInt(form.chaosSeed.value) || 0,
        
        // COMMON
        cycleCount: parseInt(form.cycleCount.value) || 0,
        pauseAfterMs: Math.round(parseFloat(form.pauseAfterSec.value) * 1000) || 0
      };
      
      // Validate (combine empty field errors with validation errors)
      const validationErrors = validateSequencerLine(line, movementType);
      const errors = emptyFieldErrors.concat(validationErrors);
      
      // Update UI
      const errorContainer = document.getElementById('editValidationErrors');
      const errorList = document.getElementById('editValidationErrorsList');
      const saveButton = document.getElementById('btnSaveEdit');
      
      if (errors.length > 0) {
        // Show errors
        errorContainer.style.display = 'block';
        errorList.innerHTML = errors.map(err => '<li>' + err + '</li>').join('');
        
        // Disable save button
        saveButton.disabled = true;
        saveButton.style.opacity = '0.5';
        saveButton.style.cursor = 'not-allowed';
        
        // Highlight error fields (including empty ones)
        highlightErrorFields(movementType, line, emptyFieldErrors);
      } else {
        // Hide errors
        errorContainer.style.display = 'none';
        errorList.innerHTML = '';
        
        // Enable save button
        saveButton.disabled = false;
        saveButton.style.opacity = '1';
        saveButton.style.cursor = 'pointer';
        
        // Clear all highlights
        clearErrorFields();
      }
    }
    
    // Highlight fields that have validation errors
    function highlightErrorFields(movementType, line, emptyFieldErrors) {
      clearErrorFields();
      
      const form = document.getElementById('editLineForm');
      const effectiveMax = AppState.pursuit.effectiveMaxDistMM || AppState.pursuit.totalDistanceMM || 0;
      
      // Check for empty fields and highlight them
      if (emptyFieldErrors && emptyFieldErrors.length > 0) {
        emptyFieldErrors.forEach(error => {
          if (error.includes('Position de d√©part')) {
            document.getElementById('editStartPos').style.border = '2px solid #f44336';
          }
          if (error.includes('Distance')) {
            document.getElementById('editDistance').style.border = '2px solid #f44336';
          }
          if (error.includes('Vitesse aller')) {
            document.getElementById('editSpeedFwd').style.border = '2px solid #f44336';
          }
          if (error.includes('Vitesse retour')) {
            document.getElementById('editSpeedBack').style.border = '2px solid #f44336';
          }
          if (error.includes('Zone d√©c√©l√©ration')) {
            document.getElementById('editDecelZone').style.border = '2px solid #f44336';
          }
          if (error.includes('Centre oscillation')) {
            document.getElementById('editOscCenter').style.border = '2px solid #f44336';
          }
          if (error.includes('Amplitude oscillation')) {
            document.getElementById('editOscAmplitude').style.border = '2px solid #f44336';
          }
          if (error.includes('Fr√©quence')) {
            document.getElementById('editOscFrequency').style.border = '2px solid #f44336';
          }
          if (error.includes('Dur√©e rampe IN')) {
            document.getElementById('editOscRampInDur').style.border = '2px solid #f44336';
          }
          if (error.includes('Dur√©e rampe OUT')) {
            document.getElementById('editOscRampOutDur').style.border = '2px solid #f44336';
          }
          if (error.includes('Centre chaos')) {
            document.getElementById('editChaosCenter').style.border = '2px solid #f44336';
          }
          if (error.includes('Amplitude chaos')) {
            document.getElementById('editChaosAmplitude').style.border = '2px solid #f44336';
          }
          if (error.includes('Vitesse max chaos')) {
            document.getElementById('editChaosSpeed').style.border = '2px solid #f44336';
          }
          if (error.includes('Degr√© de folie')) {
            document.getElementById('editChaosCraziness').style.border = '2px solid #f44336';
          }
          if (error.includes('Dur√©e chaos')) {
            document.getElementById('editChaosDuration').style.border = '2px solid #f44336';
          }
          if (error.includes('Seed')) {
            document.getElementById('editChaosSeed').style.border = '2px solid #f44336';
          }
          if (error.includes('Nombre de cycles')) {
            document.getElementById('editCycles').style.border = '2px solid #f44336';
          }
          if (error.includes('Pause')) {
            document.getElementById('editPause').style.border = '2px solid #f44336';
          }
        });
      }
      
      if (movementType === 0) {
        // VA-ET-VIENT
        const endPosition = line.startPositionMM + line.distanceMM;
        
        // Position d√©part
        if (line.startPositionMM < 0 || line.startPositionMM > effectiveMax) {
          document.getElementById('editStartPos').style.border = '2px solid #f44336';
        }
        
        // Distance
        if (endPosition > effectiveMax || line.distanceMM <= 0) {
          document.getElementById('editDistance').style.border = '2px solid #f44336';
        }
        
        // Vitesses
        if (line.speedForward < 0 || line.speedForward > 20) {
          document.getElementById('editSpeedFwd').style.border = '2px solid #f44336';
        }
        if (line.speedBackward < 0 || line.speedBackward > 20) {
          document.getElementById('editSpeedBack').style.border = '2px solid #f44336';
        }
        
        // Zone d√©c√©l√©ration
        if (line.decelZoneMM < 10 || line.decelZoneMM > 200) {
          document.getElementById('editDecelZone').style.border = '2px solid #f44336';
        }
        
      } else if (movementType === 1) {
        // OSCILLATION
        const minPos = line.oscCenterPositionMM - line.oscAmplitudeMM;
        const maxPos = line.oscCenterPositionMM + line.oscAmplitudeMM;
        
        // Centre & Amplitude
        if (minPos < 0 || maxPos > effectiveMax) {
          document.getElementById('editOscCenter').style.border = '2px solid #f44336';
        }
        if (line.oscAmplitudeMM <= 0 || maxPos > effectiveMax) {
          document.getElementById('editOscAmplitude').style.border = '2px solid #f44336';
        }
        
        // Fr√©quence
        if (line.oscFrequencyHz < 0.01 || line.oscFrequencyHz > 10) {
          document.getElementById('editOscFrequency').style.border = '2px solid #f44336';
        }
        
        // Dur√©e rampes
        if (line.oscRampInDurationMs < 100 || line.oscRampInDurationMs > 10000) {
          document.getElementById('editOscRampInDur').style.border = '2px solid #f44336';
        }
        if (line.oscRampOutDurationMs < 100 || line.oscRampOutDurationMs > 10000) {
          document.getElementById('editOscRampOutDur').style.border = '2px solid #f44336';
        }
        
      } else if (movementType === 2) {
        // CHAOS
        const minPos = line.chaosCenterPositionMM - line.chaosAmplitudeMM;
        const maxPos = line.chaosCenterPositionMM + line.chaosAmplitudeMM;
        
        // Centre & Amplitude
        if (minPos < 0 || maxPos > effectiveMax) {
          document.getElementById('editChaosCenter').style.border = '2px solid #f44336';
        }
        if (line.chaosAmplitudeMM <= 0 || maxPos > effectiveMax) {
          document.getElementById('editChaosAmplitude').style.border = '2px solid #f44336';
        }
        
        // Vitesse max
        if (line.chaosMaxSpeedLevel < 1 || line.chaosMaxSpeedLevel > 20) {
          document.getElementById('editChaosSpeed').style.border = '2px solid #f44336';
        }
        
        // Degr√© de folie
        if (line.chaosCrazinessPercent < 0 || line.chaosCrazinessPercent > 100) {
          document.getElementById('editChaosCraziness').style.border = '2px solid #f44336';
        }
        
        // Dur√©e
        if (line.chaosDurationSeconds < 5 || line.chaosDurationSeconds > 600) {
          document.getElementById('editChaosDuration').style.border = '2px solid #f44336';
        }
        
        // Seed
        if (line.chaosSeed < 0 || line.chaosSeed > 9999999) {
          document.getElementById('editChaosSeed').style.border = '2px solid #f44336';
        }
      }
      
      // Validation commune
      if (movementType !== 2 && movementType !== 4) {  // CHAOS & CALIBRATION
        if (line.cycleCount < 1 || line.cycleCount > 1000) {
          document.getElementById('editCycles').style.border = '2px solid #f44336';
        }
      }
      
      if (line.pauseAfterMs < 0 || line.pauseAfterMs > 60000) {
        document.getElementById('editPause').style.border = '2px solid #f44336';
      }
    }
    
    // Clear all error field highlights
    function clearErrorFields() {
      const fields = [
        // VA-ET-VIENT
        'editStartPos', 'editDistance', 'editSpeedFwd', 'editSpeedBack', 'editDecelZone',
        // OSCILLATION
        'editOscCenter', 'editOscAmplitude', 'editOscFrequency',
        'editOscRampInDur', 'editOscRampOutDur',
        // CHAOS
        'editChaosCenter', 'editChaosAmplitude', 'editChaosSpeed', 'editChaosCraziness',
        'editChaosDuration', 'editChaosSeed',
        // COMMON
        'editCycles', 'editPause'
      ];
      fields.forEach(fieldId => {
        const field = document.getElementById(fieldId);
        if (field) field.style.border = '2px solid #ddd';
      });
    }
    
    // Toggle visibility of fields based on movement type
    function updateMovementTypeFields() {
      const isVaet = document.getElementById('editTypeVaet').checked;
      const isOsc = document.getElementById('editTypeOsc').checked;
      const isChaos = document.getElementById('editTypeChaos').checked;
      const isCalibration = document.getElementById('editTypeCalibration').checked;
      
      document.getElementById('vaetFields').style.display = isVaet ? 'block' : 'none';
      document.getElementById('oscFields').style.display = isOsc ? 'block' : 'none';
      document.getElementById('chaosFields').style.display = isChaos ? 'block' : 'none';
      
      // Show/hide playlist loaders based on type
      document.getElementById('playlistLoaderSimple').style.display = isVaet ? 'block' : 'none';
      document.getElementById('playlistLoaderOscillation').style.display = isOsc ? 'block' : 'none';
      document.getElementById('playlistLoaderChaos').style.display = isChaos ? 'block' : 'none';
      
      // Hide cycles field for CHAOS (uses duration) and CALIBRATION (always 1 cycle)
      document.getElementById('cyclesFieldDiv').style.display = (isChaos || isCalibration) ? 'none' : 'block';
      // Pause is available for all types
      document.getElementById('pauseFieldDiv').style.display = 'block';
      
      // Revalidate when type changes
      validateEditForm();
    }
    
    function closeEditModal() {
      document.getElementById('editLineModal').style.display = 'none';
      editingLineId = null;
      
      // Clear any validation errors when closing modal
      clearErrorFields();
      const errorContainer = document.getElementById('editValidationErrors');
      if (errorContainer) errorContainer.style.display = 'none';
      
      // Re-enable save button
      const saveButton = document.getElementById('btnSaveEdit');
      if (saveButton) {
        saveButton.disabled = false;
        saveButton.style.opacity = '1';
        saveButton.style.cursor = 'pointer';
      }
    }
    
    function closeEditLineModalOnOverlayClick(event) {
      // Only close if clicking on the overlay itself (not the content)
      if (event.target.id === 'editLineModal') {
        closeEditModal();
      }
    }
    
    // ========================================================================
    // PLAYLIST INTEGRATION IN SEQUENCER
    // ========================================================================
    
    /**
     * Populate sequencer modal dropdown with presets for a specific mode
     */
    function populateSequencerDropdown(mode) {
      const selectId = 'edit' + mode.charAt(0).toUpperCase() + mode.slice(1) + 'PresetSelect';
      const select = document.getElementById(selectId);
      if (!select) return;
      
      const presets = PlaylistState[mode] || [];
      
      // Clear existing options (except first "-- S√©lectionner --")
      select.innerHTML = '<option value="">-- S√©lectionner un preset --</option>';
      
      // Add presets (sorted by timestamp desc - most recent first)
      const sortedPresets = [...presets].sort((a, b) => b.timestamp - a.timestamp);
      sortedPresets.forEach(preset => {
        const option = document.createElement('option');
        option.value = preset.id;
        option.textContent = preset.name;
        select.appendChild(option);
      });
    }
    
    /**
     * Preview a preset from sequencer dropdown
     */
    function previewSequencerPreset(mode, presetId) {
      if (!presetId) {
        hidePlaylistTooltip();
        return;
      }
      
      const id = parseInt(presetId);
      const preset = PlaylistState[mode].find(p => p.id === id);
      
      if (!preset) {
        hidePlaylistTooltip();
        return;
      }
      
      const tooltipContent = generatePresetTooltip(mode, preset.config);
      const overlay = document.getElementById('playlistTooltipOverlay');
      
      if (overlay && tooltipContent) {
        overlay.innerHTML = `<div style="font-weight: 600; margin-bottom: 8px; font-size: 13px;">üìã ${preset.name}</div>` + tooltipContent;
        overlay.classList.add('visible');
        
        // Auto-hide after 5 seconds
        setTimeout(() => {
          overlay.classList.remove('visible');
        }, 5000);
      }
    }
    
    /**
     * Quick Add preset directly to sequencer (from playlist modal)
     */
    function quickAddToSequencer(mode, presetId) {
      const preset = PlaylistState[mode].find(p => p.id === presetId);
      if (!preset) {
        showNotification('‚ùå Preset introuvable', 'error', 2000);
        return;
      }
      
      const config = preset.config;
      const effectiveMax = AppState.pursuit.effectiveMaxDistMM || AppState.pursuit.totalDistanceMM || 200;
      const center = effectiveMax / 2;
      
      // Build sequencer line based on mode
      let newLine = {
        enabled: true,
        cycleCount: 1,
        pauseAfterMs: 0
      };
      
      if (mode === 'simple') {
        newLine.movementType = 0;  // VA-ET-VIENT
        newLine.startPositionMM = config.startPositionMM || 0;
        newLine.distanceMM = config.distanceMM || 50;
        newLine.speedForward = config.speedLevelForward || 5;
        newLine.speedBackward = config.speedLevelBackward || 5;
        newLine.decelStartEnabled = false;
        newLine.decelEndEnabled = true;
        newLine.decelZoneMM = 20;
        newLine.decelEffectPercent = 50;
        newLine.decelMode = 1;
        
        // Default oscillation fields
        newLine.oscCenterPositionMM = center;
        newLine.oscAmplitudeMM = Math.min(50, center);
        newLine.oscWaveform = 0;
        newLine.oscFrequencyHz = 0.5;
        newLine.oscEnableRampIn = false;
        newLine.oscEnableRampOut = false;
        newLine.oscRampInDurationMs = 1000;
        newLine.oscRampOutDurationMs = 1000;
        
        // Default chaos fields
        newLine.chaosCenterPositionMM = center;
        newLine.chaosAmplitudeMM = Math.min(50, center);
        newLine.chaosMaxSpeedLevel = 10;
        newLine.chaosCrazinessPercent = 50;
        newLine.chaosDurationSeconds = 30;
        newLine.chaosSeed = 0;
        newLine.chaosPatternsEnabled = [true, true, true, true, true, true, true, true, true, true, true];
        
      } else if (mode === 'oscillation') {
        newLine.movementType = 1;  // OSCILLATION
        newLine.oscCenterPositionMM = config.centerPositionMM || center;
        newLine.oscAmplitudeMM = config.amplitudeMM || 50;
        newLine.oscWaveform = config.waveform || 0;
        newLine.oscFrequencyHz = config.frequencyHz || 0.5;
        newLine.oscEnableRampIn = config.enableRampIn || false;
        newLine.oscEnableRampOut = config.enableRampOut || false;
        newLine.oscRampInDurationMs = config.rampInDurationMs || 1000;
        newLine.oscRampOutDurationMs = config.rampOutDurationMs || 1000;
        newLine.cycleCount = config.cycleCount || 1;
        
        // Default VA-ET-VIENT fields
        newLine.startPositionMM = 0;
        newLine.distanceMM = Math.min(100, effectiveMax);
        newLine.speedForward = 5;
        newLine.speedBackward = 5;
        newLine.decelStartEnabled = false;
        newLine.decelEndEnabled = true;
        newLine.decelZoneMM = 20;
        newLine.decelEffectPercent = 50;
        newLine.decelMode = 1;
        
        // Default chaos fields
        newLine.chaosCenterPositionMM = center;
        newLine.chaosAmplitudeMM = Math.min(50, center);
        newLine.chaosMaxSpeedLevel = 10;
        newLine.chaosCrazinessPercent = 50;
        newLine.chaosDurationSeconds = 30;
        newLine.chaosSeed = 0;
        newLine.chaosPatternsEnabled = [true, true, true, true, true, true, true, true, true, true, true];
        
      } else if (mode === 'chaos') {
        newLine.movementType = 2;  // CHAOS
        newLine.chaosCenterPositionMM = config.centerPositionMM || center;
        newLine.chaosAmplitudeMM = config.amplitudeMM || 50;
        newLine.chaosMaxSpeedLevel = config.maxSpeedLevel || 10;
        newLine.chaosCrazinessPercent = config.crazinessPercent || 50;
        newLine.chaosDurationSeconds = config.durationSeconds || 30;
        newLine.chaosSeed = config.seed || 0;
        newLine.chaosPatternsEnabled = config.patternsEnabled || [true, true, true, true, true, true, true, true, true, true, true];
        
        // Default VA-ET-VIENT fields
        newLine.startPositionMM = 0;
        newLine.distanceMM = Math.min(100, effectiveMax);
        newLine.speedForward = 5;
        newLine.speedBackward = 5;
        newLine.decelStartEnabled = false;
        newLine.decelEndEnabled = true;
        newLine.decelZoneMM = 20;
        newLine.decelEffectPercent = 50;
        newLine.decelMode = 1;
        
        // Default oscillation fields
        newLine.oscCenterPositionMM = center;
        newLine.oscAmplitudeMM = Math.min(50, center);
        newLine.oscWaveform = 0;
        newLine.oscFrequencyHz = 0.5;
        newLine.oscEnableRampIn = false;
        newLine.oscEnableRampOut = false;
        newLine.oscRampInDurationMs = 1000;
        newLine.oscRampOutDurationMs = 1000;
      }
      
      // Validate before sending
      const errors = validateSequencerLine(newLine, newLine.movementType);
      if (errors.length > 0) {
        showNotification('‚ùå Preset invalide pour s√©quenceur:\n' + errors.join('\n'), 'error', 5000);
        return;
      }
      
      // Send to backend
      sendCommand('addSequenceLine', newLine);
      showNotification('‚úÖ Ligne ajout√©e au s√©quenceur: ' + preset.name, 'success', 3000);
      
      console.log('‚úÖ Quick Add to sequencer:', preset.name, newLine);
    }
    
    /**
     * Load a preset from playlist into sequencer edit modal
     */
    function loadPresetIntoSequencerModal(mode) {
      const selectId = 'edit' + mode.charAt(0).toUpperCase() + mode.slice(1) + 'PresetSelect';
      const select = document.getElementById(selectId);
      const presetId = parseInt(select.value);
      
      if (!presetId) {
        showNotification('‚ö†Ô∏è Veuillez s√©lectionner un preset', 'error', 2000);
        return;
      }
      
      const preset = PlaylistState[mode].find(p => p.id === presetId);
      if (!preset) {
        showNotification('‚ùå Preset introuvable', 'error', 2000);
        return;
      }
      
      const config = preset.config;
      
      // Fill sequencer modal fields based on mode
      if (mode === 'simple') {
        document.getElementById('editStartPos').value = config.startPositionMM || 0;
        document.getElementById('editDistance').value = config.distanceMM || 50;
        document.getElementById('editSpeedFwd').value = config.speedLevelForward || 5;
        document.getElementById('editSpeedBack').value = config.speedLevelBackward || 5;
      } else if (mode === 'oscillation') {
        document.getElementById('editOscCenter').value = config.centerPositionMM || 100;
        document.getElementById('editOscAmplitude').value = config.amplitudeMM || 20;
        document.getElementById('editOscWaveform').value = config.waveform || 0;
        document.getElementById('editOscFrequency').value = config.frequencyHz || 1.0;
        document.getElementById('editOscRampIn').checked = config.enableRampIn || false;
        document.getElementById('editOscRampInDur').value = config.rampInDurationMs || 2000;
        document.getElementById('editOscRampOut').checked = config.enableRampOut || false;
        document.getElementById('editOscRampOutDur').value = config.rampOutDurationMs || 2000;
        
        // Cycles (0 = infinite not allowed in sequencer, use stored value or default to 10)
        const cycleValue = config.cycleCount === 0 ? 10 : config.cycleCount;
        document.getElementById('editCycles').value = cycleValue;
      } else if (mode === 'chaos') {
        document.getElementById('editChaosCenter').value = config.centerPositionMM || 100;
        document.getElementById('editChaosAmplitude').value = config.amplitudeMM || 40;
        document.getElementById('editChaosSpeed').value = config.maxSpeedLevel || 15;
        document.getElementById('editChaosCraziness').value = config.crazinessPercent || 50;
        document.getElementById('editChaosDuration').value = config.durationSeconds || 30;
        document.getElementById('editChaosSeed').value = 0; // Default seed
        
        // Set pattern checkboxes
        if (config.patternsEnabled && Array.isArray(config.patternsEnabled)) {
          for (let i = 0; i < config.patternsEnabled.length && i < 11; i++) {
            const checkbox = document.querySelector(`#chaosFields input[name="chaosPattern${i}"]`);
            if (checkbox) {
              checkbox.checked = config.patternsEnabled[i];
            }
          }
        }
      }
      
      // Trigger validation to update UI state
      validateEditForm();
      
      showNotification('‚úÖ Valeurs charg√©es depuis: ' + preset.name, 'success', 2000);
    }
    
    function moveSequenceLine(lineId, direction) {
      sendCommand('moveSequenceLine', { lineId: lineId, direction: direction });
    }
    
    function duplicateSequenceLine(lineId) {
      sendCommand('duplicateSequenceLine', { lineId: lineId });
    }
    
    /**
     * Test a single line by disabling others (replaceSequence doesn't exist in backend)
     */
    function testSequenceLine(lineId) {
      const line = sequenceLines.find(l => l.lineId === lineId);
      if (!line) {
        showNotification('‚ùå Ligne introuvable', 'error', 2000);
        return;
      }
      
      // Check if sequence is currently running
      if (AppState.sequencer && AppState.sequencer.isRunning) {
        showNotification('‚ö†Ô∏è Arr√™tez la s√©quence en cours avant de tester', 'error', 3000);
        return;
      }
      
      // Backup current sequence state (enabled flags + cycle counts)
      window.sequenceBackup = sequenceLines.map(l => ({ 
        lineId: l.lineId, 
        enabled: l.enabled, 
        cycleCount: l.cycleCount 
      }));
      window.testedLineId = lineId;
      window.isTestingLine = true;
      
      console.log('üß™ Testing line #' + lineId + ' - Temporarily disabling other lines');
      
      // Disable all lines except the one we want to test
      sequenceLines.forEach(l => {
        if (l.lineId === lineId) {
          // Target line: ensure enabled (keep original cycle count - test full line!)
          if (!l.enabled) {
            sendCommand('toggleSequenceLine', { lineId: l.lineId, enabled: true });
            l.enabled = true;
          }
          // Don't modify cycleCount - we want to test the line as configured
        } else {
          // Other lines: temporarily disable
          if (l.enabled) {
            sendCommand('toggleSequenceLine', { lineId: l.lineId, enabled: false });
            l.enabled = false;
          }
        }
      });
      
      // Update visual state of lines without full re-render (to preserve selection)
      sequenceLines.forEach((l, idx) => {
        const row = document.querySelector(`tr[data-line-id="${l.lineId}"]`);
        if (row) {
          row.style.background = l.enabled ? 'white' : '#f5f5f5';
          row.style.opacity = l.enabled ? '1' : '0.6';
        }
      });
      
      // Disable ALL test buttons during test
      document.querySelectorAll('[id^="btnTestLine_"]').forEach(btn => {
        btn.disabled = true;
        btn.style.opacity = '0.5';
        btn.style.cursor = 'not-allowed';
      });
      
      // Start sequence after commands are sent
      setTimeout(() => {
        // Disable Unique and Boucle buttons JUST BEFORE starting
        // Use setButtonState to ensure it overrides any other state management
        console.log('üîç About to disable buttons before startSequence, isTestingLine=', window.isTestingLine);
        if (DOM.btnStartSequence) {
          setButtonState(DOM.btnStartSequence, false);
          console.log('‚úÖ btnStartSequence disabled via setButtonState');
        }
        if (DOM.btnLoopSequence) {
          setButtonState(DOM.btnLoopSequence, false);
          console.log('‚úÖ btnLoopSequence disabled via setButtonState');
        }
        
        sendCommand('startSequence', {});
        const testedLine = sequenceLines.find(l => l.lineId === lineId);
        const cycleText = testedLine ? testedLine.cycleCount + ' cycle(s)' : '';
        showNotification('üß™ Test ligne #' + lineId + ' (' + cycleText + ')', 'info', 3000);
      }, 500);
    }
    
    /**
     * Restore original sequence after test
     */
    function restoreSequenceAfterTest() {
      if (!window.isTestingLine || !window.sequenceBackup) return;
      
      console.log('üîÑ Restoring sequence original state');
      
      // Restore enabled flags only (cycleCount was not modified)
      window.sequenceBackup.forEach(backup => {
        const line = sequenceLines.find(l => l.lineId === backup.lineId);
        if (line && line.enabled !== backup.enabled) {
          sendCommand('toggleSequenceLine', { lineId: backup.lineId, enabled: backup.enabled });
          line.enabled = backup.enabled;
        }
      });
      
      // Clear test state FIRST (before re-render)
      window.isTestingLine = false;
      
      // Refresh UI (this will NOT re-disable buttons now that isTestingLine=false)
      renderSequenceTable();
      
      // Re-enable Unique and Boucle buttons immediately using setButtonState
      // No setTimeout needed since isTestingLine is already false
      if (DOM.btnStartSequence) {
        setButtonState(DOM.btnStartSequence, true);
        console.log('‚úÖ btnStartSequence re-enabled after test');
      }
      if (DOM.btnLoopSequence) {
        setButtonState(DOM.btnLoopSequence, true);
        console.log('‚úÖ btnLoopSequence re-enabled after test');
      }
      
      // Re-enable ALL test buttons
      document.querySelectorAll('[id^="btnTestLine_"]').forEach(btn => {
        btn.disabled = false;
        btn.style.opacity = '1';
        btn.style.cursor = 'pointer';
      });
      window.sequenceBackup = null;
      window.testedLineId = null;
      
      showNotification('‚úÖ S√©quence restaur√©e', 'success', 2000);
    }
    
    function toggleSequenceLine(lineId, enabled) {
      sendCommand('toggleSequenceLine', { lineId: lineId, enabled: enabled });
    }
    
    function clearSequence() {
      if (confirm('Effacer toutes les lignes du tableau?')) {
        sendCommand('clearSequence', {});
      }
    }
    
    function exportSequence() {
      sendCommand('exportSequence', {});
    }
    
    function importSequence() {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.json';
      
      input.onchange = function(e) {
        const file = e.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = function(event) {
          try {
            const jsonData = event.target.result;
            sendCommand('importSequence', { jsonData: jsonData });
          } catch (error) {
            alert('Erreur lors de la lecture du fichier: ' + error.message);
          }
        };
        reader.readAsText(file);
      };
      
      input.click();
    }
    
    /**
     * Download a JSON template with examples and documentation
     * Helps users create their own sequence files
     */
    function downloadTemplate() {
      const template = {
        version: "2.0",
        lineCount: 5,
        lines: [
          {
            lineId: 1,
            enabled: true,
            movementType: 4,  // CALIBRATION (toujours en premier!)
            cycleCount: 1,
            pauseAfterMs: 1000,
            // Note: Les autres champs sont ignor√©s pour la calibration
            startPositionMM: 0,
            distanceMM: 100,
            speedForward: 5.0,
            speedBackward: 5.0,
            decelStartEnabled: false,
            decelEndEnabled: false,
            decelZoneMM: 50.0,
            decelEffectPercent: 50.0,
            decelMode: 0,
            oscCenterPositionMM: 100.0,
            oscAmplitudeMM: 50.0,
            oscWaveform: 0,
            oscFrequencyHz: 0.1,
            oscEnableRampIn: false,
            oscEnableRampOut: false,
            oscRampInDurationMs: 1000.0,
            oscRampOutDurationMs: 1000.0,
            chaosCenterPositionMM: 110.0,
            chaosAmplitudeMM: 50.0,
            chaosMaxSpeedLevel: 10.0,
            chaosCrazinessPercent: 50.0,
            chaosDurationSeconds: 30,
            chaosSeed: 0,
            chaosPatternsEnabled: [true, true, true, true, true, true, true, true, true, true, true]
          },
          {
            lineId: 2,
            enabled: true,
            movementType: 0,  // VA-ET-VIENT (Simple)
            cycleCount: 10,
            pauseAfterMs: 500,
            // Param√®tres VA-ET-VIENT
            startPositionMM: 0.0,
            distanceMM: 100.0,
            speedForward: 8.0,
            speedBackward: 8.0,
            decelStartEnabled: true,
            decelEndEnabled: true,
            decelZoneMM: 20.0,
            decelEffectPercent: 75.0,
            decelMode: 1,  // 0=LINEAR, 1=SINE, 2=TRIANGLE_INV, 3=SINE_INV
            // Les autres champs (osc/chaos) ne sont pas utilis√©s mais doivent √™tre pr√©sents
            oscCenterPositionMM: 100.0,
            oscAmplitudeMM: 50.0,
            oscWaveform: 0,
            oscFrequencyHz: 0.25,
            oscEnableRampIn: false,
            oscEnableRampOut: false,
            oscRampInDurationMs: 1000.0,
            oscRampOutDurationMs: 1000.0,
            chaosCenterPositionMM: 110.0,
            chaosAmplitudeMM: 50.0,
            chaosMaxSpeedLevel: 10.0,
            chaosCrazinessPercent: 50.0,
            chaosDurationSeconds: 30,
            chaosSeed: 0,
            chaosPatternsEnabled: [true, true, true, true, true, true, true, true, true, true, true]
          },
          {
            lineId: 3,
            enabled: true,
            movementType: 1,  // OSCILLATION
            cycleCount: 5,
            pauseAfterMs: 2000,
            // Param√®tres OSCILLATION (les autres champs doivent √™tre pr√©sents)
            startPositionMM: 0.0,
            distanceMM: 100.0,
            speedForward: 5.0,
            speedBackward: 5.0,
            decelStartEnabled: false,
            decelEndEnabled: false,
            decelZoneMM: 50.0,
            decelEffectPercent: 50.0,
            decelMode: 0,
            oscCenterPositionMM: 100.0,
            oscAmplitudeMM: 80.0,
            oscWaveform: 0,  // 0=SINE, 1=TRIANGLE, 2=SQUARE
            oscFrequencyHz: 0.5,
            oscEnableRampIn: true,
            oscEnableRampOut: true,
            oscRampInDurationMs: 2000.0,
            oscRampOutDurationMs: 2000.0,
            chaosCenterPositionMM: 110.0,
            chaosAmplitudeMM: 50.0,
            chaosMaxSpeedLevel: 10.0,
            chaosCrazinessPercent: 50.0,
            chaosDurationSeconds: 30,
            chaosSeed: 0,
            chaosPatternsEnabled: [true, true, true, true, true, true, true, true, true, true, true]
          },
          {
            lineId: 4,
            enabled: true,
            movementType: 2,  // CHAOS
            cycleCount: 1,
            pauseAfterMs: 1000,
            // Param√®tres CHAOS (les autres champs doivent √™tre pr√©sents)
            startPositionMM: 0.0,
            distanceMM: 100.0,
            speedForward: 5.0,
            speedBackward: 5.0,
            decelStartEnabled: false,
            decelEndEnabled: false,
            decelZoneMM: 50.0,
            decelEffectPercent: 50.0,
            decelMode: 0,
            oscCenterPositionMM: 100.0,
            oscAmplitudeMM: 50.0,
            oscWaveform: 0,
            oscFrequencyHz: 1.0,
            oscEnableRampIn: false,
            oscEnableRampOut: false,
            oscRampInDurationMs: 1000.0,
            oscRampOutDurationMs: 1000.0,
            chaosCenterPositionMM: 100.0,
            chaosAmplitudeMM: 80.0,
            chaosMaxSpeedLevel: 15.0,
            chaosCrazinessPercent: 75.0,
            chaosDurationSeconds: 60,
            chaosSeed: 12345,
            chaosPatternsEnabled: [false, false, false, false, false, true, true, true, true, false, false]  // Doux: WAVE, PENDULUM, SPIRAL, BREATHING
          },
          {
            lineId: 5,
            enabled: true,
            movementType: 0,  // VA-ET-VIENT (retour √† 0)
            cycleCount: 1,
            pauseAfterMs: 0,
            startPositionMM: 0.0,
            distanceMM: 50.0,
            speedForward: 5.0,
            speedBackward: 5.0,
            decelStartEnabled: false,
            decelEndEnabled: true,
            decelZoneMM: 10.0,
            decelEffectPercent: 50.0,
            decelMode: 1,
            oscCenterPositionMM: 100.0,
            oscAmplitudeMM: 50.0,
            oscWaveform: 0,
            oscFrequencyHz: 2.0,
            oscEnableRampIn: false,
            oscEnableRampOut: false,
            oscRampInDurationMs: 1000.0,
            oscRampOutDurationMs: 1000.0,
            chaosCenterPositionMM: 110.0,
            chaosAmplitudeMM: 50.0,
            chaosMaxSpeedLevel: 10.0,
            chaosCrazinessPercent: 50.0,
            chaosDurationSeconds: 30,
            chaosSeed: 0,
            chaosPatternsEnabled: [true, true, true, true, true, true, true, true, true, true, true]
          }
        ]
      };
      
      // Create help documentation
      const help = {
        "üîß GUIDE D'UTILISATION": {
          "Format": "JSON version 2.0",
          "Structure": "Objet avec 'version', 'lineCount' et 'lines' (array)",
          "Ordre": "‚ö†Ô∏è TOUJOURS commencer par CALIBRATION (movementType=4) !"
        },
        "üìã TYPES DE MOUVEMENT (movementType)": {
          "0": "VA-ET-VIENT (Simple) - Mouvement aller-retour classique",
          "1": "OSCILLATION - Mouvement sinuso√Ødal continu",
          "2": "CHAOS - Mouvements al√©atoires chaotiques",
          "4": "CALIBRATION - Calibration automatique (toujours en premier)"
        },
        "‚öôÔ∏è PARAM√àTRES COMMUNS": {
          "lineId": "ID unique de la ligne (entier)",
          "enabled": "Ligne active ? (true/false)",
          "cycleCount": "Nombre de cycles (1 forc√© pour CALIBRATION)",
          "pauseAfterMs": "Pause apr√®s mouvement en millisecondes (0 = aucune)"
        },
        "üéØ VA-ET-VIENT (movementType=0)": {
          "startPositionMM": "Position de d√©part (mm)",
          "distanceMM": "Distance du mouvement (mm)",
          "speedForward": "Vitesse aller (1-20)",
          "speedBackward": "Vitesse retour (1-20)",
          "decelStartEnabled": "D√©c√©l√©ration au d√©part ? (true/false)",
          "decelEndEnabled": "D√©c√©l√©ration √† la fin ? (true/false)",
          "decelZoneMM": "Taille zone d√©c√©l√©ration (mm)",
          "decelEffectPercent": "Effet d√©c√©l√©ration (0-100%)",
          "decelMode": "Type: 0=LINEAR, 1=SINE, 2=TRIANGLE_INV, 3=SINE_INV"
        },
        "üåä OSCILLATION (movementType=1)": {
          "oscCenterPositionMM": "Position centrale (mm)",
          "oscAmplitudeMM": "Amplitude ¬±amplitude (mm)",
          "oscWaveform": "Forme d'onde: 0=SINE, 1=TRIANGLE, 2=SQUARE",
          "oscFrequencyHz": "Fr√©quence (0.1-10 Hz)",
          "oscEnableRampIn": "Rampe d'entr√©e ? (true/false)",
          "oscEnableRampOut": "Rampe de sortie ? (true/false)",
          "oscRampInDurationMs": "Dur√©e rampe entr√©e (ms)",
          "oscRampOutDurationMs": "Dur√©e rampe sortie (ms)"
        },
        "üå™Ô∏è CHAOS (movementType=2)": {
          "chaosCenterPositionMM": "Position centrale (mm)",
          "chaosAmplitudeMM": "Amplitude max ¬±amplitude (mm)",
          "chaosMaxSpeedLevel": "Vitesse max (1-20)",
          "chaosCrazinessPercent": "Degr√© folie (0-100%)",
          "chaosDurationSeconds": "Dur√©e en secondes (0=infini)",
          "chaosSeed": "Graine al√©atoire (0=auto)",
          "chaosPatternsEnabled": "Array[11] bool√©ens (ZIGZAG, SWEEP, PULSE, DRIFT, BURST, WAVE, PENDULUM, SPIRAL, BREATHING, BRUTE_FORCE, LIBERATOR)"
        },
        "üìè CALIBRATION (movementType=4)": {
          "Note": "Calibration automatique compl√®te",
          "cycleCount": "Toujours forc√© √† 1",
          "Autres_params": "Ignor√©s mais doivent √™tre pr√©sents dans le JSON"
        },
        "‚ö†Ô∏è IMPORTANT": {
          "Tous_les_champs": "TOUS les champs doivent √™tre pr√©sents dans chaque ligne !",
          "Ordre_execution": "Les lignes sont ex√©cut√©es dans l'ordre du tableau",
          "Validation": "Les valeurs sont valid√©es c√¥t√© backend (limites physiques)",
          "IDs": "Les lineId doivent √™tre uniques"
        }
      };
      
      // Combine template and help
      const fullDoc = {
        TEMPLATE: template,
        DOCUMENTATION: help
      };
      
      // Create downloadable file
      const jsonStr = JSON.stringify(fullDoc, null, 2);
      const blob = new Blob([jsonStr], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'sequence_template_avec_aide.json';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      showNotification('üìÑ Template t√©l√©charg√© avec documentation compl√®te !', 'success', 3000);
    }
    
    function renderSequenceTable(data) {
      // If called without data, use existing sequenceLines (e.g., after restore)
      if (data && data.lines) {
        sequenceLines = data.lines;
      } else if (!sequenceLines || sequenceLines.length === 0) {
        console.error('Invalid sequence data');
        return;
      }
      
      // üîÑ MIGRATION: Convert old microsecond values to speedLevel (0-20)
      // If speed > 20, it's likely an old microsecond value (50-500¬µs)
      sequenceLines.forEach(line => {
        if (line.speedForward > 20) {
          // Old microsecond value: convert to speedLevel
          // 500¬µs = 1, 50¬µs = 20 (linear: speedLevel = 21 - delay/25)
          line.speedForward = Math.max(1, Math.min(20, 21 - line.speedForward / 25));
          console.log('‚ö†Ô∏è Converted old speedForward from ¬µs to speedLevel:', line.speedForward.toFixed(1));
        }
        if (line.speedBackward > 20) {
          line.speedBackward = Math.max(1, Math.min(20, 21 - line.speedBackward / 25));
          console.log('‚ö†Ô∏è Converted old speedBackward from ¬µs to speedLevel:', line.speedBackward.toFixed(1));
        }
      });
      
      const tbody = document.getElementById('sequenceTableBody');
      tbody.innerHTML = '';
      
      if (sequenceLines.length === 0) {
        tbody.innerHTML = `
          <tr>
            <td colspan="9" style="padding: 40px; text-align: center; color: #999;">
              <div style="font-size: 48px; margin-bottom: 10px;">üìã</div>
              <div style="font-size: 16px;">Aucune ligne - Cliquez sur "‚ûï Ajouter ligne" pour commencer</div>
            </td>
          </tr>
        `;
        return;
      }
      
      sequenceLines.forEach((line, index) => {
        const row = document.createElement('tr');
        row.style.background = line.enabled ? 'white' : '#f5f5f5';
        row.style.opacity = line.enabled ? '1' : '0.6';
        row.style.borderBottom = '1px solid #ddd';
        row.style.transition = 'all 0.2s';
        
        // Phase 2: Drag & Drop attributes
        row.draggable = true;
        row.classList.add('sequence-line-draggable');
        row.setAttribute('data-line-id', line.lineId);
        row.setAttribute('data-line-index', index);
        
        // Phase 2: Multi-select - check if selected
        if (selectedLineIds.has(line.lineId)) {
          row.classList.add('sequence-line-selected');
        }
        
        // Add tooltip data
        const tooltipContent = generateSequenceLineTooltip(line);
        row.setAttribute('data-tooltip', tooltipContent.replace(/"/g, '&quot;'));
        row.setAttribute('data-line-number', index + 1);
        
        // Movement type icon and info
        const movementType = line.movementType !== undefined ? line.movementType : 0;
        let typeIcon = '';
        let typeInfo = '';
        let typeName = '';
        
        if (movementType === 0) {
          // VA-ET-VIENT
          typeIcon = 'üîÑ';
          typeName = 'Va-et-vient';
          typeInfo = `
            <div style="font-size: 10px; line-height: 1.2;">
              <div>${line.startPositionMM.toFixed(1)}mm</div>
              <div>¬±${line.distanceMM.toFixed(1)}mm</div>
            </div>
          `;
        } else if (movementType === 1) {
          // OSCILLATION
          typeIcon = '„Ä∞Ô∏è';
          typeName = 'Oscillation';
          const waveformNames = ['SIN', 'TRI', 'SQR'];
          const waveformName = waveformNames[line.oscWaveform] || '?';
          typeInfo = `
            <div style="font-size: 10px; line-height: 1.2;">
              <div>C:${line.oscCenterPositionMM ? line.oscCenterPositionMM.toFixed(0) : '100'}mm</div>
              <div>A:¬±${line.oscAmplitudeMM ? line.oscAmplitudeMM.toFixed(0) : '50'}mm</div>
              <div>${waveformName} ${line.oscFrequencyHz ? line.oscFrequencyHz.toFixed(2) : '0.5'}Hz</div>
            </div>
          `;
        } else if (movementType === 2) {
          // CHAOS
          typeIcon = 'üåÄ';
          typeName = 'Chaos';
          typeInfo = `
            <div style="font-size: 10px; line-height: 1.2;">
              <div>‚è±Ô∏è${line.chaosDurationSeconds || 30}s</div>
              <div>üé≤${line.chaosCrazinessPercent ? line.chaosCrazinessPercent.toFixed(0) : '50'}%</div>
            </div>
          `;
        } else if (movementType === 4) {
          // CALIBRATION
          typeIcon = 'üìè';
          typeName = 'Calibration';
          typeInfo = `
            <div style="font-size: 10px; line-height: 1.2;">
              <div>Calibration</div>
              <div>compl√®te</div>
            </div>
          `;
        }
        
        // Deceleration summary - compact version (only for VAET)
        let decelSummary = '';
        if (movementType === 0 && (line.decelStartEnabled || line.decelEndEnabled)) {
          const parts = [];
          if (line.decelStartEnabled) parts.push('D');
          if (line.decelEndEnabled) parts.push('F');
          const modeLabels = ['Lin', 'Sin', 'Tri‚Åª¬π', 'Sin‚Åª¬π'];
          decelSummary = `
            <div style="font-size: 10px; line-height: 1.3;">
              <div style="color: #4CAF50; font-weight: bold;">${parts.join('/')}</div>
              <div>${line.decelZoneMM}mm ${line.decelEffectPercent}%</div>
              <div>${modeLabels[line.decelMode] || '?'}</div>
            </div>
          `;
        } else {
          decelSummary = '<span style="color: #999; font-size: 10px;">--</span>';
        }
        
        // Speeds - different display based on type
        let speedsDisplay = '';
        if (movementType === 0) {
          // VA-ET-VIENT: Forward/Backward speeds
          speedsDisplay = `
            <div style="font-size: 11px; line-height: 1.3;">
              <div style="color: #2196F3; font-weight: bold;">‚Üó${line.speedForward.toFixed(1)}</div>
              <div style="color: #FF9800; font-weight: bold;">‚Üô${line.speedBackward.toFixed(1)}</div>
            </div>
          `;
        } else if (movementType === 1) {
          // OSCILLATION: Calculated speed (2œÄ √ó f √ó A)
          const peakSpeedMMPerSec = 2 * Math.PI * line.oscFrequencyHz * line.oscAmplitudeMM;
          speedsDisplay = `
            <div style="font-size: 11px; font-weight: bold; color: #9C27B0;">
              ${peakSpeedMMPerSec.toFixed(0)} mm/s
            </div>
          `;
        } else {
          // CHAOS: Max speed
          speedsDisplay = `
            <div style="font-size: 11px; font-weight: bold; color: #E91E63;">
              ${line.chaosMaxSpeedLevel ? line.chaosMaxSpeedLevel.toFixed(1) : '10.0'}
            </div>
          `;
        }
        
        row.innerHTML = `
          <td style="padding: 4px 2px; text-align: center; border-right: 1px solid #eee;">
            <input type="checkbox" ${line.enabled ? 'checked' : ''} 
              onchange="toggleSequenceLine(${line.lineId}, this.checked)"
              style="width: 16px; height: 16px; cursor: pointer;">
          </td>
          <td style="padding: 4px 2px; text-align: center; font-weight: bold; color: #667eea; border-right: 1px solid #eee; font-size: 12px;">
            ${index + 1}
          </td>
          <td style="padding: 4px 2px; text-align: center; border-right: 1px solid #eee;" title="${movementType === 0 ? 'Va-et-vient' : (movementType === 1 ? 'Oscillation' : (movementType === 2 ? 'Chaos' : 'Calibration'))}">
            <div style="font-size: 16px;">${typeIcon}</div>
          </td>
          <td style="padding: 4px 2px; text-align: center; border-right: 1px solid #eee;">
            ${typeInfo}
          </td>
          <td style="padding: 4px 2px; text-align: center; border-right: 1px solid #eee;">
            <span style="color: #999; font-size: 10px;">--</span>
          </td>
          <td style="padding: 4px 2px; text-align: center; border-right: 1px solid #eee;">
            ${speedsDisplay}
          </td>
          <td style="padding: 4px 2px; text-align: center; border-right: 1px solid #eee;">
            ${decelSummary}
          </td>
          <td style="padding: 4px 2px; text-align: center; font-weight: bold; color: #FF9800; border-right: 1px solid #eee;">
            ${line.cycleCount}
          </td>
          <td style="padding: 4px 2px; text-align: center; color: ${line.pauseAfterMs > 0 ? '#9C27B0' : '#999'}; font-weight: ${line.pauseAfterMs > 0 ? 'bold' : 'normal'}; border-right: 1px solid #eee; font-size: 10px;">
            ${line.pauseAfterMs > 0 ? (line.pauseAfterMs / 1000).toFixed(1) + 's' : '--'}
          </td>
          <td style="padding: 4px 2px; text-align: center; white-space: nowrap;">
            <button onclick="testSequenceLine(${line.lineId})" 
              id="btnTestLine_${line.lineId}"
              style="background: #9C27B0; color: white; border: none; padding: 4px 6px; border-radius: 3px; cursor: pointer; margin: 1px; font-size: 12px;"
              title="Tester cette ligne">‚ñ∂Ô∏è</button>
            <button onclick="editSequenceLine(${line.lineId})" 
              style="background: #2196F3; color: white; border: none; padding: 4px 6px; border-radius: 3px; cursor: pointer; margin: 1px; font-size: 12px;"
              title="√âditer">‚úèÔ∏è</button>
            <button onclick="duplicateSequenceLine(${line.lineId})"
              style="background: #4CAF50; color: white; border: none; padding: 4px 6px; border-radius: 3px; cursor: pointer; margin: 1px; font-size: 12px;"
              title="Dupliquer">üìã</button>
            <span id="tooltipEye_${line.lineId}" class="sequence-tooltip-eye" data-line-id="${line.lineId}"
              style="display: inline-block; padding: 4px 6px; cursor: pointer; margin: 1px; font-size: 14px;"
              title="Voir d√©tails">üëÅÔ∏è</span>
          </td>
        `;
        
        // Add line type attribute
        row.setAttribute('data-line-type', typeName);
        
        // Hover effect (no tooltip on row hover)
        row.onmouseenter = function() {
          if (line.enabled && !this.classList.contains('sequence-line-selected')) {
            this.style.background = '#f0f4ff';
          }
        };
        row.onmouseleave = function() {
          if (!this.classList.contains('sequence-line-selected')) {
            this.style.background = line.enabled ? 'white' : '#f5f5f5';
          }
        };
        
        // Phase 2: Drag events
        row.ondragstart = function(e) {
          draggedLineId = line.lineId;
          draggedLineIndex = index;
          this.classList.add('sequence-line-dragging');
          e.dataTransfer.effectAllowed = 'move';
          e.dataTransfer.setData('text/plain', line.lineId);
          
          // Highlight permanent trash zone
          const trashDropZone = document.getElementById('sequenceTrashDropZone');
          if (trashDropZone) {
            trashDropZone.classList.add('drag-active');
          }
        };
        
        row.ondragend = function(e) {
          this.classList.remove('sequence-line-dragging');
          
          // Remove spacer row
          const spacer = document.querySelector('.sequence-drop-spacer');
          if (spacer) {
            spacer.remove();
          }
          
          // Reset permanent trash zone
          const trashDropZone = document.getElementById('sequenceTrashDropZone');
          if (trashDropZone) {
            trashDropZone.classList.remove('drag-active');
          }
        };
        
        row.ondragover = function(e) {
          if (draggedLineId === line.lineId) return;
          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';
          
          // Smart spacer positioning based on mouse Y position within row
          if (draggedLineId !== line.lineId) {
            // Get row bounds
            const rect = this.getBoundingClientRect();
            const mouseY = e.clientY;
            const rowMiddle = rect.top + (rect.height / 2);
            
            // Determine if we should insert BEFORE or AFTER based on mouse position
            let insertAfter;
            if (draggedLineIndex < index) {
              // Dragging DOWN: only show spacer if mouse is in bottom half of row
              insertAfter = (mouseY > rowMiddle);
            } else {
              // Dragging UP: show spacer based on mouse position
              insertAfter = (mouseY > rowMiddle);
            }
            
            // Calculate final target position after insert
            let finalTargetIndex;
            if (insertAfter) {
              finalTargetIndex = index;
            } else {
              finalTargetIndex = index - 1;
            }
            
            // Don't show spacer if it would result in same position (no movement)
            // Also block if trying to insert on the dragged line itself
            if (finalTargetIndex === draggedLineIndex || index === draggedLineIndex) {
              const existingSpacer = document.querySelector('.sequence-drop-spacer');
              if (existingSpacer) existingSpacer.remove();
              return false;
            }
            
            // Throttle: only update if 200ms elapsed since last update (reduce flicker)
            const now = Date.now();
            if (now - lastDragEnterTime < 200) return false;
            lastDragEnterTime = now;
            
            // Check if spacer already exists at correct position
            const existingSpacer = document.querySelector('.sequence-drop-spacer');
            if (existingSpacer) {
              const spacerParent = existingSpacer.parentNode;
              const spacerNextSibling = existingSpacer.nextSibling;
              const spacerPrevSibling = existingSpacer.previousSibling;
              
              // Check if spacer is already at correct position
              if (insertAfter && spacerPrevSibling === this) {
                // Already after this row, no need to recreate
                return false;
              }
              if (!insertAfter && spacerNextSibling === this) {
                // Already before this row, no need to recreate
                return false;
              }
              
              // Remove if position changed
              existingSpacer.remove();
            }
            
            // Create spacer row
            const spacer = document.createElement('tr');
            spacer.className = 'sequence-drop-spacer';
            spacer.innerHTML = '<td colspan="10" style="height: 50px; padding: 0; border: none; background: transparent;"><div class="sequence-drop-placeholder-inner">‚¨á Ins√©rer ici ‚¨á</div></td>';
            
            // Store target for drop handling
            spacer.dataset.targetLineId = line.lineId;
            spacer.dataset.targetIndex = index;
            
            // Make spacer droppable
            spacer.ondragover = function(e) {
              e.preventDefault();
              e.dataTransfer.dropEffect = 'move';
              return false;
            };
            
            spacer.ondrop = function(e) {
              e.preventDefault();
              e.stopPropagation();
              const targetRow = document.querySelector(`[data-line-id="${this.dataset.targetLineId}"]`);
              if (targetRow && targetRow.ondrop) {
                targetRow.ondrop(e);
              }
              return false;
            };
            
            // Insert spacer
            if (insertAfter) {
              this.parentNode.insertBefore(spacer, this.nextSibling);
            } else {
              this.parentNode.insertBefore(spacer, this);
            }
          }
          
          return false;
        };
        
        row.ondragenter = function(e) {
          // Just prevent default, ondragover handles everything
          if (draggedLineId === line.lineId) return;
          e.preventDefault();
        };
        
        row.ondragleave = function(e) {
          // Don't remove placeholder on leave - keep it visible
        };
        
        row.ondrop = function(e) {
          e.stopPropagation();
          e.preventDefault();
          
          // Remove spacer row
          const spacer = document.querySelector('.sequence-drop-spacer');
          if (spacer) {
            spacer.remove();
          }
          
          if (draggedLineId && draggedLineId !== line.lineId) {
            // Calculate direction: drag FROM draggedLineIndex TO index
            const targetIndex = index;
            let direction;
            
            if (draggedLineIndex < targetIndex) {
              // Moving down: need (targetIndex - draggedLineIndex) moves down
              direction = targetIndex - draggedLineIndex;
            } else {
              // Moving up: need -(draggedLineIndex - targetIndex) moves up
              direction = -(draggedLineIndex - targetIndex);
            }
            
            // Send multiple move commands to backend
            console.log(`üì¶ Drag: line ${draggedLineId} from index ${draggedLineIndex} to ${targetIndex} (${direction} moves)`);
            
            // Execute moves sequentially
            let movesRemaining = Math.abs(direction);
            const moveDirection = direction > 0 ? 1 : -1;
            
            const executeMove = () => {
              if (movesRemaining > 0) {
                sendCommand('moveSequenceLine', { lineId: draggedLineId, direction: moveDirection });
                movesRemaining--;
                setTimeout(executeMove, 100); // Wait 100ms between moves
              } else {
                // After move complete: clear selection if dragged line was selected
                if (selectedLineIds.has(draggedLineId)) {
                  selectedLineIds.delete(draggedLineId);
                  updateBatchToolbar();
                  renderSequenceTable({ lines: sequenceLines });
                }
              }
            };
            
            executeMove();
          }
          
          return false;
        };
        
        // Phase 2: Multi-select click handler
        row.onclick = function(e) {
          // Don't trigger if clicking on buttons or checkbox
          if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT') {
            return;
          }
          
          if (e.shiftKey && lastSelectedIndex !== null) {
            // Shift+Click: select range
            const startIdx = Math.min(lastSelectedIndex, index);
            const endIdx = Math.max(lastSelectedIndex, index);
            
            for (let i = startIdx; i <= endIdx; i++) {
              if (i < sequenceLines.length) {
                selectedLineIds.add(sequenceLines[i].lineId);
              }
            }
          } else if (e.ctrlKey || e.metaKey) {
            // Ctrl+Click: toggle selection
            if (selectedLineIds.has(line.lineId)) {
              selectedLineIds.delete(line.lineId);
            } else {
              selectedLineIds.add(line.lineId);
            }
          } else {
            // Regular click: select only this line
            selectedLineIds.clear();
            selectedLineIds.add(line.lineId);
          }
          
          lastSelectedIndex = index;
          updateBatchToolbar();
          renderSequenceTable({ lines: sequenceLines }); // Re-render to show selection
        };
        
        tbody.appendChild(row);
        
        // NOW attach eye icon tooltip handler (after DOM insertion)
        setTimeout(() => {
          const eyeIcon = document.getElementById('tooltipEye_' + line.lineId);
          if (eyeIcon) {
            eyeIcon.onmouseenter = function(e) {
              showSequenceTooltip(row);
            };
            eyeIcon.onmouseleave = function() {
              hidePlaylistTooltip();
            };
          }
        }, 0);
      });
      
      // Add drag leave handler to tbody to cleanup spacer if leaving table
      tbody.ondragleave = function(e) {
        // Only remove if leaving tbody completely (not entering child element)
        if (!this.contains(e.relatedTarget)) {
          const spacer = document.querySelector('.sequence-drop-spacer');
          if (spacer) {
            spacer.remove();
          }
        }
      };
      
      // Update batch toolbar visibility
      updateBatchToolbar();
      
      // Initialize trash zones drag handlers (only once)
      initializeTrashZones();
      
      // Re-disable test buttons if testing (in case of re-render during test)
      // But do it synchronously to avoid timing issues
      if (window.isTestingLine) {
        document.querySelectorAll('[id^="btnTestLine_"]').forEach(btn => {
          btn.disabled = true;
          btn.style.opacity = '0.5';
          btn.style.cursor = 'not-allowed';
        });
        // Also re-disable start buttons using setButtonState
        if (DOM.btnStartSequence) setButtonState(DOM.btnStartSequence, false);
        if (DOM.btnLoopSequence) setButtonState(DOM.btnLoopSequence, false);
      }
    }
    
    /**
     * Phase 2: Initialize trash zones drag & drop handlers
     */
    function initializeTrashZones() {
      // Toolbar trash zone (batch operations)
      const trashZone = document.getElementById('sequenceTrashZone');
      if (trashZone && !trashZone.hasAttribute('data-initialized')) {
        trashZone.setAttribute('data-initialized', 'true');
      
      trashZone.ondragover = function(e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
        this.classList.add('drag-over');
        return false;
      };
      
      trashZone.ondragleave = function(e) {
        if (!this.contains(e.relatedTarget)) {
          this.classList.remove('drag-over');
        }
      };
      
      trashZone.ondrop = function(e) {
        e.preventDefault();
        e.stopPropagation();
        this.classList.remove('drag-over');
        
        // Get dragged line(s)
        const linesToDelete = selectedLineIds.size > 0 ? 
          Array.from(selectedLineIds) : 
          [draggedLineId];
        
        if (linesToDelete.length === 0) return;
        
        // Confirm deletion
        const count = linesToDelete.length;
        const message = count === 1 ? 
          `‚ö†Ô∏è Supprimer la ligne s√©lectionn√©e ?\n\nCette action est irr√©versible.` :
          `‚ö†Ô∏è Supprimer ${count} lignes s√©lectionn√©es ?\n\nCette action est irr√©versible.`;
        
        if (!confirm(message)) return;
        
        console.log(`üóëÔ∏è Trash zone drop: deleting ${count} line(s)`);
        
        // Sort descending to delete from end
        const sortedIds = linesToDelete.sort((a, b) => b - a);
        
        sortedIds.forEach(lineId => {
          sendCommand('deleteSequenceLine', { lineId: lineId });
        });
        
        showNotification(`‚úÖ ${count} ligne(s) supprim√©e(s)`, 'success', 2000);
        
        // Clear selection
        clearSelection();
        
        return false;
      };
      }
      
      // Permanent trash drop zone (always visible)
      const trashDropZone = document.getElementById('sequenceTrashDropZone');
      if (trashDropZone && !trashDropZone.hasAttribute('data-initialized')) {
        trashDropZone.setAttribute('data-initialized', 'true');
        
        trashDropZone.ondragover = function(e) {
          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';
          return false;
        };
        
        trashDropZone.ondrop = function(e) {
          e.preventDefault();
          e.stopPropagation();
          
          // Get dragged line(s)
          const linesToDelete = selectedLineIds.size > 0 ? 
            Array.from(selectedLineIds) : 
            [draggedLineId];
          
          if (linesToDelete.length === 0) return;
          
          // Confirm deletion
          const count = linesToDelete.length;
          const message = count === 1 ? 
            `‚ö†Ô∏è Supprimer la ligne s√©lectionn√©e ?\n\nCette action est irr√©versible.` :
            `‚ö†Ô∏è Supprimer ${count} lignes s√©lectionn√©es ?\n\nCette action est irr√©versible.`;
          
          if (!confirm(message)) return;
          
          console.log(`üóëÔ∏è Permanent trash zone drop: deleting ${count} line(s)`);
          
          // Sort descending to delete from end
          const sortedIds = linesToDelete.sort((a, b) => b - a);
          
          sortedIds.forEach(lineId => {
            sendCommand('deleteSequenceLine', { lineId: lineId });
          });
          
          showNotification(`‚úÖ ${count} ligne(s) supprim√©e(s)`, 'success', 2000);
          
          // Clear selection
          clearSelection();
          
          return false;
        };
      }
    }
    
    /**
     * Phase 2: Update batch toolbar visibility and count
     */
    function updateBatchToolbar() {
      const toolbar = document.getElementById('sequenceBatchToolbar');
      const countDisplay = document.getElementById('batchSelectionCount');
      
      if (selectedLineIds.size > 0) {
        toolbar.classList.add('visible');
        countDisplay.textContent = `${selectedLineIds.size} ligne(s) s√©lectionn√©e(s)`;
      } else {
        toolbar.classList.remove('visible');
      }
    }
    
    /**
     * Phase 2: Clear all selections
     */
    function clearSelection() {
      selectedLineIds.clear();
      lastSelectedIndex = null;
      updateBatchToolbar();
      renderSequenceTable({ lines: sequenceLines });
    }
    
    /**
     * Phase 2: Batch enable/disable lines
     */
    function batchEnableLines(enabled) {
      if (selectedLineIds.size === 0) return;
      
      console.log(`üì¶ Batch ${enabled ? 'enable' : 'disable'} ${selectedLineIds.size} lines`);
      
      selectedLineIds.forEach(lineId => {
        sendCommand('toggleSequenceLine', { lineId: lineId, enabled: enabled });
        
        // Update local state
        const line = sequenceLines.find(l => l.lineId === lineId);
        if (line) {
          line.enabled = enabled;
        }
      });
      
      showNotification(`‚úÖ ${selectedLineIds.size} ligne(s) ${enabled ? 'activ√©e(s)' : 'd√©sactiv√©e(s)'}`, 'success', 2000);
      
      // Clear selection after operation
      clearSelection();
    }
    
    /**
     * Phase 2: Batch delete lines
     */
    function batchDeleteLines() {
      if (selectedLineIds.size === 0) return;
      
      const count = selectedLineIds.size;
      if (!confirm(`‚ö†Ô∏è Supprimer ${count} ligne(s) s√©lectionn√©e(s) ?\n\nCette action est irr√©versible.`)) {
        return;
      }
      
      console.log(`üì¶ Batch delete ${count} lines`);
      
      // Convert to array and sort by lineId descending (delete from end to avoid index shifts)
      const lineIdsArray = Array.from(selectedLineIds).sort((a, b) => b - a);
      
      lineIdsArray.forEach(lineId => {
        sendCommand('deleteSequenceLine', { lineId: lineId });
      });
      
      showNotification(`‚úÖ ${count} ligne(s) supprim√©e(s)`, 'success', 2000);
      
      // Clear selection
      clearSelection();
    }
    
    function updateSequenceStatus(status) {
      if (!status) return;
      
      // Update mode
      const modeText = status.isRunning 
        ? (status.isLoopMode ? 'üîÅ BOUCLE INFINIE' : '‚ñ∂Ô∏è LECTURE UNIQUE')
        : '‚èπÔ∏è Arr√™t√©';
      DOM.seqMode.textContent = modeText;
      DOM.seqMode.style.color = status.isRunning ? '#4CAF50' : '#999';
      
      // Update current line
      const lineText = status.isRunning 
        ? `${status.currentLineNumber} / ${status.totalLines}`
        : '-- / --';
      DOM.seqCurrentLine.textContent = lineText;
      
      // Update cycle
      DOM.seqLineCycle.textContent = 
        status.isRunning ? status.currentCycle : '--';
      
      // Update loop count
      DOM.seqLoopCount.textContent = status.loopCount || 0;
      
      // Update pause remaining
      const pauseText = status.pauseRemaining > 0 
        ? `${status.pauseRemaining} ms`
        : '-- ms';
      DOM.seqPauseRemaining.textContent = pauseText;
      
      // Button states: ONLY controlled by backend sequenceStatus
      // Backend says "running" = buttons disabled, "stopped" = buttons enabled
      const isRunning = status.isRunning;
      
      // Auto-restore sequence after test
      if (!isRunning && window.isTestingLine) {
        console.log('üîÑ Test finished, scheduling restore...');
        setTimeout(() => {
          restoreSequenceAfterTest();
        }, 500);
      }
      
      // Start buttons: enable ONLY when backend confirms sequence stopped
      // BUT: Keep disabled during line test (will be re-enabled by restoreSequenceAfterTest)
      console.log('üîç updateSequenceStatus: isRunning=', isRunning, 'isTestingLine=', window.isTestingLine);
      if (!isRunning && !window.isTestingLine) {
        const canStart = canStartOperation();
        console.log('üü¢ Enabling start buttons, canStart=', canStart);
        setButtonState(DOM.btnStartSequence, canStart);
        setButtonState(DOM.btnLoopSequence, canStart);
      } else {
        console.log('üî¥ Keeping start buttons disabled');
        // Force disable to override any other updates
        setButtonState(DOM.btnStartSequence, false);
        setButtonState(DOM.btnLoopSequence, false);
      }
      // If running or testing, keep disabled (already disabled on click or by testSequenceLine)
      
      // Control buttons: available while running
      setButtonState(DOM.btnPauseSequence, isRunning);
      setButtonState(DOM.btnStopSequence, isRunning);
      setButtonState(DOM.btnSkipLine, isRunning);
      
      // Update pause button text
      if (isRunning && status.isPaused) {
        DOM.btnPauseSequence.innerHTML = '‚ñ∂Ô∏è Reprendre';
      } else {
        DOM.btnPauseSequence.innerHTML = '‚è∏Ô∏è Pause';
      }
      
      // Highlight active line using currentLineIndex (not currentLineId)
      const tbody = document.getElementById('sequenceTableBody');
      if (tbody) {
        const rows = tbody.querySelectorAll('tr');
        rows.forEach(row => {
          row.classList.remove('sequence-line-active');
        });
        
        if (isRunning && status.currentLineIndex !== undefined) {
          // Backend sends 0-based currentLineIndex
          const activeIndex = status.currentLineIndex;
          
          if (activeIndex >= 0 && activeIndex < rows.length) {
            rows[activeIndex].classList.add('sequence-line-active');
            
            // Scroll to active line
            rows[activeIndex].scrollIntoView({ behavior: 'smooth', block: 'nearest' });
          }
        }
      }
    }
    
    // ========================================================================
    // WEBSOCKET CONNECTION
    // ========================================================================
    
    function connectWebSocket() {
      AppState.ws = new WebSocket('ws://' + window.location.hostname + ':81');
      
      AppState.ws.onopen = function() {
        console.log('WebSocket connected');
        document.getElementById('state').textContent = 'Connect√© au contr√¥leur';
        
        // Initialize pattern toggle button state
        updatePatternToggleButton();
        
        // Request status after a short delay to ensure everything is ready
        setTimeout(function() {
          sendCommand('getStatus', {});
        }, 50);
      };
      
      AppState.ws.onmessage = function(event) {
        try {
          const data = JSON.parse(event.data);
          
          // Handle error messages (high priority)
          if (data.type === 'error') {
            showNotification(data.message, 'error');
            return;
          }
          
          // Handle specific message types for MODE TABLEAU
          if (data.type === 'sequenceTable') {
            renderSequenceTable(data.data);
            return;
          }
          
          if (data.type === 'sequenceStatus') {
            updateSequenceStatus(data);
            return;
          }
          
          if (data.type === 'exportData') {
            // Download JSON file
            const jsonStr = JSON.stringify(data.data, null, 2);
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'sequence_' + new Date().toISOString().slice(0,10) + '.json';
            a.click();
            URL.revokeObjectURL(url);
            return;
          }

          if (data.type === 'fsList') {
            // display the index.html timestamp in the sequence tab
            if (data.files && data.files.length > 0) {
              const idxFile = data.files.find(f => f.name === '/index.html' || f.name === 'index.html');
              if (idxFile) {
                const el = document.getElementById('fsIndexTimestamp');
                if (el) el.textContent = 'index.html: ' + idxFile.time;
              }
            }
            return;
          }

          if (data.type === 'log') {
            // Display log in the common logs panel
            if (DOM.logConsolePanel) {
              const level = data.level || 'INFO';
              const msg = data.message || '';
              
              // Color coding based on log level (VSCode Dark+ theme inspired)
              const colors = {
                'ERROR': '#f48771',   // Red
                'WARN': '#dcdcaa',    // Yellow
                'INFO': '#4ec9b0',    // Cyan
                'DEBUG': '#9cdcfe'    // Blue
              };
              const color = colors[level] || '#d4d4d4';
              
              const timestamp = new Date().toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
              const lineEl = document.createElement('div');
              lineEl.style.color = color;
              lineEl.textContent = `[${timestamp}] [${level}] ${msg}`;
              DOM.logConsolePanel.appendChild(lineEl);
              DOM.logConsolePanel.scrollTop = DOM.logConsolePanel.scrollHeight;
              
              // Auto-scroll and limit to 500 lines
              while (DOM.logConsolePanel.children.length > 500) {
                DOM.logConsolePanel.removeChild(DOM.logConsolePanel.firstChild);
              }
            }
            return;
          }
          
          // Default: update main UI
          updateUI(data);
        } catch (e) {
          console.error('WebSocket parse error:', e, 'Raw data:', event.data);
          showNotification('Erreur de communication avec l\'ESP32', 'error');
        }
      };
      
      AppState.ws.onclose = function() {
        console.log('WebSocket disconnected. Reconnecting...');
        if (DOM.state) {
          DOM.state.textContent = 'D√©connect√© - Reconnexion...';
        }
        setTimeout(connectWebSocket, 2000);
      };
      
      AppState.ws.onerror = function(error) {
        console.error('WebSocket error:', error);
        if (DOM.state) {
          DOM.state.textContent = 'Erreur de connexion';
        }
        showNotification('Erreur WebSocket - V√©rifiez la connexion', 'error');
      };
    }
    
    // ============================================================================
    // UNIFIED NOTIFICATION SYSTEM
    // ============================================================================
    
    function showNotification(message, type = 'error', duration = 5000) {
      // Remove existing notification if any
      const existingNotif = document.querySelector('.notification');
      if (existingNotif) {
        existingNotif.remove();
      }
      
      // Create notification element
      const notif = document.createElement('div');
      notif.className = 'notification notification-' + type;
      notif.textContent = message;
      document.body.appendChild(notif);
      
      // Show notification
      setTimeout(() => {
        notif.classList.add('show');
      }, 10);
      
      // Auto-hide after duration
      setTimeout(() => {
        notif.classList.remove('show');
        setTimeout(() => notif.remove(), 300);
      }, duration);
    }
    
    // ============================================================================
    // UI UPDATE
    // ============================================================================
    
    function updateUI(data) {
      // Defensive check: only process status-like messages which contain positionMM
      // Some incoming messages (logs, fsList, etc.) can be generic JSON and should
      // not be passed to updateUI. Guard against missing fields to avoid runtime
      // errors like "cannot read property 'toFixed' of undefined".
      if (!data || !('positionMM' in data)) {
        console.warn('updateUI: unexpected message, skipping', data);
        return;
      }
      // Update global state for mode change logic
      AppState.system.currentState = data.state;
      AppState.system.canStart = data.canStart || false;
      
      const stateText = ['Initialisation', 'Calibration...', 'Pr√™t', 'En marche', 'En pause', 'Erreur'];
      const stateClass = ['state-init', 'state-calibrating', 'state-ready', 'state-running', 'state-paused', 'state-error'];
      
      let displayText = stateText[data.state] || 'Inconnu';
      if (data.errorMessage && data.errorMessage !== '') {
        displayText += ' ‚ö†Ô∏è ' + data.errorMessage;
      }
      
      DOM.state.textContent = displayText;
      DOM.state.className = 'status-value ' + (stateClass[data.state] || '');
      
      // Check if calibrating (used in multiple places below)
      const isCalibrating = data.state === SystemState.CALIBRATING;
      
      // Show/hide calibration overlay
      if (DOM.calibrationOverlay) {
        if (isCalibrating) {
          DOM.calibrationOverlay.classList.add('active');
        } else {
          DOM.calibrationOverlay.classList.remove('active');
        }
      }
      
      // Show tabs and controls after first successful calibration
      // Once calibrated (canStart = true), reveal the interface
      if (AppState.system.canStart && data.totalDistMM > 0) {
        const tabsContainer = document.getElementById('tabsContainer');
        const allTabContents = document.querySelectorAll('.tab-content');
        const welcomeMessage = document.getElementById('welcomeMessage');
        
        // Hide welcome message
        if (welcomeMessage && !welcomeMessage.classList.contains('hidden')) {
          welcomeMessage.classList.add('hidden');
        }
        
        // Show tabs
        if (tabsContainer && tabsContainer.classList.contains('hidden-until-calibrated')) {
          tabsContainer.classList.remove('hidden-until-calibrated');
        }
        
        // Show all tab contents
        allTabContents.forEach(tabContent => {
          if (tabContent.classList.contains('hidden-until-calibrated')) {
            tabContent.classList.remove('hidden-until-calibrated');
          }
        });
      }
      
      // Extra safety: check fields exist before accessing (defense-in-depth)
      if (data.positionMM !== undefined && data.currentStep !== undefined) {
        currentPositionMM = data.positionMM; // Update global position tracker
        DOM.position.textContent = 
          data.positionMM.toFixed(2) + ' mm (' + data.currentStep + ' steps)';
      }
      
      if (data.totalDistMM !== undefined) {
        // Display total distance with limit info if applicable
        let totalDistText = data.totalDistMM.toFixed(2) + ' mm';
        if (data.maxDistLimitPercent && data.maxDistLimitPercent < 100) {
          totalDistText += ' (' + data.effectiveMaxDistMM.toFixed(2) + ' mm @ ' + 
                          data.maxDistLimitPercent.toFixed(0) + '%)';
        }
        DOM.totalDist.textContent = totalDistText;
        if (DOM.maxDist) {
          DOM.maxDist.textContent = data.totalDistMM.toFixed(2);
        }
        
        // Update max dist limit slider if data received (but NOT while user is editing!)
        if (data.maxDistLimitPercent && !isEditingMaxDistLimit) {
          DOM.maxDistLimitSlider.value = data.maxDistLimitPercent.toFixed(0);
          updateMaxDistLimitUI();
        }
      }
      
      // Update pursuit mode variables
      if (data.totalDistMM !== undefined) {
        AppState.pursuit.totalDistanceMM = data.totalDistMM;
        
        // Store max distance limit percent in AppState (but not while user is editing!)
        if (data.maxDistLimitPercent !== undefined && !isEditingMaxDistLimit) {
          AppState.pursuit.maxDistLimitPercent = data.maxDistLimitPercent;
        }
        
        // Update gauge limit line
        if (data.maxDistLimitPercent && data.maxDistLimitPercent < 100 && data.effectiveMaxDistMM) {
          const limitPercent = (data.effectiveMaxDistMM / data.totalDistMM);
          const containerHeight = DOM.gaugeContainer ? DOM.gaugeContainer.offsetHeight : 500;
          const limitPixelPosition = containerHeight - (limitPercent * containerHeight);
          
          DOM.gaugeLimitLine.style.top = limitPixelPosition + 'px';
          DOM.gaugeLimitLine.style.display = 'block';
        } else if (DOM.gaugeLimitLine) {
          DOM.gaugeLimitLine.style.display = 'none';
        }
      }
      if (data.positionMM !== undefined) {
        AppState.pursuit.currentPositionMM = data.positionMM;
        updateGaugePosition(AppState.pursuit.currentPositionMM);
      }
      
      // Update speed display based on CURRENT ACTIVE MODE (not just data availability)
      const speedElement = document.getElementById('currentSpeed');
      const cpmSpan = speedElement ? speedElement.nextElementSibling : null;
      const currentMode = AppState.system.currentMode;
      
      if (currentMode === 'oscillation' && data.oscillation && data.oscillation.frequencyHz !== undefined && data.oscillation.amplitudeMM !== undefined) {
        // OSCILLATION MODE: Show ACTUAL speed (backend calculates with hardware limits)
        // If actualSpeedMMS is provided, use it (accounts for adaptive delay)
        // Otherwise fallback to theoretical peak speed calculation
        let displaySpeed;
        let isLimited = false;
        
        if (data.oscillation.actualSpeedMMS !== undefined && data.oscillation.actualSpeedMMS > 0) {
          // Use actual speed from backend (considers hardware limits)
          displaySpeed = parseFloat(data.oscillation.actualSpeedMMS);
          
          // Check if speed was limited
          const theoreticalSpeed = 2 * Math.PI * data.oscillation.frequencyHz * data.oscillation.amplitudeMM;
          isLimited = (displaySpeed < theoreticalSpeed - 1); // 1 mm/s tolerance
        } else {
          // Fallback: calculate theoretical peak speed
          displaySpeed = 2 * Math.PI * data.oscillation.frequencyHz * data.oscillation.amplitudeMM;
        }
        
        speedElement.innerHTML = 'üåä ' + displaySpeed.toFixed(0) + ' mm/s' + (isLimited ? ' ‚ö†Ô∏è' : '');
        
        if (cpmSpan) {
          cpmSpan.textContent = '(pic, f=' + data.oscillation.frequencyHz.toFixed(2) + ' Hz' + 
                                (isLimited ? ', limit√©' : '') + ')';
        }
      } else if (currentMode === 'chaos' && data.chaos && data.chaos.maxSpeedLevel !== undefined) {
        // CHAOS MODE: Show max speed level
        const speedMMPerSec = data.chaos.maxSpeedLevel * 10.0;
        speedElement.innerHTML = '‚ö° ' + data.chaos.maxSpeedLevel.toFixed(1);
        
        if (cpmSpan) {
          cpmSpan.textContent = '(max ' + speedMMPerSec.toFixed(0) + ' mm/s)';
        }
      } else if (currentMode === 'pursuit' && pursuitMaxSpeedLevel !== undefined) {
        // PURSUIT MODE: Show max speed level from UI variable
        const speedMMPerSec = pursuitMaxSpeedLevel * 10.0;
        speedElement.innerHTML = '‚ö° ' + pursuitMaxSpeedLevel.toFixed(1);
        
        if (cpmSpan) {
          cpmSpan.textContent = '(max ' + speedMMPerSec.toFixed(0) + ' mm/s)';
        }
      } else if (currentMode === 'sequencer') {
        // SEQUENCER MODE: Show mode indicator
        speedElement.innerHTML = '- (mode s√©quence)';
        if (cpmSpan) {
          cpmSpan.textContent = '';
        }
      } else if (currentMode === 'simple' && data.motion && data.cyclesPerMinForward !== undefined && data.cyclesPerMinBackward !== undefined) {
        // SIMPLE MODE: Show forward/backward speeds with cycles/min
        const avgCpm = ((data.cyclesPerMinForward + data.cyclesPerMinBackward) / 2).toFixed(0);
        speedElement.innerHTML = 
          '‚ÜóÔ∏è ' + data.motion.speedLevelForward.toFixed(1) + 
          '&nbsp;&nbsp;‚Ä¢&nbsp;&nbsp;' +
          '‚ÜôÔ∏è ' + data.motion.speedLevelBackward.toFixed(1);
        
        if (cpmSpan) {
          cpmSpan.textContent = '(' + avgCpm + ' c/min)';
        }
      }
      
      if (data.totalTraveled !== undefined) {
        DOM.totalTraveled.textContent = (data.totalTraveled / 1000.0).toFixed(3) + " m";

        
        // Update milestone icon
        const milestoneInfo = getMilestoneInfo(data.totalTraveled / 1000.0); // Convert mm to m
        
        if (milestoneInfo.current) {
          // Build tooltip with progress info
          let tooltip = `${milestoneInfo.current.emoji} ${milestoneInfo.current.name} (${milestoneInfo.current.threshold}m)`;
          if (milestoneInfo.current.location !== "-") {
            tooltip += ` - ${milestoneInfo.current.location}`;
          }
          
          if (milestoneInfo.next) {
            tooltip += `\n\n‚è≠Ô∏è Prochain: ${milestoneInfo.next.emoji} ${milestoneInfo.next.name} (${milestoneInfo.next.threshold}m)`;
            tooltip += `\nüìä Progression: ${milestoneInfo.progressPercent}%`;
          } else {
            tooltip += `\n\nüéâ Dernier jalon atteint!`;
          }
          
          DOM.milestoneIcon.textContent = milestoneInfo.current.emoji;
          DOM.milestoneIcon.title = tooltip;
          
          // Check if milestone changed (achievement notification)
          if (AppState.milestone.lastThreshold < milestoneInfo.current.threshold) {
            // New milestone achieved!
            AppState.milestone.lastThreshold = milestoneInfo.current.threshold;
            
            // Trigger animation
            DOM.milestoneIcon.classList.remove('milestone-achievement');
            void DOM.milestoneIcon.offsetWidth; // Force reflow
            DOM.milestoneIcon.classList.add('milestone-achievement');
            
            // Show notification
            let message = `üéâ Jalon atteint: ${milestoneInfo.current.emoji} ${milestoneInfo.current.name} (${milestoneInfo.current.threshold}m)`;
            if (milestoneInfo.next) {
              message += `\n‚è≠Ô∏è Prochain objectif: ${milestoneInfo.next.name} (${milestoneInfo.next.threshold}m) - ${milestoneInfo.progressPercent}%`;
            }
            showNotification(message, 'success', 6000);
          }
          
          AppState.milestone.current = milestoneInfo.current;
        } else {
          // No milestone reached yet
          if (milestoneInfo.next) {
            const tooltip = `‚è≠Ô∏è Prochain: ${milestoneInfo.next.emoji} ${milestoneInfo.next.name} (${milestoneInfo.next.threshold}m)\nüìä Progression: ${milestoneInfo.progressPercent}%`;
            DOM.milestoneIcon.textContent = 'üêú';
            DOM.milestoneIcon.title = tooltip;
          } else {
            DOM.milestoneIcon.textContent = '';
            DOM.milestoneIcon.title = '';
          }
        }
      }
      
      if (data.totalDistMM > 0 && data.positionMM !== undefined) {
        const progress = (data.positionMM / data.totalDistMM) * 100;
        const progressMini = document.getElementById('progressMini');
        const progressPct = document.getElementById('progressPct');
        if (progressMini) progressMini.style.width = progress + '%';
        if (progressPct) progressPct.textContent = progress.toFixed(1) + '%';
      }
      
      // Sync input values with server state (but not if user is editing)
      // Also check activeElement to prevent overwriting during typing
      if (AppState.editing.input !== 'startPosition' && document.activeElement !== DOM.startPosition) {
        DOM.startPosition.value = data.motion.startPositionMM.toFixed(1);
      }
      if (AppState.editing.input !== 'distance' && document.activeElement !== DOM.distance) {
        DOM.distance.value = data.targetDistMM.toFixed(1);
      }
      // Update speed values based on unified/separate mode
      const isSeparateMode = document.getElementById('speedModeSeparate')?.checked || false;
      
      if (isSeparateMode) {
        // SEPARATE MODE: update forward and backward individually
        if (AppState.editing.input !== 'speedForward' && document.activeElement !== DOM.speedForward) {
          DOM.speedForward.value = data.motion.speedLevelForward.toFixed(1);
        }
        if (AppState.editing.input !== 'speedBackward' && document.activeElement !== DOM.speedBackward) {
          DOM.speedBackward.value = data.motion.speedLevelBackward.toFixed(1);
        }
        // Speed info removed in compact mode
        if (DOM.speedForwardInfo) {
          DOM.speedForwardInfo.textContent = 
            '‚âà ' + data.cyclesPerMinForward.toFixed(0) + ' cycles/min';
        }
        if (DOM.speedBackwardInfo) {
          DOM.speedBackwardInfo.textContent = 
            '‚âà ' + data.cyclesPerMinBackward.toFixed(0) + ' cycles/min';
        }
      } else {
        // UNIFIED MODE: show current speed (should be same for both directions)
        if (AppState.editing.input !== 'speedUnified' && document.activeElement !== DOM.speedUnified) {
          // Use backward speed as reference (shows what user just changed)
          // In unified mode, both speeds should be identical, but we show backward
          // to ensure the displayed value reflects the most recent change
          DOM.speedUnified.value = data.motion.speedLevelBackward.toFixed(1);
          
          // Also keep separate fields in sync (hidden but used when switching modes)
          DOM.speedForward.value = data.motion.speedLevelForward.toFixed(1);
          DOM.speedBackward.value = data.motion.speedLevelBackward.toFixed(1);
        }
        
        // Speed info removed in compact mode
        if (DOM.speedUnifiedInfo) {
          const avgCyclesPerMin = (data.cyclesPerMinForward + data.cyclesPerMinBackward) / 2.0;
          DOM.speedUnifiedInfo.textContent = 
            '‚âà ' + avgCyclesPerMin.toFixed(0) + ' cycles/min';
        }
      }
      
      // Update max values and presets
      // Use effective max distance (factored) if available, otherwise total
      const effectiveMax = (data.effectiveMaxDistMM && data.effectiveMaxDistMM > 0) ? data.effectiveMaxDistMM : data.totalDistMM;
      const maxAvailable = effectiveMax - data.motion.startPositionMM;
      
      DOM.startPosition.max = effectiveMax;
      DOM.distance.max = maxAvailable;
      
      // Show factored value if limit < 100% (only if elements exist)
      if (DOM.maxStart) {
        if (data.maxDistLimitPercent && data.maxDistLimitPercent < 100) {
          DOM.maxStart.textContent = effectiveMax.toFixed(2) + ' (' + data.maxDistLimitPercent.toFixed(0) + '% de ' + data.totalDistMM.toFixed(2) + ')';
        } else {
          DOM.maxStart.textContent = effectiveMax.toFixed(2);
        }
      }
      
      if (DOM.maxDist) {
        DOM.maxDist.textContent = maxAvailable.toFixed(2);
      }
      updateStartPresets(effectiveMax);
      updateDistancePresets(maxAvailable);
      
      // Enable/disable start button
      const isRunning = data.state === SystemState.RUNNING;
      const isPausedState = data.state === SystemState.PAUSED;
      const canStart = canStartOperation() && !isRunning && !isPausedState;
      
      setButtonState(DOM.btnStart, canStart);
      
      // Enable/disable calibrate button (now in common tools section)
      if (DOM.btnCalibrateCommon) {
        if (!data.canCalibrate) {
          DOM.btnCalibrateCommon.disabled = true;
          DOM.btnCalibrateCommon.style.opacity = '0.5';
          DOM.btnCalibrateCommon.style.cursor = 'not-allowed';
        } else {
          DOM.btnCalibrateCommon.disabled = false;
          DOM.btnCalibrateCommon.style.opacity = '1';
          DOM.btnCalibrateCommon.style.cursor = 'pointer';
        }
      }
      
      // Disable inputs during calibration (but allow changes during running)
      const inputsEnabled = canStartOperation();
      
      // Update input fields state
      [DOM.startPosition, DOM.distance, DOM.speedUnified, DOM.speedForward, DOM.speedBackward].forEach(input => {
        if (input) {
          input.disabled = !inputsEnabled;
          input.style.opacity = inputsEnabled ? '1' : '0.6';
        }
      });
      
      // Update pursuit controls
      if (DOM.pursuitActiveCheckbox) DOM.pursuitActiveCheckbox.disabled = !inputsEnabled;
      setButtonState(DOM.btnActivatePursuit, inputsEnabled);
      
      // Update deceleration zone configuration from server
      if (data.decelZone && AppState.editing.input !== 'decelZone') {
        const section = document.getElementById('decelSection');
        const headerText = document.getElementById('decelHeaderText');
        
        // Update section collapsed state and header text based on enabled
        if (data.decelZone.enabled) {
          section.classList.remove('collapsed');
          headerText.textContent = 'üéØ D√©c√©l√©ration - activ√©e';
        } else {
          section.classList.add('collapsed');
          headerText.textContent = 'üéØ D√©c√©l√©ration - d√©sactiv√©e';
        }
        
        document.getElementById('decelZoneStart').checked = data.decelZone.enableStart;
        document.getElementById('decelZoneEnd').checked = data.decelZone.enableEnd;
        
        // Check if zone value was adapted by ESP32 (only if we just sent a request)
        const decelZoneInput = document.getElementById('decelZoneMM');
        const requestedZone = AppState.lastDecelZoneRequest;
        const receivedZone = data.decelZone.zoneMM;
        
        if (requestedZone !== undefined && Math.abs(requestedZone - receivedZone) > 0.1) {
          // Value was adapted - show notification once
          showNotification(`‚ö†Ô∏è Zone ajust√©e: ${requestedZone.toFixed(0)}mm ‚Üí ${receivedZone.toFixed(0)}mm (limite du mouvement)`, 'warning', 4000);
          // Clear the request flag to avoid showing notification again
          AppState.lastDecelZoneRequest = undefined;
        }
        
        decelZoneInput.value = receivedZone;
        document.getElementById('decelEffectPercent').value = data.decelZone.effectPercent;
        document.getElementById('effectValue').textContent = data.decelZone.effectPercent.toFixed(0) + '%';
        
        // Update select dropdown for mode
        const decelModeSelect = document.getElementById('decelModeSelect');
        if (decelModeSelect) {
          decelModeSelect.value = data.decelZone.mode.toString();
        }
        
        // Update zone preset active state
        document.querySelectorAll('[data-decel-zone]').forEach(btn => {
          const btnValue = parseInt(btn.getAttribute('data-decel-zone'));
          if (btnValue === data.decelZone.zoneMM) {
            btn.classList.add('active');
          } else {
            btn.classList.remove('active');
          }
        });
        
        // Redraw preview if enabled
        if (data.decelZone.enabled) {
          drawDecelPreview();
        }
      }
      
      // Show pending changes indicator
      const pendingChanges = document.getElementById('pendingChanges');
      if (data.hasPending) {
        pendingChanges.style.display = 'block';
        pendingChanges.textContent = '‚è≥ Changements en attente: ' + 
          data.pendingStartPos.toFixed(1) + ' mm ‚Üí ' + 
          (data.pendingStartPos + data.pendingDist).toFixed(1) + ' mm (' +
          data.pendingDist.toFixed(1) + 'mm) @ ' + 
          'Aller: ' + data.pendingMotion.speedLevelForward.toFixed(1) + '/20, ' +
          'Retour: ' + data.pendingMotion.speedLevelBackward.toFixed(1) + '/20 (fin de cycle)';
      } else {
        pendingChanges.style.display = 'none';
      }
      
      // Update oscillation state display
      if (data.oscillation && data.oscillationState) {
        DOM.oscCurrentAmplitude.textContent = 
          data.oscillationState.currentAmplitude.toFixed(2);
        DOM.oscCompletedCycles.textContent = 
          data.oscillationState.completedCycles;
        
        let rampStatus = 'Aucune';
        if (data.oscillationState.isTransitioning) {
          rampStatus = 'üîÑ Transition fr√©quence...';
        } else if (data.oscillationState.isRampingIn) {
          rampStatus = 'üìà Rampe entr√©e';
        } else if (data.oscillationState.isRampingOut) {
          rampStatus = 'üìâ Rampe sortie';
        } else if (data.operationMode === 3 && data.state === SystemState.RUNNING) {  // MODE_OSCILLATION + RUNNING
          rampStatus = '‚úÖ Stabilis√©';
        }
        DOM.oscRampStatus.textContent = rampStatus;
        
        // üîí DISABLE frequency controls during transition (500ms smooth change)
        const isTransitioning = data.oscillationState.isTransitioning || false;
        DOM.oscFrequency.disabled = isTransitioning;
        
        // Apply visual feedback during transition
        if (isTransitioning) {
          DOM.oscFrequency.style.backgroundColor = '#fff3cd';
          DOM.oscFrequency.style.cursor = 'not-allowed';
        } else {
          DOM.oscFrequency.style.backgroundColor = '';
          DOM.oscFrequency.style.cursor = '';
        }
        
        // Also disable preset buttons during transition
        document.querySelectorAll('[data-osc-frequency]').forEach(btn => {
          btn.disabled = isTransitioning;
          btn.style.opacity = isTransitioning ? '0.5' : '1';
          btn.style.cursor = isTransitioning ? 'not-allowed' : 'pointer';
        });
        
        // Sync oscillation config to UI (skip fields being edited OR having focus)
        if (AppState.editing.oscField !== 'oscCenter' && document.activeElement !== DOM.oscCenter) {
          DOM.oscCenter.value = data.oscillation.centerPositionMM.toFixed(1);
        }
        
        if (AppState.editing.oscField !== 'oscAmplitude' && document.activeElement !== DOM.oscAmplitude) {
          DOM.oscAmplitude.value = data.oscillation.amplitudeMM.toFixed(1);
        }
        
        if (AppState.editing.oscField !== 'oscWaveform' && document.activeElement !== DOM.oscWaveform) {
          DOM.oscWaveform.value = data.oscillation.waveform;
        }
        
        if (AppState.editing.oscField !== 'oscFrequency' && document.activeElement !== DOM.oscFrequency && !isTransitioning) {
          // Use effective frequency if available (accounts for speed limiting)
          const displayFreq = data.oscillation.effectiveFrequencyHz || data.oscillation.frequencyHz;
          const isFreqLimited = data.oscillation.effectiveFrequencyHz && 
                                Math.abs(data.oscillation.effectiveFrequencyHz - data.oscillation.frequencyHz) > 0.001;
          
          DOM.oscFrequency.value = displayFreq.toFixed(3);
          
          // Visual feedback if frequency is limited
          if (isFreqLimited) {
            DOM.oscFrequency.style.backgroundColor = '#ffe8e8';
            DOM.oscFrequency.style.fontWeight = 'bold';
            DOM.oscFrequency.style.color = '#d32f2f';
            DOM.oscFrequency.title = `‚ö†Ô∏è Fr√©quence limit√©e de ${data.oscillation.frequencyHz.toFixed(2)} Hz √† ${displayFreq.toFixed(2)} Hz (vitesse max: 300 mm/s)`;
          } else {
            DOM.oscFrequency.style.backgroundColor = '';
            DOM.oscFrequency.style.fontWeight = '';
            DOM.oscFrequency.style.color = '';
            DOM.oscFrequency.title = '';
          }
        }
        
        if (AppState.editing.oscField !== 'oscRampInDuration' && document.activeElement !== DOM.oscRampInDuration) {
          DOM.oscRampInDuration.value = data.oscillation.rampInDurationMs;
        }
        
        if (AppState.editing.oscField !== 'oscRampOutDuration' && document.activeElement !== DOM.oscRampOutDuration) {
          DOM.oscRampOutDuration.value = data.oscillation.rampOutDurationMs;
        }
        
        if (AppState.editing.oscField !== 'oscCycleCount' && document.activeElement !== DOM.oscCycleCount) {
          DOM.oscCycleCount.value = data.oscillation.cycleCount;
        }
        
        // Checkboxes (not edited via focus)
        DOM.oscRampInEnable.checked = data.oscillation.enableRampIn;
        DOM.oscRampOutEnable.checked = data.oscillation.enableRampOut;
        DOM.oscReturnCenter.checked = data.oscillation.returnToCenter;
        
        // Update ramp visibility (removed in compact mode - always visible inline)
        // DOM.oscRampInConfig.style.display = 
        //   data.oscillation.enableRampIn ? 'block' : 'none';
        // DOM.oscRampOutConfig.style.display = 
        //   data.oscillation.enableRampOut ? 'block' : 'none';
        
        // Validate limits (only if not editing center or amplitude)
        if (AppState.editing.oscField !== 'oscCenter' && AppState.editing.oscField !== 'oscAmplitude') {
          validateOscillationLimits();
        }
        
        // Update preset buttons visual state
        updateOscillationPresets();
      }
      
      // Update chaos UI
      updateChaosUI(data);
      
      // Update Pause/Resume buttons for Simple, Oscillation, and Chaos modes
      const isPaused = (data.state === SystemState.PAUSED);
      const isRunningOrPaused = (isRunning || isPaused);
      
      // Simple mode Pause button
      const btnPause = document.getElementById('btnPause');
      if (btnPause) {
        btnPause.disabled = !isRunningOrPaused;
        if (isPaused) {
          btnPause.innerHTML = '‚ñ∂ Reprendre';
        } else {
          btnPause.innerHTML = '‚è∏ Pause';
        }
      }
      
      // Simple mode Stop button
      const btnStop = document.getElementById('btnStop');
      if (btnStop) {
        btnStop.disabled = !isRunningOrPaused;
      }
      
      // Oscillation mode Pause button
      const btnPauseOsc = document.getElementById('btnPauseOscillation');
      if (btnPauseOsc) {
        btnPauseOsc.disabled = !isRunningOrPaused;
        if (isPaused) {
          btnPauseOsc.innerHTML = '‚ñ∂ Reprendre';
        } else {
          btnPauseOsc.innerHTML = '‚è∏ Pause';
        }
      }
      
      // Oscillation mode Stop button
      const btnStopOsc = document.getElementById('btnStopOscillation');
      if (btnStopOsc) {
        btnStopOsc.disabled = !isRunningOrPaused;
      }
      
      // Chaos mode Pause button
      const btnPauseChaos = document.getElementById('btnPauseChaos');
      if (btnPauseChaos) {
        btnPauseChaos.disabled = !isRunningOrPaused;
        if (isPaused) {
          btnPauseChaos.innerHTML = '‚ñ∂ Reprendre';
        } else {
          btnPauseChaos.innerHTML = '‚è∏ Pause';
        }
      }
      
      // Chaos mode Stop button
      const btnStopChaos = document.getElementById('btnStopChaos');
      if (btnStopChaos) {
        btnStopChaos.disabled = !isRunningOrPaused;
      }
      
      // Note: Sequence start buttons are NOT managed here anymore
      // They are controlled ONLY by:
      // 1. User click (immediate disable)
      // 2. Backend sequenceStatus (re-enable when stopped)
      // This prevents flickering/desync issues
      
      // Update system stats
      if (data.system) {
        updateSystemStats(data.system);
      }
    }
    
    function updateSystemStats(system) {
      // CPU frequency
      document.getElementById('sysCpuFreq').textContent = system.cpuFreqMHz + ' MHz';
      
      // Temperature
      const temp = parseFloat(system.temperatureC);
      const tempEl = document.getElementById('sysTemp');
      tempEl.textContent = temp.toFixed(1) + ' ¬∞C';
      // Color coding based on temperature
      if (temp > 80) {
        tempEl.style.color = '#f44336'; // Red - hot
      } else if (temp > 70) {
        tempEl.style.color = '#FF9800'; // Orange - warm
      } else {
        tempEl.style.color = '#333'; // Normal
      }
      
      // RAM
      const ramFreeMB = (system.heapFree / 1024).toFixed(1);
      const ramTotalMB = (system.heapTotal / 1024).toFixed(1);
      const ramUsedPercent = parseFloat(system.heapUsedPercent);
      document.getElementById('sysRam').textContent = ramFreeMB + ' KB libre / ' + ramTotalMB + ' KB';
      document.getElementById('sysRamPercent').textContent = ramUsedPercent.toFixed(1) + '% utilis√©';
      
      // PSRAM
      const psramFreeMB = (system.psramFree / 1024 / 1024).toFixed(1);
      const psramTotalMB = (system.psramTotal / 1024 / 1024).toFixed(1);
      const psramUsedPercent = parseFloat(system.psramUsedPercent);
      document.getElementById('sysPsram').textContent = psramFreeMB + ' MB libre / ' + psramTotalMB + ' MB';
      document.getElementById('sysPsramPercent').textContent = psramUsedPercent.toFixed(1) + '% utilis√©';
      
      // WiFi
      const rssi = system.wifiRssi;
      let quality = 'Inconnu';
      let qualityColor = '#666';
      if (rssi >= -50) {
        quality = 'Excellent';
        qualityColor = '#4CAF50';
      } else if (rssi >= -60) {
        quality = 'Tr√®s bon';
        qualityColor = '#8BC34A';
      } else if (rssi >= -70) {
        quality = 'Bon';
        qualityColor = '#FFC107';
      } else if (rssi >= -80) {
        quality = 'Faible';
        qualityColor = '#FF9800';
      } else {
        quality = 'Tr√®s faible';
        qualityColor = '#f44336';
      }
      document.getElementById('sysWifi').textContent = rssi + ' dBm';
      const qualityEl = document.getElementById('sysWifiQuality');
      qualityEl.textContent = quality;
      qualityEl.style.color = qualityColor;
      
      // Uptime
      const uptimeSec = system.uptimeSeconds;
      const hours = Math.floor(uptimeSec / 3600);
      const minutes = Math.floor((uptimeSec % 3600) / 60);
      const seconds = uptimeSec % 60;
      const uptimeStr = hours > 0 
        ? `${hours}h ${minutes}m ${seconds}s`
        : minutes > 0
          ? `${minutes}m ${seconds}s`
          : `${seconds}s`;
      document.getElementById('sysUptime').textContent = uptimeStr;
    }
    
    // ============================================================================
    // PLAYLIST MANAGEMENT FUNCTIONS
    // ============================================================================
    
    function generatePresetName(mode, config) {
      if (mode === 'simple') {
        return `${config.startPositionMM}‚Üí${config.startPositionMM + config.distanceMM}mm v:${config.speedLevelForward}/${config.speedLevelBackward}`;
      } else if (mode === 'oscillation') {
        const waveNames = ['Sine', 'Triangle', 'Square'];
        return `${waveNames[config.waveform] || 'Sine'} ${config.frequencyHz}Hz ¬±${config.amplitudeMM}mm`;
      } else if (mode === 'chaos') {
        return `Chaos ${config.durationSeconds}s (${config.crazinessPercent}%)`;
      }
      return 'Preset';
    }
    
    function generatePresetTooltip(mode, config) {
      if (mode === 'simple') {
        return `üìç D√©part: ${config.startPositionMM}mm
üìè Distance: ${config.distanceMM}mm
‚û°Ô∏è Vitesse aller: ${config.speedLevelForward}/20
‚¨ÖÔ∏è Vitesse retour: ${config.speedLevelBackward}/20
‚è±Ô∏è Dur√©e estim√©e: ${((config.distanceMM / (config.speedLevelForward * 10)) * 60).toFixed(1)}s`;
      } else if (mode === 'oscillation') {
        const waveNames = ['üåä Sine', 'üìê Triangle', '‚¨ú Carr√©'];
        const ramps = [];
        if (config.enableRampIn) ramps.push('IN');
        if (config.enableRampOut) ramps.push('OUT');
        return `${waveNames[config.waveform] || 'üåä Sine'}
üìç Centre: ${config.centerPositionMM}mm
‚ÜîÔ∏è Amplitude: ¬±${config.amplitudeMM}mm
‚ö° Fr√©quence: ${config.frequencyHz}Hz
üîÑ Cycles: ${config.cycleCount === 0 ? '‚àû' : config.cycleCount}
${ramps.length > 0 ? 'üìà Rampes: ' + ramps.join(', ') : ''}`;
      } else if (mode === 'chaos') {
        const enabledCount = config.patternsEnabled ? config.patternsEnabled.filter(p => p).length : 11;
        return `üìç Centre: ${config.centerPositionMM}mm
‚ÜîÔ∏è Amplitude: ¬±${config.amplitudeMM}mm
‚ö° Vitesse max: ${config.maxSpeedLevel}/20
üé≤ Folie: ${config.crazinessPercent}%
‚è±Ô∏è Dur√©e: ${config.durationSeconds === 0 ? '‚àû' : config.durationSeconds + 's'}
üé≠ Patterns: ${enabledCount}/11 actifs`;
      }
      return 'Preset';
    }
    
    /**
     * Generate tooltip content for sequence line
     */
    function generateSequenceLineTooltip(line) {
      const movementType = line.movementType !== undefined ? line.movementType : 0;
      
      if (movementType === 0) {
        // VA-ET-VIENT
        const decelInfo = [];
        if (line.decelStartEnabled) decelInfo.push('D√©part');
        if (line.decelEndEnabled) decelInfo.push('Fin');
        const decelModes = ['Lin√©aire', 'Sinuso√Ødal', 'Triangle‚Åª¬π', 'Sine‚Åª¬π'];
        
        return `üîÑ VA-ET-VIENT
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üìç D√©part: ${line.startPositionMM}mm
üìè Distance: ${line.distanceMM}mm
‚û°Ô∏è Vitesse aller: ${line.speedForward.toFixed(1)}/20
‚¨ÖÔ∏è Vitesse retour: ${line.speedBackward.toFixed(1)}/20
${decelInfo.length > 0 ? 'üõë D√©cel: ' + decelInfo.join(' + ') + ' (' + line.decelZoneMM + 'mm, ' + line.decelEffectPercent + '%, ' + decelModes[line.decelMode] + ')' : 'üõë D√©cel: Aucune'}
üîÑ Cycles: ${line.cycleCount}
‚è±Ô∏è Pause apr√®s: ${line.pauseAfterMs > 0 ? (line.pauseAfterMs / 1000).toFixed(1) + 's' : 'Aucune'}`;
      } else if (movementType === 1) {
        // OSCILLATION
        const waveNames = ['üåä Sine', 'üìê Triangle', '‚¨ú Carr√©'];
        const ramps = [];
        if (line.oscEnableRampIn) ramps.push('IN (' + line.oscRampInDurationMs + 'ms)');
        if (line.oscEnableRampOut) ramps.push('OUT (' + line.oscRampOutDurationMs + 'ms)');
        
        const peakSpeed = (2 * Math.PI * line.oscFrequencyHz * line.oscAmplitudeMM).toFixed(1);
        
        return `„Ä∞Ô∏è OSCILLATION
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
${waveNames[line.oscWaveform] || 'üåä Sine'}
üìç Centre: ${line.oscCenterPositionMM}mm
‚ÜîÔ∏è Amplitude: ¬±${line.oscAmplitudeMM}mm
‚ö° Fr√©quence: ${line.oscFrequencyHz}Hz
‚ö° Vitesse pic: ${peakSpeed}mm/s
üîÑ Cycles: ${line.cycleCount}
${ramps.length > 0 ? 'üìà Rampes: ' + ramps.join(' + ') : 'üìà Rampes: Aucune'}
‚è±Ô∏è Pause apr√®s: ${line.pauseAfterMs > 0 ? (line.pauseAfterMs / 1000).toFixed(1) + 's' : 'Aucune'}`;
      } else if (movementType === 2) {
        // CHAOS
        const enabledCount = line.chaosPatternsEnabled ? line.chaosPatternsEnabled.filter(p => p).length : 11;
        
        return `üåÄ CHAOS
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üìç Centre: ${line.chaosCenterPositionMM}mm
‚ÜîÔ∏è Amplitude: ¬±${line.chaosAmplitudeMM}mm
‚ö° Vitesse max: ${line.chaosMaxSpeedLevel.toFixed(1)}/20
üé≤ Folie: ${line.chaosCrazinessPercent}%
‚è±Ô∏è Dur√©e: ${line.chaosDurationSeconds}s
üå± Seed: ${line.chaosSeed}
üé≠ Patterns: ${enabledCount}/11 actifs
‚è±Ô∏è Pause apr√®s: ${line.pauseAfterMs > 0 ? (line.pauseAfterMs / 1000).toFixed(1) + 's' : 'Aucune'}`;
      } else if (movementType === 4) {
        // CALIBRATION
        return `üìè CALIBRATION
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
Recalibration compl√®te du syst√®me
R√©initialise la position √† 0mm
D√©tecte la limite physique`;
      }
      
      return 'Ligne de s√©quence';
    }
    
    function getCurrentModeConfig(mode) {
      if (mode === 'simple') {
        return {
          startPositionMM: parseFloat(document.getElementById('startPosition').value) || 0,
          distanceMM: parseFloat(document.getElementById('distance').value) || 50,
          speedLevelForward: parseFloat(document.getElementById('speedForward')?.value || document.getElementById('speedUnified').value) || 5,
          speedLevelBackward: parseFloat(document.getElementById('speedBackward')?.value || document.getElementById('speedUnified').value) || 5
        };
      } else if (mode === 'oscillation') {
        return {
          centerPositionMM: parseFloat(document.getElementById('oscCenter').value) || 100,
          amplitudeMM: parseFloat(document.getElementById('oscAmplitude').value) || 20,
          waveform: parseInt(document.getElementById('oscWaveform').value) || 0,
          frequencyHz: parseFloat(document.getElementById('oscFrequency').value) || 1.0,
          cycleCount: parseInt(document.getElementById('oscCycleCount').value) || 10,
          enableRampIn: document.getElementById('oscRampInEnable').checked,
          rampInDurationMs: parseInt(document.getElementById('oscRampInDuration').value) || 2000,
          enableRampOut: document.getElementById('oscRampOutEnable').checked,
          rampOutDurationMs: parseInt(document.getElementById('oscRampOutDuration').value) || 2000,
          returnToCenter: document.getElementById('oscReturnCenter').checked
        };
      } else if (mode === 'chaos') {
        const patterns = [
          document.getElementById('patternZigzag').checked,
          document.getElementById('patternSweep').checked,
          document.getElementById('patternPulse').checked,
          document.getElementById('patternDrift').checked,
          document.getElementById('patternBurst').checked,
          document.getElementById('patternWave').checked,
          document.getElementById('patternPendulum').checked,
          document.getElementById('patternSpiral').checked,
          document.getElementById('patternCalm').checked,
          document.getElementById('patternBruteForce').checked,
          document.getElementById('patternLiberator').checked
        ];
        return {
          centerPositionMM: parseFloat(document.getElementById('chaosCenterPos').value) || 100,
          amplitudeMM: parseFloat(document.getElementById('chaosAmplitude').value) || 40,
          maxSpeedLevel: parseFloat(document.getElementById('chaosMaxSpeed').value) || 15,
          crazinessPercent: parseInt(document.getElementById('chaosCraziness').value) || 50,
          durationSeconds: parseInt(document.getElementById('chaosDuration').value) || 30,
          patternsEnabled: patterns
        };
      }
      return {};
    }
    
    function openPlaylistModal(mode) {
      const modal = document.getElementById('playlistModal');
      const titleEl = document.getElementById('playlistModalTitle');
      const configEl = document.getElementById('playlistCurrentConfigContent');
      
      modal.dataset.mode = mode;
      
      if (mode === 'simple') {
        titleEl.textContent = 'Mode Simple';
      } else if (mode === 'oscillation') {
        titleEl.textContent = 'Mode Oscillation';
      } else if (mode === 'chaos') {
        titleEl.textContent = 'Mode Chaos';
      }
      
      // Display current config
      const config = getCurrentModeConfig(mode);
      let configHTML = '';
      
      if (mode === 'simple') {
        configHTML = `
          ‚Ä¢ D√©part: ${config.startPositionMM} mm<br>
          ‚Ä¢ Distance: ${config.distanceMM} mm<br>
          ‚Ä¢ Vitesse aller: ${config.speedLevelForward}<br>
          ‚Ä¢ Vitesse retour: ${config.speedLevelBackward}
        `;
      } else if (mode === 'oscillation') {
        const waveNames = ['Sine', 'Triangle', 'Square'];
        configHTML = `
          ‚Ä¢ Centre: ${config.centerPositionMM} mm<br>
          ‚Ä¢ Amplitude: ¬±${config.amplitudeMM} mm<br>
          ‚Ä¢ Forme: ${waveNames[config.waveform]}<br>
          ‚Ä¢ Fr√©quence: ${config.frequencyHz} Hz<br>
          ‚Ä¢ Cycles: ${config.cycleCount === 0 ? '‚àû (infini)' : config.cycleCount}
        `;
      } else if (mode === 'chaos') {
        const enabledCount = config.patternsEnabled.filter(p => p).length;
        configHTML = `
          ‚Ä¢ Centre: ${config.centerPositionMM} mm<br>
          ‚Ä¢ Amplitude: ¬±${config.amplitudeMM} mm<br>
          ‚Ä¢ Vitesse max: ${config.maxSpeedLevel}<br>
          ‚Ä¢ Craziness: ${config.crazinessPercent}%<br>
          ‚Ä¢ Dur√©e: ${config.durationSeconds === 0 ? '‚àû (infini)' : config.durationSeconds + 's'}<br>
          ‚Ä¢ Patterns actifs: ${enabledCount}/11
        `;
      }
      
      configEl.innerHTML = configHTML;
      
      // Refresh presets list
      refreshPlaylistPresets(mode);
      
      modal.classList.add('active');
    }
    
    function closePlaylistModal() {
      document.getElementById('playlistModal').classList.remove('active');
    }
    
    function closePlaylistModalOnOverlayClick(event) {
      // Only close if clicking on the overlay itself (not the content)
      if (event.target.id === 'playlistModal') {
        closePlaylistModal();
      }
    }
    
    function refreshPlaylistPresets(mode) {
      const listEl = document.getElementById('playlistPresetsList');
      const countEl = document.getElementById('playlistCount');
      const presets = PlaylistState[mode] || [];
      
      console.log('üîÑ refreshPlaylistPresets called for mode:', mode, 'presets count:', presets.length);
      
      countEl.textContent = presets.length;
      
      if (presets.length === 0) {
        console.log('‚ö†Ô∏è No presets found, displaying empty message');
        listEl.innerHTML = '<div style="color: #999; font-style: italic; padding: 20px; text-align: center;">Aucun preset sauvegard√©</div>';
        return;
      }
      
      // Sort by timestamp desc (most recent first)
      const sortedPresets = [...presets].sort((a, b) => b.timestamp - a.timestamp);
      
      console.log('‚úÖ Building HTML for', sortedPresets.length, 'presets');
      
      let html = '';
      sortedPresets.forEach(preset => {
        const tooltipContent = generatePresetTooltip(mode, preset.config);
        html += `
          <div class="preset-item" 
               data-tooltip="${tooltipContent.replace(/"/g, '&quot;')}"
               style="background: #f9f9f9; padding: 8px 10px; border-radius: 4px; margin-bottom: 6px; border: 1px solid #ddd;">
            <div style="display: flex; justify-content: space-between; align-items: center; gap: 6px;">
              <div style="flex: 1; min-width: 0;">
                <div style="font-weight: 500; font-size: 12px; margin-bottom: 2px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${preset.name}</div>
                <div style="font-size: 10px; color: #888;">${new Date(preset.timestamp * 1000).toLocaleString('fr-FR', {dateStyle: 'short', timeStyle: 'short'})}</div>
              </div>
              <div style="display: flex; gap: 2px; flex-shrink: 0;">
                <button onclick="loadPresetInMode('${mode}', ${preset.id})" style="padding: 4px 6px; font-size: 11px; min-width: unset;" title="Charger dans le mode actuel">
                  ‚¨áÔ∏è
                </button>
                <button onclick="quickAddToSequencer('${mode}', ${preset.id})" style="padding: 4px 6px; font-size: 11px; min-width: unset;" title="Ajouter direct au s√©quenceur">
                  ‚ûïüìã
                </button>
                <button onclick="renamePlaylistPreset('${mode}', ${preset.id})" style="padding: 4px 6px; font-size: 11px; min-width: unset;" title="Renommer">
                  ‚úèÔ∏è
                </button>
                <button onclick="deleteFromPlaylist('${mode}', ${preset.id})" style="padding: 4px 6px; font-size: 11px; min-width: unset;" title="Supprimer">
                  üóëÔ∏è
                </button>
                <button class="preset-tooltip-eye" data-preset-id="${preset.id}"
                  style="display: inline-block; padding: 4px 6px; cursor: pointer; font-size: 14px;"
                  title="Voir d√©tails">üëÅÔ∏è</button>
              </div>
            </div>
          </div>
        `;
      });
      
      console.log('‚úÖ Setting HTML, length:', html.length);
      listEl.innerHTML = html;
      
      // Attach eye icon tooltip handlers after DOM insertion
      setTimeout(() => {
        document.querySelectorAll('.preset-tooltip-eye').forEach(eyeIcon => {
          eyeIcon.onmouseenter = function(e) {
            const presetItem = this.closest('.preset-item');
            if (presetItem) {
              showPlaylistTooltip(presetItem);
            }
          };
          eyeIcon.onmouseleave = function() {
            hidePlaylistTooltip();
          };
        });
      }, 0);
    }
    
    function showPlaylistTooltip(element) {
      const tooltipContent = element.getAttribute('data-tooltip');
      const overlay = document.getElementById('playlistTooltipOverlay');
      if (overlay && tooltipContent) {
        overlay.innerHTML = tooltipContent;
        overlay.classList.add('visible');
      }
    }
    
    function hidePlaylistTooltip() {
      const overlay = document.getElementById('playlistTooltipOverlay');
      if (overlay) {
        overlay.classList.remove('visible');
      }
    }
    
    /**
     * Show sequence line tooltip
     */
    function showSequenceTooltip(element) {
      const tooltipContent = element.getAttribute('data-tooltip');
      const lineNumber = element.getAttribute('data-line-number');
      const lineType = element.getAttribute('data-line-type');
      
      const overlay = document.getElementById('playlistTooltipOverlay');
      if (overlay && tooltipContent) {
        const header = `<div style="font-weight: 600; margin-bottom: 8px; font-size: 14px; border-bottom: 2px solid rgba(255,255,255,0.3); padding-bottom: 6px;">#${lineNumber} - ${lineType}</div>`;
        overlay.innerHTML = header + tooltipContent;
        overlay.classList.add('visible');
      }
    }
    
    function filterPlaylistPresets(searchTerm) {
      const items = document.querySelectorAll('.preset-item');
      const term = (searchTerm || '').toLowerCase().trim();
      let visibleCount = 0;
      
      items.forEach(item => {
        // Search in preset name
        const nameEl = item.querySelector('div > div:first-child');
        const name = nameEl ? nameEl.textContent.toLowerCase() : '';
        const visible = term === '' || name.includes(term);
        
        item.style.display = visible ? 'block' : 'none';
        if (visible) visibleCount++;
      });
      
      // Update count display
      const countEl = document.getElementById('playlistCount');
      if (countEl) {
        countEl.textContent = visibleCount;
      }
      
      console.log('üîç Search:', term, '‚Üí', visibleCount, 'results');
    }
    
    function addToPlaylist(mode) {
      const config = getCurrentModeConfig(mode);
      
      // Validation: refuse infinite durations
      if (mode === 'oscillation' && config.cycleCount === 0) {
        showNotification('‚ùå Impossible d\'ajouter: cycles infinis non support√©s dans la playlist', 'error', 5000);
        return;
      }
      if (mode === 'chaos' && config.durationSeconds === 0) {
        showNotification('‚ùå Impossible d\'ajouter: dur√©e infinie non support√©e dans la playlist', 'error', 5000);
        return;
      }
      
      // Check limit
      if (PlaylistState[mode].length >= 20) {
        showNotification('‚ùå Limite atteinte: maximum 20 presets par mode', 'error', 4000);
        return;
      }
      
      // Generate default name
      const defaultName = generatePresetName(mode, config);
      const name = prompt('Nom du preset:', defaultName);
      if (!name) return;
      
      // Send to backend
      fetch('/api/playlists/add', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({
          mode: mode,
          name: name,
          config: config
        })
      })
      .then(r => r.json())
      .then(data => {
        if (data.success) {
          showNotification('‚úÖ Preset ajout√© √† la playlist', 'success', 3000);
          console.log('‚úÖ Preset added, reloading playlists...');
          // Reload playlists, then refresh modal display
          loadPlaylists(() => {
            console.log('‚úÖ Playlists reloaded, refreshing modal for mode:', mode);
            refreshPlaylistPresets(mode);
          });
        } else {
          showNotification('‚ùå Erreur: ' + (data.error || 'Unknown'), 'error');
        }
      })
      .catch(error => {
        showNotification('‚ùå Erreur r√©seau: ' + error, 'error');
      });
    }
    
    function deleteFromPlaylist(mode, id) {
      if (!confirm('Supprimer ce preset de la playlist?')) return;
      
      fetch('/api/playlists/delete', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({
          mode: mode,
          id: id
        })
      })
      .then(r => r.json())
      .then(data => {
        if (data.success) {
          showNotification('‚úÖ Preset supprim√©', 'success', 2000);
          // Reload playlists, then refresh modal display
          loadPlaylists(() => refreshPlaylistPresets(mode));
        } else {
          showNotification('‚ùå Erreur: ' + (data.error || 'Unknown'), 'error');
        }
      })
      .catch(error => {
        showNotification('‚ùå Erreur r√©seau: ' + error, 'error');
      });
    }
    
    function renamePlaylistPreset(mode, id) {
      const preset = PlaylistState[mode].find(p => p.id === id);
      if (!preset) return;
      
      const newName = prompt('Nouveau nom:', preset.name);
      if (!newName || newName === preset.name) return;
      
      fetch('/api/playlists/update', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({
          mode: mode,
          id: id,
          name: newName
        })
      })
      .then(r => r.json())
      .then(data => {
        if (data.success) {
          showNotification('‚úÖ Preset renomm√©', 'success', 2000);
          // Reload playlists, then refresh modal display
          loadPlaylists(() => refreshPlaylistPresets(mode));
        } else {
          showNotification('‚ùå Erreur: ' + (data.error || 'Unknown'), 'error');
        }
      })
      .catch(error => {
        showNotification('‚ùå Erreur r√©seau: ' + error, 'error');
      });
    }
    
    function loadPresetInMode(mode, id) {
      const preset = PlaylistState[mode].find(p => p.id === id);
      if (!preset) {
        console.error('‚ùå Preset not found:', mode, id);
        return;
      }
      
      const config = preset.config;
      
      if (mode === 'simple') {
        document.getElementById('startPosition').value = config.startPositionMM || 0;
        document.getElementById('distance').value = config.distanceMM || 50;
        
        // Check if unified or separate speed mode
        const isSeparate = document.getElementById('speedModeSeparate').checked;
        if (isSeparate) {
          document.getElementById('speedForward').value = config.speedLevelForward || 5;
          document.getElementById('speedBackward').value = config.speedLevelBackward || 5;
        } else {
          document.getElementById('speedUnified').value = config.speedLevelForward || 5;
        }
        
        // Send commands to backend
        sendCommand('setStartPosition', {startPosition: config.startPositionMM || 0});
        sendCommand('setDistance', {distance: config.distanceMM || 50});
        sendCommand('setSpeedForward', {speed: config.speedLevelForward || 5});
        sendCommand('setSpeedBackward', {speed: config.speedLevelBackward || 5});
      } else if (mode === 'oscillation') {
        document.getElementById('oscCenter').value = config.centerPositionMM || 100;
        document.getElementById('oscAmplitude').value = config.amplitudeMM || 20;
        document.getElementById('oscWaveform').value = config.waveform || 0;
        document.getElementById('oscFrequency').value = config.frequencyHz || 1.0;
        document.getElementById('oscCycleCount').value = config.cycleCount || 10;
        document.getElementById('oscRampInEnable').checked = config.enableRampIn || false;
        document.getElementById('oscRampInDuration').value = config.rampInDurationMs || 2000;
        document.getElementById('oscRampOutEnable').checked = config.enableRampOut || false;
        document.getElementById('oscRampOutDuration').value = config.rampOutDurationMs || 2000;
        document.getElementById('oscReturnCenter').checked = config.returnToCenter || false;
        
        // Send command to backend
        sendCommand('setOscillation', config);
      } else if (mode === 'chaos') {
        document.getElementById('chaosCenterPos').value = config.centerPositionMM || 100;
        document.getElementById('chaosAmplitude').value = config.amplitudeMM || 40;
        document.getElementById('chaosMaxSpeed').value = config.maxSpeedLevel || 15;
        document.getElementById('chaosCraziness').value = config.crazinessPercent || 50;
        document.getElementById('chaosDuration').value = config.durationSeconds || 30;
        document.getElementById('crazinessValue').textContent = config.crazinessPercent || 50;

        // Set pattern checkboxes (correct IDs)
        if (config.patternsEnabled && Array.isArray(config.patternsEnabled) && config.patternsEnabled.length >= 11) {
          document.getElementById('patternZigzag').checked = config.patternsEnabled[0];
          document.getElementById('patternSweep').checked = config.patternsEnabled[1];
          document.getElementById('patternPulse').checked = config.patternsEnabled[2];
          document.getElementById('patternDrift').checked = config.patternsEnabled[3];
          document.getElementById('patternBurst').checked = config.patternsEnabled[4];
          document.getElementById('patternWave').checked = config.patternsEnabled[5];
          document.getElementById('patternPendulum').checked = config.patternsEnabled[6];
          document.getElementById('patternSpiral').checked = config.patternsEnabled[7];
          document.getElementById('patternCalm').checked = config.patternsEnabled[8];
          document.getElementById('patternBruteForce').checked = config.patternsEnabled[9];
          document.getElementById('patternLiberator').checked = config.patternsEnabled[10];
        }
        
        // Send command to backend
        sendCommand('setChaosConfig', {
          centerPositionMM: config.centerPositionMM || 100,
          amplitudeMM: config.amplitudeMM || 40,
          maxSpeedLevel: config.maxSpeedLevel || 15,
          crazinessPercent: config.crazinessPercent || 50,
          durationSeconds: config.durationSeconds || 30,
          seed: 0,  // Use default seed
          patternsEnabled: config.patternsEnabled || []
        });
      }
      
      closePlaylistModal();
      showNotification('‚úÖ Preset charg√© dans le mode ' + mode, 'info', 2000);
    }
    
    function updateStartPresets(maxDist) {
      // Use cached NodeList for performance (called ~50 times/second via updateUI)
      DOM.presetStartButtons.forEach(btn => {
        const startPos = parseFloat(btn.getAttribute('data-start'));
        const isValid = startPos <= maxDist;
        btn.disabled = !isValid;
        btn.style.opacity = isValid ? '1' : '0.3';
        btn.style.cursor = isValid ? 'pointer' : 'not-allowed';
      });
    }
    
    function updateDistancePresets(maxAvailable) {
      // Use cached NodeList for performance (called ~50 times/second via updateUI)
      DOM.presetDistanceButtons.forEach(btn => {
        const distance = parseFloat(btn.getAttribute('data-distance'));
        const isValid = distance <= maxAvailable;
        btn.disabled = !isValid;
        btn.style.opacity = isValid ? '1' : '0.3';
        btn.style.cursor = isValid ? 'pointer' : 'not-allowed';
      });
    }
    
    // UTILITY FUNCTIONS - Button State Management
    // ========================================================================
    
    /**
     * Check if system can start a new operation
     * Centralized validation logic to avoid code duplication
     * @returns {boolean} True if system is ready to start (calibrated and not calibrating)
     */
    function canStartOperation() {
      return AppState.system.canStart && 
             AppState.system.currentState !== SystemState.CALIBRATING;
    }
    
    /**
     * Uniformly set button enabled/disabled state with visual feedback
     * @param {HTMLElement} button - The button element to update
     * @param {boolean} enabled - Whether the button should be enabled
     */
    function setButtonState(button, enabled) {
      if (!button) return;
      button.disabled = !enabled;
      button.style.opacity = enabled ? '1' : '0.5';
      button.style.cursor = enabled ? 'pointer' : 'not-allowed';
    }
    
    function sendCommand(cmd, params = {}) {
      if (AppState.ws && AppState.ws.readyState === WebSocket.OPEN) {
        const message = JSON.stringify({cmd: cmd, ...params});
        AppState.ws.send(message);
      } else {
        console.warn('Cannot send command:', cmd, '- WebSocket not connected (retrying...)');
      }
    }
    
    document.getElementById('btnCalibrateCommon').addEventListener('click', function() {
      sendCommand('calibrate');
    });
    
    // ============================================================================
    // MAX DISTANCE LIMIT CONFIGURATION
    // ============================================================================
    
    // Max Distance Limit: Helper function to update UI state
    function updateMaxDistLimitUI() {
      const isReady = AppState.system.currentState === SystemState.READY;
      const totalMM = AppState.pursuit.totalDistanceMM || 0;
      
      // Get current limit percent from AppState (or default to 100)
      const currentPercent = AppState.pursuit.maxDistLimitPercent || 100;
      
      // Only update slider value if user is NOT currently editing it
      if (!isEditingMaxDistLimit) {
        DOM.maxDistLimitSlider.value = currentPercent;
      }
      
      // Enable/disable controls based on state
      DOM.maxDistLimitSlider.disabled = !isReady;
      DOM.btnApplyMaxDistLimit.disabled = !isReady;
      
      // Show/hide warning
      DOM.maxDistLimitWarning.style.display = isReady ? 'none' : 'block';
      
      // Update slider value and display (only if not editing)
      if (!isEditingMaxDistLimit) {
        const effectiveMM = (totalMM * currentPercent / 100).toFixed(1);
        DOM.maxDistLimitValue.textContent = currentPercent + '%';
        DOM.maxDistLimitMM.textContent = '(' + effectiveMM + ' mm)';
      }
    }
    
    // Max Distance Limit: Initialize event listeners (called after initDOMCache)
    function initMaxDistLimitListeners() {
      // Toggle configuration panel
      DOM.btnConfigMaxDist.addEventListener('click', function() {
        const isVisible = DOM.maxDistConfigPanel.style.display !== 'none';
        DOM.maxDistConfigPanel.style.display = isVisible ? 'none' : 'block';
        
        if (!isVisible) {
          // Panel just opened - load current value and START blocking updates
          isEditingMaxDistLimit = true; // Block updates while panel is open
          updateMaxDistLimitUI();
        } else {
          // Panel closed - stop blocking updates
          isEditingMaxDistLimit = false;
        }
      });
      
      // Update slider display while dragging
      DOM.maxDistLimitSlider.addEventListener('input', function() {
        const percent = parseFloat(this.value);
        const totalMM = AppState.pursuit.totalDistanceMM || 0;
        const effectiveMM = (totalMM * percent / 100).toFixed(1);
        
        DOM.maxDistLimitValue.textContent = percent + '%';
        DOM.maxDistLimitMM.textContent = '(' + effectiveMM + ' mm)';
      });
      
      // Apply limit
      DOM.btnApplyMaxDistLimit.addEventListener('click', function() {
        const percent = parseFloat(DOM.maxDistLimitSlider.value);
        
        // Reset input fields to safe defaults when applying limit
        document.getElementById('startPosition').value = 0;
        document.getElementById('distance').value = 0;
        
        // Update oscillation and chaos centers with new effective max
        const totalMM = AppState.pursuit.totalDistanceMM || 0;
        const effectiveMax = totalMM * percent / 100;
        
        const oscCenterField = document.getElementById('oscCenter');
        if (oscCenterField && effectiveMax > 0) {
          oscCenterField.value = (effectiveMax / 2).toFixed(1);
          // Send to backend to update oscillation config
          sendCommand('setOscillationConfig', {
            centerPositionMM: effectiveMax / 2,
            amplitudeMM: parseFloat(document.getElementById('oscAmplitude').value) || 50,
            frequencyHz: parseFloat(document.getElementById('oscFrequency').value) || 1,
            waveform: parseInt(document.getElementById('oscWaveform').value) || 0
          });
        }
        
        const chaosCenterField = document.getElementById('chaosCenterPos');
        if (chaosCenterField && effectiveMax > 0) {
          chaosCenterField.value = (effectiveMax / 2).toFixed(1);
        }
        
        sendCommand('setMaxDistanceLimit', {percent: percent});
        DOM.maxDistConfigPanel.style.display = 'none';
        isEditingMaxDistLimit = false; // Allow updates after applying
      });
      
      // Cancel
      DOM.btnCancelMaxDistLimit.addEventListener('click', function() {
        DOM.maxDistConfigPanel.style.display = 'none';
        isEditingMaxDistLimit = false; // Allow updates after cancelling
      });
    }
    
    document.getElementById('btnStart').addEventListener('click', function() {
      const distance = parseFloat(document.getElementById('distance').value);
      const isSeparateMode = document.getElementById('speedModeSeparate')?.checked || false;
      
      let speedForward, speedBackward;
      if (isSeparateMode) {
        speedForward = parseFloat(document.getElementById('speedForward').value);
        speedBackward = parseFloat(document.getElementById('speedBackward').value);
      } else {
        const unifiedSpeed = parseFloat(document.getElementById('speedUnified').value);
        speedForward = unifiedSpeed;
        speedBackward = unifiedSpeed;
      }
      
      sendCommand('start', {distance: distance, speed: speedForward});
      // Set backward speed separately after start
      setTimeout(() => {
        sendCommand('setSpeedBackward', {speed: speedBackward});
      }, 100);
    });
    
    document.getElementById('btnPause').addEventListener('click', function() {
      sendCommand('pause');
    });
    
    document.getElementById('btnStop').addEventListener('click', function() {
      // Only show modal if motor has moved (currentStep > 0)
      if (currentPositionMM > 0.5) {
        showStopModal();
      } else {
        // Direct stop if at position 0
        sendCommand('stop');
      }
    });
    
    document.getElementById('btnResetDistanceCommon').addEventListener('click', function() {
      if (confirm('R√©initialiser le compteur de distance parcourue ?')) {
        sendCommand('resetTotalDistance');
      }
    });
    
    // ========================================================================
    // PLAYLIST BUTTON EVENT LISTENERS
    // ========================================================================
    
    document.getElementById('btnManagePlaylistSimple').addEventListener('click', function() {
      openPlaylistModal('simple');
    });
    
    document.getElementById('btnManagePlaylistOscillation').addEventListener('click', function() {
      openPlaylistModal('oscillation');
    });
    
    document.getElementById('btnManagePlaylistChaos').addEventListener('click', function() {
      openPlaylistModal('chaos');
    });
    
    document.getElementById('btnAddCurrentToPlaylist').addEventListener('click', function() {
      const mode = document.getElementById('playlistModal').dataset.mode;
      if (mode) {
        addToPlaylist(mode);
      }
    });
    
    // Track when user starts editing an input
    // Use mousedown to catch spinner clicks BEFORE focus + force focus immediately
    document.getElementById('startPosition').addEventListener('mousedown', function() {
      AppState.editing.input = 'startPosition';
      this.focus();
    });
    document.getElementById('startPosition').addEventListener('focus', function() {
      AppState.editing.input = 'startPosition';
    });
    document.getElementById('startPosition').addEventListener('blur', function() {
      AppState.editing.input = null;
    });
    document.getElementById('startPosition').addEventListener('change', function() {
      const startPos = parseFloat(this.value);
      sendCommand('setStartPosition', {startPosition: startPos});
      AppState.editing.input = null;
    });
    
    document.getElementById('distance').addEventListener('mousedown', function() {
      AppState.editing.input = 'distance';
      this.focus();
    });
    document.getElementById('distance').addEventListener('focus', function() {
      AppState.editing.input = 'distance';
    });
    document.getElementById('distance').addEventListener('blur', function() {
      AppState.editing.input = null;
    });
    document.getElementById('distance').addEventListener('change', function() {
      const distance = parseFloat(this.value);
      sendCommand('setDistance', {distance: distance});
      AppState.editing.input = null;
    });
    
    // Unified speed control
    document.getElementById('speedUnified').addEventListener('mousedown', function() {
      AppState.editing.input = 'speedUnified';
      this.focus();
    });
    document.getElementById('speedUnified').addEventListener('focus', function() {
      AppState.editing.input = 'speedUnified';
    });
    document.getElementById('speedUnified').addEventListener('blur', function() {
      AppState.editing.input = null;
    });
    document.getElementById('speedUnified').addEventListener('change', function() {
      const speed = parseFloat(this.value);
      
      // Update hidden separate fields for consistency
      document.getElementById('speedForward').value = speed;
      document.getElementById('speedBackward').value = speed;
      
      // Send both commands to ESP32
      sendCommand('setSpeedForward', {speed: speed});
      sendCommand('setSpeedBackward', {speed: speed});
      
      AppState.editing.input = null;
    });
    
    // Separate speed controls
    document.getElementById('speedForward').addEventListener('mousedown', function() {
      AppState.editing.input = 'speedForward';
      this.focus();
    });
    document.getElementById('speedForward').addEventListener('focus', function() {
      AppState.editing.input = 'speedForward';
    });
    document.getElementById('speedForward').addEventListener('blur', function() {
      AppState.editing.input = null;
    });
    document.getElementById('speedForward').addEventListener('change', function() {
      const speed = parseFloat(this.value);
      sendCommand('setSpeedForward', {speed: speed});
      AppState.editing.input = null;
    });
    
    document.getElementById('speedBackward').addEventListener('mousedown', function() {
      AppState.editing.input = 'speedBackward';
      this.focus();
    });
    document.getElementById('speedBackward').addEventListener('focus', function() {
      AppState.editing.input = 'speedBackward';
    });
    document.getElementById('speedBackward').addEventListener('blur', function() {
      AppState.editing.input = null;
    });
    document.getElementById('speedBackward').addEventListener('change', function() {
      const speed = parseFloat(this.value);
      sendCommand('setSpeedBackward', {speed: speed});
      AppState.editing.input = null;
    });
    
    document.querySelectorAll('[data-start]').forEach(btn => {
      btn.addEventListener('click', function() {
        const startPos = parseFloat(this.getAttribute('data-start'));
        const maxStart = parseFloat(document.getElementById('startPosition').max);
        
        if (startPos <= maxStart) {
          document.getElementById('startPosition').value = startPos;
          sendCommand('setStartPosition', {startPosition: startPos});
          
          document.querySelectorAll('[data-start]').forEach(b => b.classList.remove('active'));
          this.classList.add('active');
        }
      });
    });
    
    document.querySelectorAll('[data-distance]').forEach(btn => {
      btn.addEventListener('click', function() {
        const distance = parseFloat(this.getAttribute('data-distance'));
        const maxDist = parseFloat(document.getElementById('distance').max);
        
        if (distance <= maxDist) {
          document.getElementById('distance').value = distance;
          sendCommand('setDistance', {distance: distance});
          
          document.querySelectorAll('[data-distance]').forEach(b => b.classList.remove('active'));
          this.classList.add('active');
        }
      });
    });
    
    // Unified speed presets
    document.querySelectorAll('[data-speed-unified]').forEach(btn => {
      btn.addEventListener('click', function() {
        const speed = parseFloat(this.getAttribute('data-speed-unified'));
        
        // Update visible unified field
        document.getElementById('speedUnified').value = speed;
        
        // Also update hidden separate fields for consistency when switching modes
        document.getElementById('speedForward').value = speed;
        document.getElementById('speedBackward').value = speed;
        
        // Send both commands to ESP32
        sendCommand('setSpeedForward', {speed: speed});
        sendCommand('setSpeedBackward', {speed: speed});
        
        // Update preset button highlighting
        document.querySelectorAll('[data-speed-unified]').forEach(b => b.classList.remove('active'));
        this.classList.add('active');
      });
    });
    
    // Separate speed presets
    document.querySelectorAll('[data-speed-forward]').forEach(btn => {
      btn.addEventListener('click', function() {
        const speed = parseFloat(this.getAttribute('data-speed-forward'));
        document.getElementById('speedForward').value = speed;
        sendCommand('setSpeedForward', {speed: speed});
        
        document.querySelectorAll('[data-speed-forward]').forEach(b => b.classList.remove('active'));
        this.classList.add('active');
      });
    });
    
    document.querySelectorAll('[data-speed-backward]').forEach(btn => {
      btn.addEventListener('click', function() {
        const speed = parseFloat(this.getAttribute('data-speed-backward'));
        document.getElementById('speedBackward').value = speed;
        sendCommand('setSpeedBackward', {speed: speed});
        
        document.querySelectorAll('[data-speed-backward]').forEach(b => b.classList.remove('active'));
        this.classList.add('active');
      });
    });
    
    // Toggle between unified and separate speed controls (RADIO BUTTONS)
    document.querySelectorAll('input[name="speedMode"]').forEach(radio => {
      radio.addEventListener('change', function() {
        const isSeparate = document.getElementById('speedModeSeparate').checked;
        const unifiedGroup = document.getElementById('speedUnifiedGroup');
        const separateGroup = document.getElementById('speedSeparateGroup');
      
      if (isSeparate) {
        // UNIFIED ‚Üí SEPARATE: Copy unified value to BOTH forward AND backward
        unifiedGroup.style.display = 'none';
        separateGroup.style.display = 'block';
        
        const unifiedSpeed = parseFloat(document.getElementById('speedUnified').value);
        document.getElementById('speedForward').value = unifiedSpeed;
        document.getElementById('speedBackward').value = unifiedSpeed;
        
        // Send both commands to ESP32 to ensure sync
        sendCommand('setSpeedForward', {speed: unifiedSpeed});
        sendCommand('setSpeedBackward', {speed: unifiedSpeed});
        
        // Update preset button highlighting
        document.querySelectorAll('[data-speed-forward]').forEach(btn => {
          if (parseFloat(btn.getAttribute('data-speed-forward')) === unifiedSpeed) {
            btn.classList.add('active');
          } else {
            btn.classList.remove('active');
          }
        });
        document.querySelectorAll('[data-speed-backward]').forEach(btn => {
          if (parseFloat(btn.getAttribute('data-speed-backward')) === unifiedSpeed) {
            btn.classList.add('active');
          } else {
            btn.classList.remove('active');
          }
        });
        
        console.log('Switched to SEPARATE mode: both speeds set to ' + unifiedSpeed);
        
      } else {
        // SEPARATE ‚Üí UNIFIED: Use forward speed value for both
        unifiedGroup.style.display = 'flex';
        separateGroup.style.display = 'none';
        
        const forwardSpeed = parseFloat(document.getElementById('speedForward').value);
        
        // Use forward speed as the unified value
        document.getElementById('speedUnified').value = forwardSpeed;
        
        // Also update backward to match forward
        document.getElementById('speedBackward').value = forwardSpeed;
        
        // Apply forward speed to BOTH directions immediately
        sendCommand('setSpeedForward', {speed: forwardSpeed});
        sendCommand('setSpeedBackward', {speed: forwardSpeed});
        
        // Update preset button highlighting
        document.querySelectorAll('[data-speed-unified]').forEach(btn => {
          if (parseFloat(btn.getAttribute('data-speed-unified')) === forwardSpeed) {
            btn.classList.add('active');
          } else {
            btn.classList.remove('active');
          }
        });
        
        console.log('Switched to UNIFIED mode: using forward speed ' + forwardSpeed + ' for both directions');
      }
      });
    });

    // ============================================================================
    // PURSUIT MODE - Interactive Gauge Control
    // ============================================================================
    
    let pursuitActive = false;
    // Pursuit mode constants and local state
    // Note: pursuitTargetMM migrated to AppState.pursuit.targetMM
    let pursuitMaxSpeedLevel = 10;
    const PURSUIT_COMMAND_INTERVAL = 20;  // Send command max every 20ms (50Hz)
    
    // Flag to prevent WebSocket updates while user is editing max distance limit
    let isEditingMaxDistLimit = false;
    
    function updateGaugePosition(positionMM) {
      if (AppState.pursuit.totalDistanceMM <= 0) return;
      
      const containerHeight = DOM.gaugeContainer.offsetHeight;
      
      // Calculate position (0mm = bottom, totalDistanceMM = top)
      const percent = positionMM / AppState.pursuit.totalDistanceMM;
      const pixelPosition = containerHeight - (percent * containerHeight);
      
      DOM.gaugePosition.style.top = pixelPosition + 'px';
      DOM.currentPositionMM.textContent = positionMM.toFixed(1);
      
      // Update error
      const error = Math.abs(AppState.pursuit.targetMM - positionMM);
      DOM.positionError.textContent = error.toFixed(1);
    }
    
    function setGaugeTarget(positionMM) {
      if (AppState.pursuit.totalDistanceMM <= 0) return;
      
      // Clamp to valid range
      if (positionMM < 0) positionMM = 0;
      if (positionMM > AppState.pursuit.totalDistanceMM) positionMM = AppState.pursuit.totalDistanceMM;
      
      AppState.pursuit.targetMM = positionMM;
      
      const containerHeight = DOM.gaugeContainer.offsetHeight;
      
      // Calculate position (0mm = bottom, totalDistanceMM = top)
      const percent = positionMM / AppState.pursuit.totalDistanceMM;
      const pixelPosition = containerHeight - (percent * containerHeight);
      
      DOM.gaugeCursor.style.top = pixelPosition + 'px';
      DOM.targetPositionMM.textContent = positionMM.toFixed(1);
      
      // Update error
      const error = Math.abs(AppState.pursuit.targetMM - AppState.pursuit.currentPositionMM);
      DOM.positionError.textContent = error.toFixed(1);
      
      // Send pursuit command if active and enough time has passed
      if (pursuitActive) {
        const now = Date.now();
        if (now - AppState.pursuit.lastCommandTime > PURSUIT_COMMAND_INTERVAL) {
          sendPursuitCommand();
          AppState.pursuit.lastCommandTime = now;
        }
      }
    }
    
    function sendPursuitCommand() {
      // Always send command - the ESP32 will handle when to stop (errorSteps == 0)
      sendCommand('pursuitMove', {
        targetPosition: AppState.pursuit.targetMM,
        maxSpeed: pursuitMaxSpeedLevel
      });
    }
    
    // Gauge mouse interaction
    document.getElementById('gaugeContainer').addEventListener('mousedown', function(e) {
      AppState.pursuit.isDragging = true;
      updateGaugeFromMouse(e);
    });
    
    document.addEventListener('mousemove', function(e) {
      if (AppState.pursuit.isDragging) {
        updateGaugeFromMouse(e);
      }
    });
    
    document.addEventListener('mouseup', function() {
      AppState.pursuit.isDragging = false;
    });
    
    function updateGaugeFromMouse(e) {
      const container = document.getElementById('gaugeContainer');
      const rect = container.getBoundingClientRect();
      const y = e.clientY - rect.top;
      const containerHeight = rect.height;
      
      // Convert y position to percentage (top = 100%, bottom = 0%)
      let percent = 1 - (y / containerHeight);
      if (percent < 0) percent = 0;
      if (percent > 1) percent = 1;
      
      // Convert to position in mm
      const positionMM = percent * AppState.pursuit.totalDistanceMM;
      setGaugeTarget(positionMM);
    }
    
    // Pursuit mode controls
    document.getElementById('pursuitActiveCheckbox').addEventListener('change', function() {
      pursuitActive = this.checked;
      
      if (pursuitActive) {
        // Check if system is calibrating
        if (AppState.system.currentState === SystemState.CALIBRATING) {
          this.checked = false;
          pursuitActive = false;
          alert('Veuillez attendre la fin de la calibration');
          return;
        }
        
        document.getElementById('btnActivatePursuit').textContent = '‚è∏ Pause Poursuite';
        document.getElementById('btnActivatePursuit').classList.remove('btn-success');
        document.getElementById('btnActivatePursuit').classList.add('btn-warning');
        
        // Enable gauge interaction
        document.getElementById('gaugeContainer').style.opacity = '1';
        document.getElementById('gaugeContainer').style.cursor = 'crosshair';
        document.getElementById('gaugeContainer').style.pointerEvents = 'auto';
        
        // Use already set target position (from gauge clicks or current position)
        // Don't reset to current position - keep user's target choice
        if (AppState.pursuit.targetMM === undefined || isNaN(AppState.pursuit.targetMM)) {
          // Only initialize if never set before
          AppState.pursuit.targetMM = AppState.pursuit.currentPositionMM;
          setGaugeTarget(AppState.pursuit.currentPositionMM);
        }
        // else: Keep the target position that was set (even if 0 mm)
        
        // Enable pursuit mode on ESP32
        sendCommand('enablePursuitMode', {});
        
        // Send initial position command after ESP32 mode switch completes
        setTimeout(function() {
          sendPursuitCommand();
          setTimeout(startPursuitLoop, PURSUIT_COMMAND_INTERVAL);
        }, 200);
      } else {
        document.getElementById('btnActivatePursuit').textContent = '‚ñ∂ D√©marrer';
        document.getElementById('btnActivatePursuit').classList.remove('btn-warning');
        document.getElementById('btnActivatePursuit').classList.add('btn-success');
        
        // Disable gauge interaction visually
        document.getElementById('gaugeContainer').style.opacity = '0.5';
        document.getElementById('gaugeContainer').style.cursor = 'not-allowed';
        document.getElementById('gaugeContainer').style.pointerEvents = 'none';
        
        // Disable pursuit mode on ESP32
        sendCommand('disablePursuitMode', {});
        
        // NOTE: AppState.pursuit.targetMM is preserved for when user re-enables pursuit mode
      }
    });
    
    document.getElementById('btnActivatePursuit').addEventListener('click', function() {
      const checkbox = document.getElementById('pursuitActiveCheckbox');
      checkbox.checked = !checkbox.checked;
      checkbox.dispatchEvent(new Event('change'));
    });
    
    document.getElementById('pursuitMaxSpeed').addEventListener('change', function() {
      pursuitMaxSpeedLevel = parseFloat(this.value);
    });
    
    // Pursuit speed presets
    document.querySelectorAll('[data-pursuit-speed]').forEach(btn => {
      btn.addEventListener('click', function() {
        const speed = parseFloat(this.getAttribute('data-pursuit-speed'));
        document.getElementById('pursuitMaxSpeed').value = speed;
        pursuitMaxSpeedLevel = speed;
        
        document.querySelectorAll('[data-pursuit-speed]').forEach(b => b.classList.remove('active'));
        this.classList.add('active');
      });
    });
    
    // Pursuit loop - sends commands periodically
    function startPursuitLoop() {
      if (!pursuitActive) return;
      
      sendPursuitCommand();
      
      // Continue loop
      setTimeout(startPursuitLoop, PURSUIT_COMMAND_INTERVAL);
    }
    
    document.getElementById('btnStopPursuit').addEventListener('click', function() {
      // Disable pursuit mode
      document.getElementById('pursuitActiveCheckbox').checked = false;
      document.getElementById('pursuitActiveCheckbox').dispatchEvent(new Event('change'));
      
      // Return to start position to verify contact
      setTimeout(function() {
        console.log('Stopping pursuit - returning to start for contact verification');
        sendCommand('returnToStart', {});
      }, 200);  // Small delay to let pursuit mode disable first
    });

    // ============================================================================
    // TAB MANAGEMENT & MODE SWITCHING
    // ============================================================================
    
    // SYSTEM STATE ENUMERATION - Matches ESP32 backend states
    const SystemState = {
      INIT: 0,
      CALIBRATING: 1,
      READY: 2,
      RUNNING: 3,
      PAUSED: 4,
      ERROR: 5
    };
    
    // Note: Mode switching variables now in AppState.system
    // Access via: AppState.system.currentMode, AppState.system.pendingModeSwitch, etc.
    
    function switchTab(tabName) {
      // Save statistics before mode change
      sendCommand('saveStats', {});
      
      // SAFETY: Stop any running movement before switching tabs
      // This prevents confusion when switching modes while paused
      const isRunningOrPaused = (AppState.system.currentState === SystemState.RUNNING || 
                                  AppState.system.currentState === SystemState.PAUSED);
      
      if (isRunningOrPaused) {
        console.log('Stopping movement before tab switch');
        sendCommand('stop');
        // Note: UI will update via WebSocket status message
      }
      
      // PRE-CHECK: If switching to sequencer with limit active, show modal and abort
      if (tabName === 'tableau') {
        const currentLimit = AppState.pursuit.maxDistLimitPercent || 100;
        
        if (currentLimit < 100) {
          const limitedCourse = AppState.pursuit.effectiveMaxDistMM || 0;
          const totalCourse = AppState.pursuit.totalDistanceMM || 0;
          
          // Update modal content with current values
          document.getElementById('seqModalCurrentLimit').textContent = 
            currentLimit.toFixed(0) + '% (' + limitedCourse.toFixed(1) + ' mm)';
          document.getElementById('seqModalAfterLimit').textContent = 
            '100% (' + totalCourse.toFixed(1) + ' mm)';
          
          // Show modal and ABORT tab switch
          document.getElementById('sequencerLimitModal').classList.add('active');
          return; // Don't switch tab yet!
        }
      }
      
      // Hide all tab contents
      document.querySelectorAll('.tab-content').forEach(content => {
        content.classList.remove('active');
      });
      
      // Remove active class from all tabs
      document.querySelectorAll('.tab').forEach(tab => {
        tab.classList.remove('active');
      });
      
      // Show selected tab content
      const tabMap = {
        'simple': 'tabSimple',
        'pursuit': 'tabPursuit',
        'oscillation': 'tabOscillation',
        'chaos': 'tabChaos',
        'tableau': 'tabTableau'
      };
      
      document.getElementById(tabMap[tabName]).classList.add('active');
      
      // Add active class to selected tab
      document.querySelector('[data-tab="' + tabName + '"]').classList.add('active');
      
      AppState.system.currentMode = tabName;
      console.log('Switched to mode: ' + tabName);
      
      // Handle mode-specific initialization
      if (tabName === 'pursuit') {
        // Switching TO pursuit mode
        setGaugeTarget(0);  // Start at 0mm
      } else if (tabName === 'simple') {
        // Switching TO simple mode - disable pursuit if active
        if (pursuitActive) {
          document.getElementById('pursuitActiveCheckbox').checked = false;
          document.getElementById('pursuitActiveCheckbox').dispatchEvent(new Event('change'));
        }
      } else if (tabName === 'oscillation') {
        // Switching TO oscillation mode - always update center with effective max
        const totalMM = AppState.pursuit.totalDistanceMM || 0;
        const effectiveMax = (AppState.pursuit.maxDistLimitPercent && AppState.pursuit.maxDistLimitPercent < 100)
          ? (totalMM * AppState.pursuit.maxDistLimitPercent / 100)
          : totalMM;
        
        const oscCenterField = document.getElementById('oscCenter');
        if (oscCenterField && effectiveMax > 0) {
          // Always set to effective center
          oscCenterField.value = (effectiveMax / 2).toFixed(1);
          // Also send to backend (use sendOscillationConfig function)
          sendOscillationConfig();
        }
        
        validateOscillationLimits();
        updateOscillationPresets();  // Update preset buttons state
      } else if (tabName === 'chaos') {
        // Switching TO chaos mode - always update center with effective max
        const totalMM = AppState.pursuit.totalDistanceMM || 0;
        const effectiveMax = (AppState.pursuit.maxDistLimitPercent && AppState.pursuit.maxDistLimitPercent < 100)
          ? (totalMM * AppState.pursuit.maxDistLimitPercent / 100)
          : totalMM;
        
        const chaosCenterField = document.getElementById('chaosCenterPos');
        if (chaosCenterField && effectiveMax > 0) {
          // Always set to effective center
          chaosCenterField.value = (effectiveMax / 2).toFixed(1);
        }
        
        validateChaosLimits();
        updateChaosPresets();  // Update preset buttons state
      }
      // Note: tableau (sequencer) pre-check is done at the start of switchTab()
    }
    
    function isSystemRunning() {
      // State 3 = RUNNING, 4 = PAUSED (for simple mode)
      // Also check if pursuit mode is active
      return AppState.system.currentState === SystemState.RUNNING || 
             AppState.system.currentState === SystemState.PAUSED || 
             pursuitActive;
    }
    
    function cancelModeChange() {
      document.getElementById('modeChangeModal').classList.remove('active');
      AppState.system.pendingModeSwitch = null;
      
      // Reset checkbox
      document.getElementById('bypassCalibrationCheckbox').checked = false;
      
      // Restore previous tab selection
      document.querySelectorAll('.tab').forEach(tab => {
        tab.classList.remove('active');
      });
      document.querySelector('[data-tab="' + AppState.system.currentMode + '"]').classList.add('active');
    }
    
    function confirmModeChange() {
      const bypassCalibration = document.getElementById('bypassCalibrationCheckbox').checked;
      document.getElementById('modeChangeModal').classList.remove('active');
      
      // If pursuit is active, disable it first
      if (pursuitActive) {
        console.log('Mode change: Disabling pursuit mode first');
        document.getElementById('pursuitActiveCheckbox').checked = false;
        document.getElementById('pursuitActiveCheckbox').dispatchEvent(new Event('change'));
      }
      
      // Stop movement (for simple mode)
      sendCommand('stop', {});
      
      // Wait a bit for stop to complete, then either quick return or full calibration
      setTimeout(function() {
        if (bypassCalibration) {
          // Quick return to start only
          console.log('Mode change: Quick return to start (bypass full calibration)');
          sendCommand('returnToStart', {});
        } else {
          // Full calibration
          console.log('Mode change: Full calibration');
          sendCommand('calibrate', {});
        }
        
        // Reset checkbox for next time
        document.getElementById('bypassCalibrationCheckbox').checked = false;
        
        // Actually switch the tab after starting calibration/return
        if (AppState.system.pendingModeSwitch) {
          switchTab(AppState.system.pendingModeSwitch);
          AppState.system.pendingModeSwitch = null;
        }
      }, 500);
    }
    
    // ============================================================================
    // STOP CONFIRMATION MODAL FUNCTIONS
    // ============================================================================
    
    function showStopModal() {
      document.getElementById('stopModal').classList.add('active');
    }
    
    function cancelStopModal() {
      document.getElementById('stopModal').classList.remove('active');
      // Reset checkbox for next time (keep checked by default)
      document.getElementById('returnToStartCheckbox').checked = true;
    }
    
    function confirmStopModal() {
      const shouldReturnToStart = document.getElementById('returnToStartCheckbox').checked;
      document.getElementById('stopModal').classList.remove('active');
      
      // CRITICAL FIX: Detect current mode and send mode-specific stop command
      const currentMode = AppState.system.currentMode;
      
      if (currentMode === 'tableau') {  // 'tableau' is the sequencer tab name
        // SEQUENCER MODE FIX: Send stopSequence command
        console.log('Stop confirmed (Sequencer mode): Stopping sequence');
        sendCommand('stopSequence', {});
        
        // Return to start if requested (same as other modes)
        if (shouldReturnToStart) {
          setTimeout(function() {
            console.log('Stop confirmed: Returning to start position');
            sendCommand('returnToStart', {});
          }, 500);
        }
      } else if (currentMode === 'chaos') {
        // Chaos mode: send stopChaos command
        console.log('Stop confirmed (Chaos mode): Stopping chaos movement');
        sendCommand('stopChaos', {});
        
        // Return to start if requested
        if (shouldReturnToStart) {
          setTimeout(function() {
            console.log('Stop confirmed: Returning to start position');
            sendCommand('returnToStart', {});
          }, 500);
        }
      } else if (currentMode === 'oscillation') {
        // Oscillation mode: send stopOscillation command
        console.log('Stop confirmed (Oscillation mode): Stopping oscillation');
        sendCommand('stopOscillation', {});
        
        // Return to start if requested
        if (shouldReturnToStart) {
          setTimeout(function() {
            console.log('Stop confirmed: Returning to start position');
            sendCommand('returnToStart', {});
          }, 500);
        }
      } else {
        // Simple mode or others: send generic stop
        console.log('Stop confirmed: Stopping movement');
        sendCommand('stop', {});
        
        // Return to start if requested
        if (shouldReturnToStart) {
          setTimeout(function() {
            console.log('Stop confirmed: Returning to start position');
            sendCommand('returnToStart', {});
          }, 500);
        }
      }
      
      if (!shouldReturnToStart) {
        console.log('Stop confirmed: Staying at current position');
      }
      
      // Reset checkbox for next time (keep checked by default)
      document.getElementById('returnToStartCheckbox').checked = true;
    }
    
    // Sequencer Limit Modal Functions
    function cancelSequencerLimitChange() {
      document.getElementById('sequencerLimitModal').classList.remove('active');
      
      // Return to previous tab
      const prevTab = AppState.system.currentMode || 'simple';
      setTimeout(function() {
        // Restore previous tab selection
        document.querySelectorAll('.tab').forEach(tab => {
          tab.classList.remove('active');
        });
        document.querySelector('[data-tab="' + prevTab + '"]').classList.add('active');
        
        // Restore previous tab content
        document.querySelectorAll('.mode-content').forEach(content => {
          content.classList.remove('active');
        });
        document.getElementById(prevTab + '-content').classList.add('active');
      }, 10);
    }
    
    function confirmSequencerLimitChange() {
      document.getElementById('sequencerLimitModal').classList.remove('active');
      
      // Reset limit to 100%
      sendCommand('setMaxDistanceLimit', { limitPercent: 100 });
      
      // Show confirmation notification
      setTimeout(function() {
        showNotification('‚úÖ Limite r√©initialis√©e √† 100% (mode s√©quenceur)', 3000);
      }, 100);
      
      // Now actually switch to sequencer tab
      // We need to temporarily bypass the check by setting limit to 100 in AppState
      AppState.pursuit.maxDistLimitPercent = 100;
      switchTab('tableau');
    }
    
    // Tab click handlers
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', function() {
        const targetMode = this.getAttribute('data-tab');
        
        // Don't do anything if clicking on already active tab
        if (targetMode === AppState.system.currentMode) {
          return;
        }
        
        // Check if system is running
        if (isSystemRunning()) {
          // Update modal message based on current mode
          const modalMessage = document.getElementById('modalMessage');
          if (pursuitActive) {
            modalMessage.innerHTML = 
              'Le mode poursuite est actuellement actif. Le changement de mode va :<br>' +
              '‚Ä¢ D√©sactiver le mode poursuite<br>' +
              '‚Ä¢ Retourner au point de d√©part pour v√©rifier le contact<br>' +
              '‚Ä¢ Lancer une calibration si n√©cessaire<br><br>' +
              '<strong>Voulez-vous continuer ?</strong>';
          } else {
            modalMessage.innerHTML = 
              'Une op√©ration est en cours. Le changement de mode va arr√™ter le mouvement et lancer une recalibration.<br><br>' +
              '<strong>Voulez-vous continuer ?</strong>';
          }
          
          // Show confirmation modal
          AppState.system.pendingModeSwitch = targetMode;
          document.getElementById('modeChangeModal').classList.add('active');
        } else {
          // Safe to switch immediately
          switchTab(targetMode);
        }
      });
    });
    
    // Force initial state on page load (prevent browser cache issues)
    window.addEventListener('load', function() {
      // Initialize DOM cache FIRST (performance optimization)
      initDOMCache();
      
      // Initialize speed limits based on maxSpeedLevel constant
      initSpeedLimits();
      
      // Initialize max distance limit event listeners
      initMaxDistLimitListeners();
      
      // Ensure pursuit checkbox is unchecked on fresh load
      DOM.pursuitActiveCheckbox.checked = false;
      pursuitActive = false;
      
      // Reset button text
      DOM.btnActivatePursuit.textContent = '‚ñ∂ D√©marrer';
      DOM.btnActivatePursuit.classList.remove('btn-warning');
      DOM.btnActivatePursuit.classList.add('btn-success');
      
      // Disable gauge interaction on page load (pursuit mode inactive)
      if (DOM.gaugeContainer) {
        DOM.gaugeContainer.style.opacity = '0.5';
        DOM.gaugeContainer.style.cursor = 'not-allowed';
        DOM.gaugeContainer.style.pointerEvents = 'none';
      }
      
      // Request sequence table on load (wait for WebSocket connection)
      function requestSequenceTableWhenReady() {
        if (AppState.ws && AppState.ws.readyState === WebSocket.OPEN) {
          sendCommand('getSequenceTable', {});
        } else {
          setTimeout(requestSequenceTableWhenReady, 200);
        }
      }
      requestSequenceTableWhenReady();
    });
    
    // ============================================================================
    // MODE S√©quenceur - Event Listeners
    // ============================================================================
    
    document.getElementById('btnAddLine').addEventListener('click', addSequenceLine);
    document.getElementById('btnClearAll').addEventListener('click', clearSequence);
    document.getElementById('btnImportSeq').addEventListener('click', importSequence);
    document.getElementById('btnExportSeq').addEventListener('click', exportSequence);
    document.getElementById('btnDownloadTemplate').addEventListener('click', downloadTemplate);
    
    // Phase 2: Keyboard shortcuts for multi-select
    document.addEventListener('keydown', function(e) {
      // Only handle when on sequencer tab
      if (AppState.system.currentMode !== 'tableau') return;
      
      // Escape: Clear selection
      if (e.key === 'Escape' && selectedLineIds.size > 0) {
        clearSelection();
        e.preventDefault();
      }
      
      // Ctrl+A: Select all
      if ((e.ctrlKey || e.metaKey) && e.key === 'a' && sequenceLines.length > 0) {
        selectedLineIds.clear();
        sequenceLines.forEach(line => selectedLineIds.add(line.lineId));
        lastSelectedIndex = 0;
        updateBatchToolbar();
        renderSequenceTable({ lines: sequenceLines });
        e.preventDefault();
      }
      
      // Delete: Delete selected lines
      if (e.key === 'Delete' && selectedLineIds.size > 0) {
        batchDeleteLines();
        e.preventDefault();
      }
    });
    
    // ============================================================================
    // LOGS PANEL MANAGEMENT
    // ============================================================================
    
    document.getElementById('btnShowLogs').addEventListener('click', function() {
      const panel = document.getElementById('logsPanel');
      if (panel.style.display === 'none') {
        panel.style.display = 'block';
        this.innerHTML = 'üìã Logs';
        this.style.background = '#e74c3c';
        this.style.color = 'white';
        // Load log files list
        loadLogFilesList();
      } else {
        panel.style.display = 'none';
        this.innerHTML = 'üìã Logs';
        this.style.background = '#17a2b8';
        this.style.color = 'white';
      }
    });

    document.getElementById('btnCloseLogs').addEventListener('click', function() {
      document.getElementById('logsPanel').style.display = 'none';
      document.getElementById('btnShowLogs').innerHTML = 'üìã Logs';
      document.getElementById('btnShowLogs').style.background = '#17a2b8';
      document.getElementById('btnShowLogs').style.color = 'white';
    });

    document.getElementById('btnClearLogsPanel').addEventListener('click', function() {
      const logEl = document.getElementById('logConsolePanel');
      if (logEl) logEl.textContent = '(logs effac√©s)';
    });

    document.getElementById('debugLevelCheckbox').addEventListener('change', function() {
      // Toggle debug level on the ESP32
      sendCommand('toggleDebug', {});
    });

    document.getElementById('btnClearAllLogFiles').addEventListener('click', function() {
      if (confirm('Supprimer TOUS les fichiers de logs?\n\nCette action est irr√©versible.')) {
        fetch('/logs/clear', { method: 'POST' })
          .then(response => response.text())
          .then(data => {
            alert(data);
            loadLogFilesList();  // Refresh list
          })
          .catch(error => {
            alert('Erreur: ' + error);
          });
      }
    });

    function loadLogFilesList() {
      fetch('/logs')
        .then(response => response.text())
        .then(html => {
          // Parse HTML to extract file links
          const parser = new DOMParser();
          const doc = parser.parseFromString(html, 'text/html');
          const links = doc.querySelectorAll('a');
          
          if (links.length === 0) {
            DOM.logFilesList.innerHTML = '<div style="color: #999; font-style: italic; font-size: 11px;">Aucun fichier de log</div>';
            return;
          }
          
          // Create container with DOM methods (XSS safe)
          const container = document.createElement('div');
          container.style.cssText = 'display: flex; flex-direction: column; gap: 5px;';
          
          links.forEach(link => {
            const filename = link.textContent;
            const url = link.href;
            
            // Create item div
            const itemDiv = document.createElement('div');
            itemDiv.style.cssText = 'display: flex; justify-content: space-between; align-items: center; padding: 6px; background: #f9f9f9; border-radius: 4px; border: 1px solid #ddd;';
            
            // Create filename span (safe from XSS with textContent)
            const filenameSpan = document.createElement('span');
            filenameSpan.style.cssText = 'font-family: monospace; font-size: 12px;';
            filenameSpan.textContent = filename;  // Safe: uses textContent instead of innerHTML
            
            // Create download link
            const downloadLink = document.createElement('a');
            downloadLink.href = url;
            downloadLink.target = '_blank';
            downloadLink.style.cssText = 'background: #2196F3; color: white; padding: 4px 10px; border-radius: 3px; text-decoration: none; font-size: 11px;';
            downloadLink.textContent = 'üì• T√©l√©charger';
            
            itemDiv.appendChild(filenameSpan);
            itemDiv.appendChild(downloadLink);
            container.appendChild(itemDiv);
          });
          
          DOM.logFilesList.innerHTML = '';  // Clear first
          DOM.logFilesList.appendChild(container);
        })
        .catch(error => {
          DOM.logFilesList.innerHTML = '<div style="color: #f44336; font-size: 11px;">Erreur de chargement</div>';
        });
    }
    
    // ============================================================================
    // STATISTICS PANEL MANAGEMENT
    // ============================================================================
    
    let statsChart = null;  // Chart.js instance
    
    // Day icons mapping (Monday = 0, Sunday = 6)
    const dayIcons = ['üåô', 'üî•', 'üíß', '‚ö°', 'üåü', '‚òÄÔ∏è', 'üåà'];
    const dayNames = ['Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi', 'Dimanche'];
    
    /**
     * Calculate ISO 8601 week number (Monday = start of week)
     * @param {Date} date - The date to calculate week number for
     * @returns {number} Week number (1-53)
     */
    function getISOWeek(date) {
      const target = new Date(date.valueOf());
      const dayNr = (date.getDay() + 6) % 7;  // Monday = 0
      target.setDate(target.getDate() - dayNr + 3);
      const firstThursday = target.valueOf();
      target.setMonth(0, 1);
      if (target.getDay() !== 4) {
        target.setMonth(0, 1 + ((4 - target.getDay()) + 7) % 7);
      }
      return 1 + Math.ceil((firstThursday - target) / 604800000);
    }
    
    document.getElementById('btnShowStats').addEventListener('click', function() {
      const panel = document.getElementById('statsPanel');
      if (panel.style.display === 'none') {
        panel.style.display = 'block';
        this.innerHTML = 'üìä Stats';
        this.style.background = '#e74c3c';
        this.style.color = 'white';
        // Load stats data
        loadStatsData();
      } else {
        panel.style.display = 'none';
        this.innerHTML = 'üìä Stats';
        this.style.background = '#4CAF50';
        this.style.color = 'white';
      }
    });

    document.getElementById('btnCloseStats').addEventListener('click', function() {
      document.getElementById('statsPanel').style.display = 'none';
      document.getElementById('btnShowStats').innerHTML = 'üìä Stats';
      document.getElementById('btnShowStats').style.background = '#4CAF50';
      document.getElementById('btnShowStats').style.color = 'white';
    });

    document.getElementById('btnShowSystem').addEventListener('click', function() {
      const panel = document.getElementById('systemPanel');
      if (panel.style.display === 'none') {
        panel.style.display = 'block';
        this.innerHTML = '‚öôÔ∏è Sys';
        this.style.background = '#e74c3c';
        this.style.color = 'white';
      } else {
        panel.style.display = 'none';
        this.innerHTML = '‚öôÔ∏è Sys';
        this.style.background = '#2196F3';
        this.style.color = 'white';
      }
    });

    document.getElementById('btnCloseSystem').addEventListener('click', function() {
      document.getElementById('systemPanel').style.display = 'none';
      document.getElementById('btnShowSystem').innerHTML = '‚öôÔ∏è Sys';
      document.getElementById('btnShowSystem').style.background = '#2196F3';
      document.getElementById('btnShowSystem').style.color = 'white';
    });

    document.getElementById('btnClearStats').addEventListener('click', function() {
      if (confirm('‚ö†Ô∏è Supprimer TOUTES les statistiques?\n\nCette action est irr√©versible et ne supprime PAS le compteur de distance (RAZ).')) {
        fetch('/api/stats/clear', { method: 'POST' })
          .then(response => response.json())
          .then(data => {
            if (data.success) {
              alert('‚úÖ Statistiques effac√©es');
              loadStatsData();  // Refresh display
            } else {
              alert('‚ùå Erreur: ' + (data.error || 'Unknown'));
            }
          })
          .catch(error => {
            alert('‚ùå Erreur r√©seau: ' + error);
          });
      }
    });

    function loadStatsData() {
      fetch('/api/stats')
        .then(response => response.json())
        .then(data => {
          displayStatsTable(data);
          displayStatsChart(data);
        })
        .catch(error => {
          console.error('Error loading stats:', error);
          document.getElementById('statsTableBody').innerHTML = 
            '<tr><td colspan="3" style="padding: 20px; text-align: center; color: #f44336;">‚ùå Erreur de chargement</td></tr>';
        });
    }

    function displayStatsTable(stats) {
      const tbody = document.getElementById('statsTableBody');
      const totalEl = document.getElementById('statsTotalDistance');
      
      if (!stats || stats.length === 0) {
        tbody.innerHTML = '<tr><td colspan="4" style="padding: 20px; text-align: center; color: #999; font-style: italic;">Aucune statistique disponible</td></tr>';
        totalEl.textContent = '0 km';
        return;
      }
      
      // Sort by date (newest first)
      stats.sort((a, b) => new Date(b.date) - new Date(a.date));
      
      let totalMM = 0;
      tbody.innerHTML = '';
      
      stats.forEach(entry => {
        const distanceMM = entry.distanceMM || 0;
        totalMM += distanceMM;
        
        const date = new Date(entry.date);
        const dayOfWeek = date.getDay();  // 0=Sunday, 1=Monday, ...
        const dayIndex = dayOfWeek === 0 ? 6 : dayOfWeek - 1;  // Convert to Monday=0
        const dayIcon = dayIcons[dayIndex];
        
        const distanceKM = (distanceMM / 1000000).toFixed(3);
        const distanceM = (distanceMM / 1000).toFixed(1);
        const displayDistance = distanceMM >= 1000000 ? `${distanceKM} km` : `${distanceM} m`;
        
        // Get milestone icon for this day's distance
        const distanceMeters = distanceMM / 1000;
        const milestoneInfo = getMilestoneInfo(distanceMeters);
        const milestoneIcon = milestoneInfo.current ? milestoneInfo.current.emoji : 'üèÅ';
        const milestoneName = milestoneInfo.current ? milestoneInfo.current.name : 'D√©marrage';
        
        // Build tooltip with milestone info (like main display)
        let milestoneTooltip = `${milestoneInfo.current.emoji} ${milestoneInfo.current.name} (${milestoneInfo.current.threshold}m)`;
        if (milestoneInfo.current.location !== "-") {
          milestoneTooltip += ` - ${milestoneInfo.current.location}`;
        }
        
        const row = document.createElement('tr');
        row.style.borderBottom = '1px solid #f0f0f0';
        row.innerHTML = `
          <td style="padding: 8px;">${entry.date}</td>
          <td style="padding: 8px; text-align: center; font-size: 12px;">${dayNames[dayIndex]}</td>
          <td style="padding: 8px; text-align: center; font-size: 18px; cursor: help;" title="${milestoneTooltip}">${milestoneIcon}</td>
          <td style="padding: 8px; text-align: right; font-family: monospace;">${displayDistance}</td>
        `;
        tbody.appendChild(row);
      });
      
      // Update total
      const totalKM = (totalMM / 1000000).toFixed(3);
      const totalM = (totalMM / 1000).toFixed(1);
      const displayTotal = totalMM >= 1000000 ? `${totalKM} km` : `${totalM} m`;
      
      // Update total milestone icon with progress
      const totalMilestoneEl = document.getElementById('statsTotalMilestone');
      if (totalMilestoneEl && totalMM > 0) {
        const totalMeters = totalMM / 1000;
        const totalMilestoneInfo = getMilestoneInfo(totalMeters);
        const totalMilestoneIcon = totalMilestoneInfo.current ? totalMilestoneInfo.current.emoji : 'üèÅ';
        const totalMilestoneName = totalMilestoneInfo.current ? totalMilestoneInfo.current.name : 'D√©marrage';
        
        // Build tooltip with progress to next milestone
        let totalTooltip = `${totalMilestoneIcon} ${totalMilestoneName} (${totalMilestoneInfo.current.threshold}m)`;
        if (totalMilestoneInfo.current.location !== "-") {
          totalTooltip += ` - ${totalMilestoneInfo.current.location}`;
        }
        
        if (totalMilestoneInfo.next) {
          totalTooltip += `\n\n‚è≠Ô∏è Prochain: ${totalMilestoneInfo.next.emoji} ${totalMilestoneInfo.next.name} (${totalMilestoneInfo.next.threshold}m)`;
          totalTooltip += `\nüìä Progression: ${totalMilestoneInfo.progressPercent}%`;
        } else {
          totalTooltip += '\n\nüèÜ Objectif final atteint!';
        }
        
        totalMilestoneEl.textContent = totalMilestoneIcon;
        totalMilestoneEl.setAttribute('title', totalTooltip);
        totalMilestoneEl.style.cursor = 'help';
      }
      
      // Add progress percentage to total distance display
      const totalMilestoneInfo = getMilestoneInfo(totalMM / 1000);
      if (totalMilestoneInfo.next) {
        totalEl.textContent = `${displayTotal} (${totalMilestoneInfo.progressPercent}%)`;
      } else {
        totalEl.textContent = displayTotal;
      }
    }

    function displayStatsChart(stats) {
      if (!stats || stats.length === 0) {
        if (statsChart) {
          statsChart.destroy();
          statsChart = null;
        }
        return;
      }
      
      // Filter last 90 days (3 months sliding window)
      const today = new Date();
      const threeMonthsAgo = new Date(today);
      threeMonthsAgo.setDate(today.getDate() - 90);
      
      const filteredStats = stats.filter(entry => {
        const entryDate = new Date(entry.date);
        return entryDate >= threeMonthsAgo;
      });
      
      // Sort by date (oldest first for chart)
      filteredStats.sort((a, b) => new Date(a.date) - new Date(b.date));
      
      // ‚ú® Agr√©gation par semaine (1 barre = 1 semaine)
      const weeklyData = {};  // Key: "2025-W43" (ISO week number)
      
      filteredStats.forEach(entry => {
        const date = new Date(entry.date);
        
        // Calculer num√©ro de semaine ISO 8601
        const weekNumber = getISOWeek(date);
        const year = date.getFullYear();
        const weekKey = `${year}-W${String(weekNumber).padStart(2, '0')}`;
        
        // Initialiser si n√©cessaire
        if (!weeklyData[weekKey]) {
          weeklyData[weekKey] = {
            totalMM: 0,
            startDate: null,
            endDate: null,
            days: []
          };
        }
        
        // Accumuler distance
        weeklyData[weekKey].totalMM += entry.distanceMM;
        weeklyData[weekKey].days.push(entry.date);
        
        // Tracker dates min/max de la semaine
        if (!weeklyData[weekKey].startDate || date < weeklyData[weekKey].startDate) {
          weeklyData[weekKey].startDate = date;
        }
        if (!weeklyData[weekKey].endDate || date > weeklyData[weekKey].endDate) {
          weeklyData[weekKey].endDate = date;
        }
      });
      
      // Pr√©parer donn√©es pour Chart.js
      const sortedWeeks = Object.keys(weeklyData).sort();
      const labels = sortedWeeks.map(weekKey => {
        const week = weeklyData[weekKey];
        // Label: "21-27 Oct" (format compact)
        const start = week.startDate.getDate();
        const end = week.endDate.getDate();
        const month = week.startDate.toLocaleDateString('fr-FR', { month: 'short' });
        return `${start}-${end} ${month}`;
      });
      
      const distances = sortedWeeks.map(weekKey => {
        const totalMM = weeklyData[weekKey].totalMM;
        return (totalMM / 1000).toFixed(1);  // mm ‚Üí m
      });
      
      const ctx = document.getElementById('statsChart').getContext('2d');
      
      if (statsChart) {
        statsChart.destroy();
      }
      
      statsChart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [{
            label: 'Distance hebdomadaire (m)',
            data: distances,
            backgroundColor: 'rgba(76, 175, 80, 0.6)',
            borderColor: 'rgba(76, 175, 80, 1)',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: true,
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              callbacks: {
                title: function(context) {
                  const weekKey = sortedWeeks[context[0].dataIndex];
                  const week = weeklyData[weekKey];
                  return `Semaine ${weekKey.split('-')[1]} (${labels[context[0].dataIndex]})`;
                },
                label: function(context) {
                  const value = parseFloat(context.parsed.y);
                  return value >= 1000 ? `${(value / 1000).toFixed(2)} km` : `${value.toFixed(1)} m`;
                },
                afterLabel: function(context) {
                  if (!context || !context[0] || context[0].dataIndex === undefined) return '';
                  const weekKey = sortedWeeks[context[0].dataIndex];
                  const week = weeklyData[weekKey];
                  if (!week) return '';
                  return `${week.days.length} jour(s) actif(s)`;
                }
              }
            }
          },
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Distance (m)'
              }
            },
            x: {
              title: {
                display: true,
                text: 'Semaines (90 derniers jours)'
              },
              ticks: {
                maxRotation: 45,
                minRotation: 45
              }
            }
          }
        }
      });
    }
    
    document.getElementById('btnStartSequence').addEventListener('click', function() {
      // Disable both start buttons immediately (instant feedback)
      setButtonState(DOM.btnStartSequence, false);
      setButtonState(DOM.btnLoopSequence, false);
      sendCommand('startSequence', {});
    });
    
    document.getElementById('btnLoopSequence').addEventListener('click', function() {
      // Disable both start buttons immediately (instant feedback)
      setButtonState(DOM.btnStartSequence, false);
      setButtonState(DOM.btnLoopSequence, false);
      sendCommand('loopSequence', {});
    });
    
    document.getElementById('btnPauseSequence').addEventListener('click', function() {
      sendCommand('toggleSequencePause', {});
    });
    
    document.getElementById('btnStopSequence').addEventListener('click', function() {
      // Only show modal if motor has moved (currentStep > 0)
      if (currentPositionMM > 0.5) {
        showStopModal();
      } else {
        // Direct stop if at position 0
        sendCommand('stopSequence', {});
      }
    });
    
    // ============================================================================
    // ============================================================================
    // MODE OSCILLATION - Event Listeners
    // ============================================================================
    
    // Toggle help section
    function toggleOscHelp() {
      const helpSection = document.getElementById('oscHelpSection');
      helpSection.style.display = helpSection.style.display === 'none' ? 'block' : 'none';
    }
    
    function toggleChaosHelp() {
      const helpSection = document.getElementById('chaosHelpSection');
      helpSection.style.display = helpSection.style.display === 'none' ? 'block' : 'none';
    }
    
    // Debounce timer for validation
    let validationDebounceTimer = null;
    
    // Update limit validation on input change (with debouncing)
    function validateOscillationLimits() {
      const center = parseFloat(DOM.oscCenter.value) || 0;
      const amplitude = parseFloat(DOM.oscAmplitude.value) || 0;
      const minPos = center - amplitude;
      const maxPos = center + amplitude;
      
      const minLimit = 0;
      const maxLimit = AppState.pursuit.totalDistanceMM || 0;
      
      const warning = document.getElementById('oscLimitWarning');
      const statusSpan = document.getElementById('oscLimitStatus');
      const btnStart = DOM.btnStartOscillation;
      
      // If not calibrated yet (check both canStart and totalDistanceMM), show waiting message
      if (!AppState.system.canStart || !AppState.pursuit.totalDistanceMM || AppState.pursuit.totalDistanceMM === 0) {
        warning.style.display = 'none';
        statusSpan.textContent = '‚è≥ En attente calibration';
        statusSpan.style.color = '#ff9800';
        btnStart.disabled = true;
        btnStart.style.opacity = '0.5';
        btnStart.style.cursor = 'not-allowed';
        return false;
      }
      
      if (minPos < minLimit || maxPos > maxLimit) {
        warning.style.display = 'block';
        statusSpan.textContent = '‚ùå Invalide';
        statusSpan.style.color = '#e74c3c';
        btnStart.disabled = true;
        btnStart.style.opacity = '0.5';
        btnStart.style.cursor = 'not-allowed';
        return false;
      } else {
        warning.style.display = 'none';
        statusSpan.textContent = '‚úÖ Valide';
        statusSpan.style.color = '#27ae60';
        btnStart.disabled = false;
        btnStart.style.opacity = '1';
        btnStart.style.cursor = 'pointer';
        updateOscillationPresets();  // Update preset buttons state
        return true;
      }
    }
    
    // Helper function to send oscillation config in real-time
    function sendOscillationConfig() {
      const amplitude = parseFloat(document.getElementById('oscAmplitude').value) || 0;
      const frequency = parseFloat(document.getElementById('oscFrequency').value) || 0.5;
      
      // üöÄ SAFETY: Check if frequency would exceed speed limit
      const MAX_SPEED_MM_S = maxSpeedLevel * 10.0; // 300 mm/s by default
      const theoreticalSpeed = 2 * Math.PI * frequency * amplitude;
      
      if (amplitude > 0 && theoreticalSpeed > MAX_SPEED_MM_S) {
        // Calculate max allowed frequency for this amplitude
        const maxAllowedFreq = MAX_SPEED_MM_S / (2.0 * Math.PI * amplitude);
        
        // Show notification
        showNotification(
          `‚ö†Ô∏è Fr√©quence limit√©e: ${frequency.toFixed(2)} Hz ‚Üí ${maxAllowedFreq.toFixed(2)} Hz (vitesse max: ${MAX_SPEED_MM_S.toFixed(0)} mm/s)`,
          'error',
          4000
        );
        
        // Don't modify the input field - backend will handle limiting
        // User sees their requested value, but backend uses effective frequency
      }
      
      const config = {
        centerPositionMM: parseFloat(document.getElementById('oscCenter').value) || 0,
        amplitudeMM: amplitude,
        waveform: parseInt(document.getElementById('oscWaveform').value) || 0,
        frequencyHz: frequency,
        enableRampIn: document.getElementById('oscRampInEnable').checked,
        rampInDurationMs: parseFloat(document.getElementById('oscRampInDuration').value) || 2000,
        enableRampOut: document.getElementById('oscRampOutEnable').checked,
        rampOutDurationMs: parseFloat(document.getElementById('oscRampOutDuration').value) || 2000,
        cycleCount: parseInt(document.getElementById('oscCycleCount').value) || 0,
        returnToCenter: document.getElementById('oscReturnCenter').checked
      };
      sendCommand('setOscillation', config);
    }
    
    // Oscillation input editing protection + real-time update
    // Use mousedown to catch spinner clicks BEFORE focus + force focus immediately
    document.getElementById('oscCenter').addEventListener('mousedown', function() {
      AppState.editing.oscField = 'oscCenter';
      this.focus();
    });
    document.getElementById('oscCenter').addEventListener('focus', function() {
      AppState.editing.oscField = 'oscCenter';
    });
    document.getElementById('oscCenter').addEventListener('blur', function() {
      AppState.editing.oscField = null;
      validateOscillationLimits();
      sendOscillationConfig();  // Send on blur
    });
    document.getElementById('oscCenter').addEventListener('input', function() {
      // Debounce validation on input (300ms)
      clearTimeout(validationDebounceTimer);
      validationDebounceTimer = setTimeout(validateOscillationLimits, 300);
    });
    
    document.getElementById('oscAmplitude').addEventListener('mousedown', function() {
      AppState.editing.oscField = 'oscAmplitude';
      this.focus();
    });
    document.getElementById('oscAmplitude').addEventListener('focus', function() {
      AppState.editing.oscField = 'oscAmplitude';
    });
    document.getElementById('oscAmplitude').addEventListener('blur', function() {
      AppState.editing.oscField = null;
      validateOscillationLimits();
      sendOscillationConfig();  // Send on blur
    });
    document.getElementById('oscAmplitude').addEventListener('input', function() {
      // Debounce validation on input (300ms)
      clearTimeout(validationDebounceTimer);
      validationDebounceTimer = setTimeout(validateOscillationLimits, 300);
    });
    
    document.getElementById('oscWaveform').addEventListener('mousedown', function() {
      AppState.editing.oscField = 'oscWaveform';
      this.focus();
    });
    document.getElementById('oscWaveform').addEventListener('focus', function() {
      AppState.editing.oscField = 'oscWaveform';
    });
    document.getElementById('oscWaveform').addEventListener('change', function() {
      AppState.editing.oscField = null;
      sendOscillationConfig();  // Send immediately on change
    });
    
    document.getElementById('oscFrequency').addEventListener('mousedown', function() {
      AppState.editing.oscField = 'oscFrequency';
      this.focus();
    });
    document.getElementById('oscFrequency').addEventListener('focus', function() {
      AppState.editing.oscField = 'oscFrequency';
    });
    document.getElementById('oscFrequency').addEventListener('blur', function() {
      AppState.editing.oscField = null;
      validateOscillationLimits();  // Validate on blur
      sendOscillationConfig();  // Send on blur
    });
    document.getElementById('oscFrequency').addEventListener('input', function() {
      // Debounce validation on input (300ms)
      clearTimeout(validationDebounceTimer);
      validationDebounceTimer = setTimeout(() => {
        validateOscillationLimits();
        updateOscillationPresets(); // Update presets to gray out invalid ones
      }, 300);
    });
    
    document.getElementById('oscRampInDuration').addEventListener('mousedown', function() {
      AppState.editing.oscField = 'oscRampInDuration';
      this.focus();
    });
    document.getElementById('oscRampInDuration').addEventListener('focus', function() {
      AppState.editing.oscField = 'oscRampInDuration';
    });
    document.getElementById('oscRampInDuration').addEventListener('blur', function() {
      AppState.editing.oscField = null;
      sendOscillationConfig();  // Send on blur
    });
    
    document.getElementById('oscRampOutDuration').addEventListener('mousedown', function() {
      AppState.editing.oscField = 'oscRampOutDuration';
      this.focus();
    });
    document.getElementById('oscRampOutDuration').addEventListener('focus', function() {
      AppState.editing.oscField = 'oscRampOutDuration';
    });
    document.getElementById('oscRampOutDuration').addEventListener('blur', function() {
      AppState.editing.oscField = null;
      sendOscillationConfig();  // Send on blur
    });
    
    document.getElementById('oscCycleCount').addEventListener('mousedown', function() {
      AppState.editing.oscField = 'oscCycleCount';
      this.focus();
    });
    document.getElementById('oscCycleCount').addEventListener('focus', function() {
      AppState.editing.oscField = 'oscCycleCount';
    });
    document.getElementById('oscCycleCount').addEventListener('blur', function() {
      AppState.editing.oscField = null;
      sendOscillationConfig();  // Send on blur
    });
    
    // Toggle ramp config visibility + send config (compact mode: always visible)
    document.getElementById('oscRampInEnable').addEventListener('change', function() {
      // document.getElementById('oscRampInConfig').style.display = this.checked ? 'block' : 'none'; // Removed in compact mode
      sendOscillationConfig();  // Send on change
    });
    
    document.getElementById('oscRampOutEnable').addEventListener('change', function() {
      // document.getElementById('oscRampOutConfig').style.display = this.checked ? 'block' : 'none'; // Removed in compact mode
      sendOscillationConfig();  // Send on change
    });
    
    document.getElementById('oscReturnCenter').addEventListener('change', function() {
      sendOscillationConfig();  // Send on change
    });
    
    // Start oscillation
    document.getElementById('btnStartOscillation').addEventListener('click', function() {
      if (!validateOscillationLimits()) {
        showNotification('Limites invalides: ajustez le centre ou l\'amplitude', 'error');
        return;
      }
      
      // Send final config + start (config already sent in real-time, but ensure it's current)
      sendOscillationConfig();
      
      // Wait a bit then start
      setTimeout(function() {
        sendCommand('startOscillation', {});
      }, 50);
    });
    
    // Stop oscillation
    document.getElementById('btnStopOscillation').addEventListener('click', function() {
      // Only show modal if motor has moved (currentStep > 0)
      if (currentPositionMM > 0.5) {
        showStopModal();
      } else {
        // Direct stop if at position 0
        sendCommand('stopOscillation', {});
      }
    });
    
    // Pause oscillation
    document.getElementById('btnPauseOscillation').addEventListener('click', function() {
      sendCommand('pause');
    });
    
    // Oscillation preset buttons handlers
    document.querySelectorAll('[data-osc-center]').forEach(btn => {
      btn.addEventListener('click', function() {
        if (!this.disabled) {
          document.getElementById('oscCenter').value = this.getAttribute('data-osc-center');
          sendOscillationConfig();
          validateOscillationLimits();
          updateOscillationPresets();
        }
      });
    });
    
    document.querySelectorAll('[data-osc-amplitude]').forEach(btn => {
      btn.addEventListener('click', function() {
        if (!this.disabled) {
          const newAmplitude = this.getAttribute('data-osc-amplitude');
          console.log('üéØ Preset amplitude clicked: ' + newAmplitude + 'mm');
          document.getElementById('oscAmplitude').value = newAmplitude;
          console.log('üì§ Sending oscillation config with amplitude=' + newAmplitude);
          sendOscillationConfig();
          validateOscillationLimits();
          updateOscillationPresets();
        }
      });
    });
    
    document.querySelectorAll('[data-osc-frequency]').forEach(btn => {
      btn.addEventListener('click', function() {
        if (!this.disabled) {
          document.getElementById('oscFrequency').value = this.getAttribute('data-osc-frequency');
          sendOscillationConfig();
        }
      });
    });
    
    // Function to update visual state of oscillation preset buttons
    function updateOscillationPresets() {
      const effectiveMax = AppState.pursuit.effectiveMaxDistMM || AppState.pursuit.totalDistanceMM || 0;
      if (effectiveMax === 0) return;
      
      const currentCenter = parseFloat(document.getElementById('oscCenter').value) || 0;
      const currentAmplitude = parseFloat(document.getElementById('oscAmplitude').value) || 0;
      
      // üöÄ MAX_SPEED_LEVEL constant (must match backend)
      const MAX_SPEED_MM_S = maxSpeedLevel * 10.0; // 300 mm/s by default
      
      // Validate center presets (must allow current amplitude)
      document.querySelectorAll('[data-osc-center]').forEach(btn => {
        const centerValue = parseFloat(btn.getAttribute('data-osc-center'));
        const minPos = centerValue - currentAmplitude;
        const maxPos = centerValue + currentAmplitude;
        const isValid = minPos >= 0 && maxPos <= effectiveMax;
        
        btn.disabled = !isValid;
        btn.style.opacity = isValid ? '1' : '0.3';
        btn.style.cursor = isValid ? 'pointer' : 'not-allowed';
      });
      
      // Validate amplitude presets (must respect current center)
      document.querySelectorAll('[data-osc-amplitude]').forEach(btn => {
        const amplitudeValue = parseFloat(btn.getAttribute('data-osc-amplitude'));
        const minPos = currentCenter - amplitudeValue;
        const maxPos = currentCenter + amplitudeValue;
        const isValid = minPos >= 0 && maxPos <= effectiveMax;
        
        btn.disabled = !isValid;
        btn.style.opacity = isValid ? '1' : '0.3';
        btn.style.cursor = isValid ? 'pointer' : 'not-allowed';
      });
      
      // üöÄ Validate frequency presets (must not exceed speed limit)
      document.querySelectorAll('[data-osc-frequency]').forEach(btn => {
        const frequencyValue = parseFloat(btn.getAttribute('data-osc-frequency'));
        
        // Calculate theoretical speed for this frequency
        if (currentAmplitude > 0) {
          const theoreticalSpeed = 2 * Math.PI * frequencyValue * currentAmplitude;
          const isValid = theoreticalSpeed <= MAX_SPEED_MM_S;
          
          btn.disabled = !isValid;
          btn.style.opacity = isValid ? '1' : '0.3';
          btn.style.cursor = isValid ? 'pointer' : 'not-allowed';
          btn.title = isValid 
            ? `${frequencyValue} Hz (${theoreticalSpeed.toFixed(0)} mm/s)` 
            : `‚ö†Ô∏è ${frequencyValue} Hz d√©passerait ${MAX_SPEED_MM_S} mm/s (${theoreticalSpeed.toFixed(0)} mm/s calcul√©)`;
        }
      });
    }
    
    // ============================================================================
    // CHAOS MODE HANDLERS
    // ============================================================================
    
    // Send chaos configuration
    // Send chaos configuration
    function sendChaosConfig() {
      const centerPos = parseFloat(document.getElementById('chaosCenterPos').value);
      const amplitude = parseFloat(document.getElementById('chaosAmplitude').value);
      const maxSpeed = parseFloat(document.getElementById('chaosMaxSpeed').value);
      const craziness = parseFloat(document.getElementById('chaosCraziness').value);
      const duration = parseInt(document.getElementById('chaosDuration').value);
      const seed = parseInt(document.getElementById('chaosSeed').value);
      
      // Collect pattern selections
      const patternsEnabled = [
        document.getElementById('patternZigzag').checked,
        document.getElementById('patternSweep').checked,
        document.getElementById('patternPulse').checked,
        document.getElementById('patternDrift').checked,
        document.getElementById('patternBurst').checked,
        document.getElementById('patternWave').checked,
        document.getElementById('patternPendulum').checked,
        document.getElementById('patternSpiral').checked,
        document.getElementById('patternCalm').checked,
        document.getElementById('patternBruteForce').checked,
        document.getElementById('patternLiberator').checked
      ];
      
      sendCommand('setChaosConfig', {
        centerPositionMM: centerPos,
        amplitudeMM: amplitude,
        maxSpeedLevel: maxSpeed,
        crazinessPercent: craziness,
        durationSeconds: duration,
        seed: seed,
        patternsEnabled: patternsEnabled
      });
    }
    
    // Validate chaos limits
    function validateChaosLimits() {
      const centerPos = parseFloat(document.getElementById('chaosCenterPos').value);
      const amplitude = parseFloat(document.getElementById('chaosAmplitude').value);
      
      if (centerPos - amplitude < 0 || centerPos + amplitude > AppState.pursuit.totalDistanceMM) {
        return false;
      }
      return true;
    }
    
    // Function to update visual state of chaos preset buttons
    function updateChaosPresets() {
      const effectiveMax = AppState.pursuit.effectiveMaxDistMM || AppState.pursuit.totalDistanceMM || 0;
      if (effectiveMax === 0) return;
      
      const currentCenter = parseFloat(document.getElementById('chaosCenterPos').value) || 0;
      const currentAmplitude = parseFloat(document.getElementById('chaosAmplitude').value) || 0;
      
      // Validate center presets (must allow current amplitude)
      document.querySelectorAll('[data-chaos-center]').forEach(btn => {
        const centerValue = parseFloat(btn.getAttribute('data-chaos-center'));
        const minPos = centerValue - currentAmplitude;
        const maxPos = centerValue + currentAmplitude;
        const isValid = minPos >= 0 && maxPos <= effectiveMax;
        
        btn.disabled = !isValid;
        btn.style.opacity = isValid ? '1' : '0.3';
        btn.style.cursor = isValid ? 'pointer' : 'not-allowed';
      });
      
      // Validate amplitude presets (must respect current center)
      document.querySelectorAll('[data-chaos-amplitude]').forEach(btn => {
        const amplitudeValue = parseFloat(btn.getAttribute('data-chaos-amplitude'));
        const minPos = currentCenter - amplitudeValue;
        const maxPos = currentCenter + amplitudeValue;
        const isValid = minPos >= 0 && maxPos <= effectiveMax;
        
        btn.disabled = !isValid;
        btn.style.opacity = isValid ? '1' : '0.3';
        btn.style.cursor = isValid ? 'pointer' : 'not-allowed';
      });
    }
    
    // Function to update pattern toggle button text (Tout/Aucun)
    function updatePatternToggleButton() {
      const patterns = [
        'patternZigzag', 'patternSweep', 'patternPulse', 'patternDrift',
        'patternBurst', 'patternWave', 'patternPendulum', 'patternSpiral',
        'patternCalm', 'patternBruteForce', 'patternLiberator'
      ];
      
      const checkedCount = patterns.filter(id => document.getElementById(id).checked).length;
      const btn = document.getElementById('btnEnableAllPatterns');
      
      if (checkedCount === patterns.length) {
        // All checked ‚Üí show "Aucun" (next action will uncheck all)
        btn.textContent = '‚ùå Aucun';
      } else {
        // Some or none checked ‚Üí show "Tout" (next action will check all)
        btn.textContent = '‚úÖ Tout';
      }
    }
    
    // Update chaos UI with live data
    function updateChaosUI(data) {
      if (!data.chaosState) return;
      
      const isRunning = data.chaosState.isRunning;
      const wasRunning = DOM.chaosStats.style.display === 'block';  // Track previous state
      const isCalibrating = data.state === SystemState.CALIBRATING;
      
      // Show/hide stats panel
      DOM.chaosStats.style.display = isRunning ? 'block' : 'none';
      
      // CRITICAL FIX: Reset patterns flag when chaos stops
      // This allows patterns to be re-synced from backend after each run
      if (wasRunning && !isRunning) {
        console.log('üîÑ Chaos stopped - resetting patterns flag for next sync');
        AppState.flags.patternsInitialized = false;
      }
      
      // Update button states (disable if not calibrated or calibrating)
      const canStart = canStartOperation() && !isRunning;
      setButtonState(DOM.btnStartChaos, canStart);
      DOM.btnStopChaos.disabled = !isRunning;
      
      // Allow live config changes while running (except seed)
      // Config inputs remain enabled for real-time adjustments
      document.getElementById('chaosCenterPos').disabled = false;
      document.getElementById('chaosAmplitude').disabled = false;
      document.getElementById('chaosMaxSpeed').disabled = false;
      document.getElementById('chaosCraziness').disabled = false;
      document.getElementById('chaosDuration').disabled = false;
      document.getElementById('chaosSeed').disabled = isRunning;  // Only disable seed while running
      
      // Enable/disable pattern checkboxes and preset buttons based on running state
      // Checkboxes: ALWAYS disabled while running, ALWAYS enabled when stopped
      document.getElementById('patternZigzag').disabled = isRunning || isCalibrating;
      document.getElementById('patternSweep').disabled = isRunning || isCalibrating;
      document.getElementById('patternPulse').disabled = isRunning || isCalibrating;
      document.getElementById('patternDrift').disabled = isRunning || isCalibrating;
      document.getElementById('patternBurst').disabled = isRunning || isCalibrating;
      document.getElementById('patternWave').disabled = isRunning || isCalibrating;
      document.getElementById('patternPendulum').disabled = isRunning || isCalibrating;
      document.getElementById('patternSpiral').disabled = isRunning || isCalibrating;
      document.getElementById('btnEnableAllPatterns').disabled = isRunning || isCalibrating;
      document.getElementById('btnEnableSoftPatterns').disabled = isRunning || isCalibrating;
      document.getElementById('btnEnableDynamicPatterns').disabled = isRunning || isCalibrating;
      
      // Restore pattern states from backend ONLY on first load (not on every status update)
      // This prevents user's checkbox changes from being overwritten during runtime config changes
      if (!AppState.flags.patternsInitialized && !isRunning && data.chaos && data.chaos.patternsEnabled) {
        document.getElementById('patternZigzag').checked = data.chaos.patternsEnabled[0];
        document.getElementById('patternSweep').checked = data.chaos.patternsEnabled[1];
        document.getElementById('patternPulse').checked = data.chaos.patternsEnabled[2];
        document.getElementById('patternDrift').checked = data.chaos.patternsEnabled[3];
        document.getElementById('patternBurst').checked = data.chaos.patternsEnabled[4];
        document.getElementById('patternWave').checked = data.chaos.patternsEnabled[5];
        document.getElementById('patternPendulum').checked = data.chaos.patternsEnabled[6];
        document.getElementById('patternSpiral').checked = data.chaos.patternsEnabled[7];
        AppState.flags.patternsInitialized = true;  // Mark as initialized
      }
      
      if (isRunning) {
        // Update stats
        document.getElementById('statPattern').textContent = data.chaosState.patternName;
        document.getElementById('statPosition').textContent = data.positionMM.toFixed(2) + ' mm';
        
        const range = data.chaosState.maxReachedMM - data.chaosState.minReachedMM;
        document.getElementById('statRange').textContent = 
          data.chaosState.minReachedMM.toFixed(1) + ' - ' + 
          data.chaosState.maxReachedMM.toFixed(1) + ' mm (' + 
          range.toFixed(1) + ' mm)';
        
        document.getElementById('statCount').textContent = data.chaosState.patternsExecuted;
        
        // Update timer
        if (data.chaos.durationSeconds > 0 && data.chaosState.elapsedSeconds !== undefined) {
          document.getElementById('statTimer').style.display = 'block';
          document.getElementById('statElapsed').textContent = 
            data.chaosState.elapsedSeconds + ' / ' + data.chaos.durationSeconds;
        } else if (data.chaosState.elapsedSeconds !== undefined) {
          document.getElementById('statTimer').style.display = 'block';
          document.getElementById('statElapsed').textContent = data.chaosState.elapsedSeconds;
        } else {
          document.getElementById('statTimer').style.display = 'none';
        }
      }
      
      // Update preset buttons visual state
      updateChaosPresets();
    }
    
    // Start chaos
    document.getElementById('btnStartChaos').addEventListener('click', function() {
      if (!validateChaosLimits()) {
        showNotification('Limites invalides: la zone chaos d√©passe les limites calibr√©es', 'error');
        return;
      }
      
      const centerPos = parseFloat(document.getElementById('chaosCenterPos').value);
      const amplitude = parseFloat(document.getElementById('chaosAmplitude').value);
      const maxSpeed = parseFloat(document.getElementById('chaosMaxSpeed').value);
      const craziness = parseFloat(document.getElementById('chaosCraziness').value);
      const duration = parseInt(document.getElementById('chaosDuration').value);
      const seed = parseInt(document.getElementById('chaosSeed').value);
      
      // Collect pattern selections (11 patterns: ZIGZAG, SWEEP, PULSE, DRIFT, BURST, WAVE, PENDULUM, SPIRAL, BREATHING, BRUTE_FORCE, LIBERATOR)
      const patternsEnabled = [
        document.getElementById('patternZigzag').checked,
        document.getElementById('patternSweep').checked,
        document.getElementById('patternPulse').checked,
        document.getElementById('patternDrift').checked,
        document.getElementById('patternBurst').checked,
        document.getElementById('patternWave').checked,
        document.getElementById('patternPendulum').checked,
        document.getElementById('patternSpiral').checked,
        document.getElementById('patternCalm').checked,
        document.getElementById('patternBruteForce').checked,
        document.getElementById('patternLiberator').checked
      ];
      
      // Validate at least one pattern selected
      if (!patternsEnabled.some(p => p)) {
        showNotification('‚ö†Ô∏è Au moins un pattern doit √™tre activ√©', 'error');
        return;
      }
      
      sendCommand('startChaos', {
        centerPositionMM: centerPos,
        amplitudeMM: amplitude,
        maxSpeedLevel: maxSpeed,
        crazinessPercent: craziness,
        durationSeconds: duration,
        seed: seed,
        patternsEnabled: patternsEnabled
      });
    });
    
    // Stop chaos
    document.getElementById('btnStopChaos').addEventListener('click', function() {
      // Only show modal if motor has moved (currentStep > 0)
      if (currentPositionMM > 0.5) {
        showStopModal();
      } else {
        // Direct stop if at position 0
        sendCommand('stopChaos', {});
      }
    });
    
    // Pause chaos
    document.getElementById('btnPauseChaos').addEventListener('click', function() {
      sendCommand('pause');
    });
    
    // Chaos preset buttons
    document.querySelectorAll('[data-chaos-center]').forEach(btn => {
      btn.addEventListener('click', function() {
        if (!this.disabled) {
          document.getElementById('chaosCenterPos').value = this.dataset.chaosCenter;
          sendChaosConfig();  // Send on preset click
          updateChaosPresets();  // Update visual state
        }
      });
    });
    
    document.querySelectorAll('[data-chaos-amplitude]').forEach(btn => {
      btn.addEventListener('click', function() {
        if (!this.disabled) {
          document.getElementById('chaosAmplitude').value = this.dataset.chaosAmplitude;
          sendChaosConfig();  // Send on preset click
          updateChaosPresets();  // Update visual state
        }
      });
    });
    
    document.querySelectorAll('[data-chaos-speed]').forEach(btn => {
      btn.addEventListener('click', function() {
        document.getElementById('chaosMaxSpeed').value = this.dataset.chaosSpeed;
        sendChaosConfig();  // Send on preset click
      });
    });
    
    document.querySelectorAll('[data-chaos-duration]').forEach(btn => {
      btn.addEventListener('click', function() {
        document.getElementById('chaosDuration').value = this.dataset.chaosDuration;
        sendChaosConfig();  // Send on preset click
      });
    });
    
    document.querySelectorAll('[data-chaos-craziness]').forEach(btn => {
      btn.addEventListener('click', function() {
        document.getElementById('chaosCraziness').value = this.dataset.chaosCraziness;
        document.getElementById('crazinessValue').textContent = this.dataset.chaosCraziness;
        sendChaosConfig();  // Send on preset click
      });
    });
    
    // Update craziness value display and send config
    document.getElementById('chaosCraziness').addEventListener('input', function() {
      document.getElementById('crazinessValue').textContent = this.value;
    });
    
    // Send config on blur (when user finishes editing)
    document.getElementById('chaosCenterPos').addEventListener('blur', function() {
      sendChaosConfig();
      updateChaosPresets();  // Update visual state after manual edit
    });
    document.getElementById('chaosAmplitude').addEventListener('blur', function() {
      sendChaosConfig();
      updateChaosPresets();  // Update visual state after manual edit
    });
    document.getElementById('chaosMaxSpeed').addEventListener('blur', function() {
      sendChaosConfig();
    });
    document.getElementById('chaosCraziness').addEventListener('blur', function() {
      sendChaosConfig();
    });
    document.getElementById('chaosDuration').addEventListener('blur', function() {
      sendChaosConfig();
    });
    document.getElementById('chaosSeed').addEventListener('blur', function() {
      sendChaosConfig();
    });
    
    // Pattern preset buttons
    document.getElementById('btnEnableAllPatterns').addEventListener('click', function() {
      // Get all pattern checkboxes
      const patterns = [
        'patternZigzag', 'patternSweep', 'patternPulse', 'patternDrift',
        'patternBurst', 'patternWave', 'patternPendulum', 'patternSpiral',
        'patternCalm', 'patternBruteForce', 'patternLiberator'
      ];
      
      // Check if all are currently checked
      const allChecked = patterns.every(id => document.getElementById(id).checked);
      
      // Toggle: if all checked ‚Üí uncheck all, otherwise check all
      const newState = !allChecked;
      patterns.forEach(id => {
        document.getElementById(id).checked = newState;
      });
      
      // Update button text immediately
      updatePatternToggleButton();
    });
    
    document.getElementById('btnEnableSoftPatterns').addEventListener('click', function() {
      // Doux (45%): WAVE, PENDULUM, SPIRAL, BREATHING
      document.getElementById('patternZigzag').checked = false;
      document.getElementById('patternSweep').checked = false;
      document.getElementById('patternPulse').checked = false;
      document.getElementById('patternDrift').checked = false;
      document.getElementById('patternBurst').checked = false;
      document.getElementById('patternWave').checked = true;
      document.getElementById('patternPendulum').checked = true;
      document.getElementById('patternSpiral').checked = true;
      document.getElementById('patternCalm').checked = true;
      document.getElementById('patternBruteForce').checked = false;
      document.getElementById('patternLiberator').checked = false;
      updatePatternToggleButton();
    });
    
    document.getElementById('btnEnableDynamicPatterns').addEventListener('click', function() {
      // Dynamiques (55%): ZIGZAG, SWEEP, PULSE, DRIFT, BURST, BRUTE_FORCE, LIBERATOR
      document.getElementById('patternZigzag').checked = true;
      document.getElementById('patternSweep').checked = true;
      document.getElementById('patternPulse').checked = true;
      document.getElementById('patternDrift').checked = true;
      document.getElementById('patternBurst').checked = true;
      document.getElementById('patternWave').checked = false;
      document.getElementById('patternPendulum').checked = false;
      document.getElementById('patternSpiral').checked = false;
      document.getElementById('patternCalm').checked = false;
      document.getElementById('patternBruteForce').checked = true;
      document.getElementById('patternLiberator').checked = true;
      updatePatternToggleButton();
    });
    
    // Add listeners to individual pattern checkboxes to update toggle button
    const patternIds = [
      'patternZigzag', 'patternSweep', 'patternPulse', 'patternDrift',
      'patternBurst', 'patternWave', 'patternPendulum', 'patternSpiral',
      'patternCalm', 'patternBruteForce', 'patternLiberator'
    ];
    patternIds.forEach(id => {
      document.getElementById(id).addEventListener('change', updatePatternToggleButton);
    });
    
    document.getElementById('btnSkipLine').addEventListener('click', function() {
      sendCommand('skipSequenceLine', {});
    });
    
    // Modal handlers
    document.getElementById('editLineForm').addEventListener('submit', saveLineEdit);
    document.getElementById('btnCancelEdit').addEventListener('click', closeEditModal);
    document.getElementById('btnCloseModal').addEventListener('click', closeEditModal);
    
    // Movement type radio buttons
    document.getElementById('editTypeVaet').addEventListener('change', updateMovementTypeFields);
    document.getElementById('editTypeOsc').addEventListener('change', updateMovementTypeFields);
    document.getElementById('editTypeChaos').addEventListener('change', updateMovementTypeFields);
    document.getElementById('editTypeCalibration').addEventListener('change', updateMovementTypeFields);
    
    // Enforce numeric input constraints on all number fields (includes real-time validation)
    function enforceNumericConstraints(input) {
      // Filter invalid characters after input AND trigger validation
      input.addEventListener('input', function(e) {
        const oldValue = this.value;
        // Allow: digits, decimal point, minus sign
        // Remove all non-numeric characters except . and -
        let newValue = this.value.replace(/[^\d.-]/g, '');
        
        // Ensure only one decimal point
        const parts = newValue.split('.');
        if (parts.length > 2) {
          newValue = parts[0] + '.' + parts.slice(1).join('');
        }
        
        // Ensure minus only at start
        if (newValue.indexOf('-') > 0) {
          newValue = newValue.replace(/-/g, '');
        }
        
        // Update value if changed
        if (newValue !== oldValue) {
          this.value = newValue;
        }
        
        // Trigger real-time validation (red border + error messages)
        // Use setTimeout to ensure value is updated before validation
        setTimeout(function() {
          if (typeof validateEditForm === 'function') {
            validateEditForm();
          }
        }, 10);
      });
      
      // Enforce min/max on blur
      input.addEventListener('blur', function() {
        const min = parseFloat(this.getAttribute('min'));
        const max = parseFloat(this.getAttribute('max'));
        const val = parseFloat(this.value);
        
        if (!isNaN(min) && val < min) {
          this.value = min;
          validateEditForm();
        }
        if (!isNaN(max) && val > max) {
          this.value = max;
          validateEditForm();
        }
      });
    }
    
    // Apply numeric constraints to all number inputs in edit modal
    const numericInputs = [
      'editStartPos', 'editDistance', 'editSpeedFwd', 'editSpeedBack', 'editDecelZone',
      'editOscCenter', 'editOscAmplitude', 'editOscFrequency',
      'editOscRampInDur', 'editOscRampOutDur',
      'editChaosCenter', 'editChaosAmplitude', 'editChaosSpeed', 'editChaosCraziness',
      'editChaosDuration', 'editChaosSeed',
      'editCycles', 'editPause'
    ];
    numericInputs.forEach(id => {
      const input = document.getElementById(id);
      if (input) enforceNumericConstraints(input);
    });
    
    // Apply same numeric constraints to MAIN CONTROLS (classic modes)
    const mainNumericInputs = [
      // VA-ET-VIENT
      'startPosition', 'distance', 'speedUnified', 'speedForward', 'speedBackward',
      'decelZone', 'decelEffect',
      // OSCILLATION
      'oscCenterPosition', 'oscAmplitude', 'oscFrequency', 'oscSpeed',
      'oscRampInDuration', 'oscRampOutDuration',
      // CHAOS
      'chaosCenter', 'chaosAmplitude', 'chaosSpeed', 'chaosCraziness',
      'chaosDuration', 'chaosSeed'
    ];
    mainNumericInputs.forEach(id => {
      const input = document.getElementById(id);
      if (input) enforceNumericConstraints(input);
    });
    
    // Close modal on outside click
    document.getElementById('editLineModal').addEventListener('click', function(e) {
      if (e.target === this) {
        closeEditModal();
      }
    });
    
    // Update effect value display in modal
    document.getElementById('editDecelEffect').addEventListener('input', function() {
      document.getElementById('editEffectValue').textContent = this.value;
    });
    
    // ============================================================================
    // DECELERATION ZONE HANDLERS
    // ============================================================================
    
    // ============================================================================
    // DECELERATION ZONE HELPERS
    // ============================================================================
    
    // JavaScript implementation of C++ calculateSlowdownFactor()
    // Matches the exact curve formulas from the firmware
    function calculateSlowdownFactorJS(zoneProgress, maxSlowdown, mode) {
      let factor = 1.0;
      
      switch(mode) {
        case 0: // DECEL_LINEAR
          factor = 1.0 + (1.0 - zoneProgress) * (maxSlowdown - 1.0);
          break;
          
        case 1: // DECEL_SINE
          const smoothProgress = (1.0 - Math.cos(zoneProgress * Math.PI)) / 2.0;
          factor = 1.0 + (1.0 - smoothProgress) * (maxSlowdown - 1.0);
          break;
          
        case 2: // DECEL_TRIANGLE_INV
          const invProgressTri = 1.0 - zoneProgress;
          const curvedTri = invProgressTri * invProgressTri;
          factor = 1.0 + curvedTri * (maxSlowdown - 1.0);
          break;
          
        case 3: // DECEL_SINE_INV
          const invProgressSin = 1.0 - zoneProgress;
          const curvedSin = Math.sin(invProgressSin * Math.PI / 2.0);
          factor = 1.0 + curvedSin * (maxSlowdown - 1.0);
          break;
          
        default:
          factor = 1.0 + (1.0 - zoneProgress) * (maxSlowdown - 1.0);
      }
      
      return factor;
    }
    
    // ============================================================================
    // DECELERATION ZONE EVENT LISTENERS
    // ============================================================================
    
    // Show/hide decel zone options
    // Deceleration section toggle (replaces checkbox)
    function toggleDecelSection() {
      const section = document.getElementById('decelSection');
      const headerText = document.getElementById('decelHeaderText');
      const isCollapsed = section.classList.contains('collapsed');
      
      section.classList.toggle('collapsed');
      
      if (isCollapsed) {
        // Expanding = activating
        headerText.textContent = 'üéØ D√©c√©l√©ration - activ√©e';
        sendDecelConfig();
        drawDecelPreview();
      } else {
        // Collapsing = deactivating
        headerText.textContent = 'üéØ D√©c√©l√©ration - d√©sactiv√©e';
        // Send config with zones disabled
        sendCommand('setDecelZone', {
          enabled: false
        });
      }
    }
    
    // Decel zone presets
    document.querySelectorAll('[data-decel-zone]').forEach(btn => {
      btn.addEventListener('click', function() {
        const value = this.getAttribute('data-decel-zone');
        document.getElementById('decelZoneMM').value = value;
        
        // Update active state
        document.querySelectorAll('[data-decel-zone]').forEach(b => b.classList.remove('active'));
        this.classList.add('active');
        
        sendDecelConfig();
        drawDecelPreview();
      });
    });
    
    // Decel zone start/end checkboxes
    document.getElementById('decelZoneStart').addEventListener('change', function() {
      sendDecelConfig();
      drawDecelPreview();
    });
    
    document.getElementById('decelZoneEnd').addEventListener('change', function() {
      sendDecelConfig();
      drawDecelPreview();
    });
    
    // Zone size input
    document.getElementById('decelZoneMM').addEventListener('input', function() {
      sendDecelConfig();
      drawDecelPreview();
    });
    
    // Effect percent slider
    document.getElementById('decelEffectPercent').addEventListener('input', function() {
      document.getElementById('effectValue').textContent = this.value + '%';
      sendDecelConfig();
      drawDecelPreview();
    });
    
    // Deceleration mode select dropdown
    document.getElementById('decelModeSelect').addEventListener('change', function() {
      sendDecelConfig();
      drawDecelPreview();
    });
    
    // Send deceleration configuration to ESP32
    function sendDecelConfig() {
      const section = document.getElementById('decelSection');
      const isEnabled = !section.classList.contains('collapsed');
      
      const zoneMM = parseFloat(document.getElementById('decelZoneMM').value) || 50;
      
      const config = {
        enabled: isEnabled,
        enableStart: document.getElementById('decelZoneStart').checked,
        enableEnd: document.getElementById('decelZoneEnd').checked,
        zoneMM: zoneMM,
        effectPercent: parseFloat(document.getElementById('decelEffectPercent').value) || 75,
        mode: parseInt(document.getElementById('decelModeSelect')?.value || 1)
      };
      
      // Store requested zone value for comparison
      AppState.lastDecelZoneRequest = zoneMM;
      
      sendCommand('setDecelZone', config);
    }
    
    // Draw deceleration curve preview on canvas
    function drawDecelPreview() {
      const canvas = document.getElementById('decelPreview');
      if (!canvas) return;
      
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      const padding = 20;
      const plotWidth = width - 2 * padding;
      const plotHeight = height - 2 * padding;
      
      // Clear canvas
      ctx.clearRect(0, 0, width, height);
      
      // Get current config
      const section = document.getElementById('decelSection');
      const enabled = !section.classList.contains('collapsed');
      const enableStart = document.getElementById('decelZoneStart').checked;
      const enableEnd = document.getElementById('decelZoneEnd').checked;
      const zoneMM = parseFloat(document.getElementById('decelZoneMM').value) || 50;
      const effectPercent = parseFloat(document.getElementById('decelEffectPercent').value) || 75;
      const mode = parseInt(document.getElementById('decelModeSelect')?.value || 1);
      
      if (!enabled) {
        ctx.font = '14px Arial';
        ctx.fillStyle = '#999';
        ctx.textAlign = 'center';
        ctx.fillText('D√©c√©l√©ration d√©sactiv√©e', width / 2, height / 2);
        return;
      }
      
      // Assume a movement amplitude of 150mm for preview
      const movementAmplitude = 150;
      const maxSlowdown = 1.0 + (effectPercent / 100.0) * 9.0;  // 1√ó to 10√ó
      
      // Draw axes
      ctx.strokeStyle = '#ccc';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(padding, padding);
      ctx.lineTo(padding, height - padding);
      ctx.lineTo(width - padding, height - padding);
      ctx.stroke();
      
      // Draw curve
      ctx.strokeStyle = '#4CAF50';
      ctx.lineWidth = 2;
      ctx.beginPath();
      
      for (let x = 0; x <= plotWidth; x++) {
        const positionMM = (x / plotWidth) * movementAmplitude;
        let speedFactor = 1.0;  // Normal speed
        
        // Check START zone
        if (enableStart && positionMM <= zoneMM) {
          const zoneProgress = positionMM / zoneMM;
          speedFactor = calculateSlowdownFactorJS(zoneProgress, maxSlowdown, mode);
        }
        // Check END zone
        if (enableEnd && positionMM >= (movementAmplitude - zoneMM)) {
          const distanceFromEnd = movementAmplitude - positionMM;
          const zoneProgress = distanceFromEnd / zoneMM;
          speedFactor = calculateSlowdownFactorJS(zoneProgress, maxSlowdown, mode);
        }
        
        // Convert speed factor to Y coordinate (inverted: slower = higher on graph)
        const normalizedSpeed = 1.0 / speedFactor;  // 1.0 = normal, 0.1 = 10√ó slower
        const y = height - padding - (normalizedSpeed * plotHeight);
        
        if (x === 0) {
          ctx.moveTo(padding + x, y);
        } else {
          ctx.lineTo(padding + x, y);
        }
      }
      
      ctx.stroke();
      
      // Draw zone boundaries
      if (enableStart || enableEnd) {
        ctx.setLineDash([5, 3]);
        ctx.strokeStyle = '#FF9800';
        ctx.lineWidth = 1;
        
        if (enableStart) {
          const startX = padding + (zoneMM / movementAmplitude) * plotWidth;
          ctx.beginPath();
          ctx.moveTo(startX, padding);
          ctx.lineTo(startX, height - padding);
          ctx.stroke();
        }
        
        if (enableEnd) {
          const endX = padding + ((movementAmplitude - zoneMM) / movementAmplitude) * plotWidth;
          ctx.beginPath();
          ctx.moveTo(endX, padding);
          ctx.lineTo(endX, height - padding);
          ctx.stroke();
        }
        
        ctx.setLineDash([]);
      }
      
      // Draw labels
      ctx.font = '10px Arial';
      ctx.fillStyle = '#666';
      ctx.textAlign = 'center';
      ctx.fillText('D√©part', padding, height - 5);
      ctx.fillText('Arriv√©e', width - padding, height - 5);
      
      // Draw speed indicators
      ctx.textAlign = 'left';
      ctx.fillText('Rapide', padding + 5, padding + 10);
      ctx.fillText('Lent', padding + 5, height - padding - 5);
    }
    
    connectWebSocket();
    loadPlaylists();  // Load playlist presets from backend
  </script>
</body>
</html>
