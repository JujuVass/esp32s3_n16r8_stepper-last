<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Stepper Controller</title>
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>âš™ï¸</text></svg>">
  <link rel="stylesheet" href="/css/styles.css">
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
</head>
<body>
  <!-- Calibration Overlay -->
  <div class="overlay" id="calibrationOverlay">
    <div class="overlay-content">
      <div class="overlay-icon">ğŸ”</div>
      <div class="overlay-title">Calibration en cours...</div>
      <div class="overlay-message">Veuillez patienter pendant la recherche des limites</div>
      <div class="spinner"></div>
      <div style="color: #999; font-size: 14px; margin-top: 15px;">
        Ne pas interrompre le processus
      </div>
    </div>
  </div>

  <!-- Reboot Overlay -->
  <div class="overlay" id="rebootOverlay">
    <div class="overlay-content">
      <div class="overlay-icon">ğŸ”„</div>
      <div class="overlay-title">RedÃ©marrage en cours...</div>
      <div class="overlay-message" id="rebootMessage">Reconnexion automatique dans quelques secondes</div>
      <div class="spinner"></div>
      <div id="rebootStatus" style="color: #999; font-size: 14px; margin-top: 15px;">
        Veuillez patienter (~10-15 secondes)
      </div>
    </div>
  </div>

  <!-- Playlist Management Modal -->
  <div class="modal" id="playlistModal" onclick="closePlaylistModalOnOverlayClick(event)">
    <div class="modal-content" style="max-width: 650px; max-height: 85vh; display: flex; flex-direction: column;" onclick="event.stopPropagation()">
      <div class="modal-title">ğŸ“‹ Playlist - <span id="playlistModalTitle">Mode</span></div>
      
      <!-- Sticky Current Config Preview -->
      <div id="playlistCurrentConfig" style="background: #E3F2FD; padding: 12px; border-radius: 6px; margin-bottom: 12px; flex-shrink: 0;">
        <div style="font-weight: 500; margin-bottom: 8px; font-size: 13px;">âš™ï¸ Configuration actuelle:</div>
        <div id="playlistCurrentConfigContent" style="font-size: 12px; color: #555;"></div>
        <button class="button btn-success" id="btnAddCurrentToPlaylist" style="margin-top: 8px; width: 100%; padding: 8px; font-size: 13px;">
          â• Ajouter Ã  la playlist
        </button>
      </div>
      
      <!-- Presets List with Scroll -->
      <div style="flex: 1; overflow-y: auto; overflow-x: visible; border-top: 2px solid #ddd; padding-top: 12px; min-height: 0;">
        <div style="font-weight: 500; margin-bottom: 10px; font-size: 13px; padding: 0 5px;">
          ğŸ“¦ Presets sauvegardÃ©s (<span id="playlistCount">0</span>/20):
        </div>
        
        <!-- Search Input -->
        <input type="text" id="playlistSearchInput" placeholder="ğŸ” Rechercher un preset..." 
               oninput="filterPlaylistPresets(this.value)"
               style="width: 90%; margin: 0 0 10px 0; padding: 8px; border: 2px solid #ddd; border-radius: 6px; font-size: 12px;">
        
        <div id="playlistPresetsList" style="padding-right: 5px; overflow: visible;">
          <!-- Presets will be dynamically inserted here -->
          <div style="color: #999; font-style: italic; padding: 20px; text-align: center; font-size: 12px;">
            Aucun preset sauvegardÃ©
          </div>
        </div>
      </div>
      
      <!-- Sticky Close Button -->
      <div style="border-top: 2px solid #ddd; padding: 12px 0 0 0; margin-top: 12px; background: white; flex-shrink: 0;">
        <button class="button btn-secondary" onclick="closePlaylistModal()" style="width: 100%; padding: 10px; font-size: 14px;">
          âœ–ï¸ Fermer
        </button>
      </div>
    </div>
  </div>

  <!-- Playlist Tooltip Overlay -->
  <div id="playlistTooltipOverlay"></div>

  <!-- Mode Change Confirmation Modal -->
  <div class="modal" id="modeChangeModal">
    <div class="modal-content">
      <div class="modal-title">âš ï¸ Changement de mode</div>
      <div class="modal-message" id="modalMessage">
        Une opÃ©ration est en cours. Le changement de mode va arrÃªter le mouvement et lancer une recalibration.
        <br><br>
        <strong>Voulez-vous continuer ?</strong>
      </div>
      <div style="margin: 20px 0; padding: 15px; background: #FFF3E0; border-radius: 5px; border: 2px solid #FF9800;">
        <label style="display: flex; align-items: center; justify-content: center; cursor: pointer; font-weight: normal;">
          <input type="checkbox" id="bypassCalibrationCheckbox" checked style="margin-right: 10px; width: 18px; height: 18px; cursor: pointer;">
          <span style="color: #FF9800; font-weight: bold;">/!\ Bypasser la calibration complÃ¨te</span>
        </label>
        <div style="font-size: 12px; color: #666; margin-top: 8px; text-align: center;">
          (Retour rapide au contact dÃ©but uniquement)
        </div>
      </div>
      <div class="modal-buttons">
        <button class="button btn-danger" onclick="cancelModeChange()">Annuler</button>
        <button class="button btn-success" onclick="confirmModeChange()">Confirmer</button>
      </div>
    </div>
  </div>

  <!-- Stop Confirmation Modal -->
  <div class="modal" id="stopModal">
    <div class="modal-content">
      <div class="modal-title">â¹ï¸ ArrÃªter le mouvement</div>
      <div class="modal-message">
        Voulez-vous arrÃªter le mouvement en cours ?
      </div>
      <div style="margin: 20px 0; padding: 15px; background: #E3F2FD; border-radius: 5px; border: 2px solid #2196F3;">
        <label style="display: flex; align-items: center; justify-content: center; cursor: pointer; font-weight: normal;">
          <input type="checkbox" id="returnToStartCheckbox" checked style="margin-right: 10px; width: 18px; height: 18px; cursor: pointer;">
          <span style="color: #2196F3; font-weight: bold;">ğŸ  Retour Ã  la position initiale (0mm)</span>
        </label>
        <div style="font-size: 12px; color: #666; margin-top: 8px; text-align: center;">
          (DÃ©sactiver pour rester Ã  la position actuelle)
        </div>
      </div>
      <div class="modal-buttons">
        <button class="button btn-secondary" onclick="cancelStopModal()">Annuler</button>
        <button class="button btn-danger" onclick="confirmStopModal()">â¹ï¸ ArrÃªter</button>
      </div>
    </div>
  </div>

  <!-- Modal for Sequencer Limit Warning -->
  <div class="modal" id="sequencerLimitModal">
    <div class="modal-content">
      <div class="modal-title">âš ï¸ Passage en Mode SÃ©quenceur</div>
      <div class="modal-message">
        <div style="background: #E3F2FD; padding: 15px; border-radius: 8px; border-left: 4px solid #2196F3; margin-bottom: 15px;">
          <div style="font-weight: bold; color: #1976D2; margin-bottom: 8px;">ğŸ“‹ Mode Expert ActivÃ©</div>
          <div style="font-size: 14px; color: #555;">
            La limitation de course active sera <strong>DÃ‰SACTIVÃ‰E</strong> :
          </div>
        </div>
        
        <div style="display: grid; grid-template-columns: auto 1fr; gap: 10px; margin: 15px 0; padding: 15px; background: #FFF3E0; border-radius: 8px;">
          <div style="font-weight: bold; color: #FF9800;">â€¢ Actuel :</div>
          <div id="seqModalCurrentLimit" style="color: #FF9800; font-weight: bold;">--</div>
          <div style="font-weight: bold; color: #4CAF50;">â€¢ AprÃ¨s :</div>
          <div id="seqModalAfterLimit" style="color: #4CAF50; font-weight: bold;">--</div>
        </div>
        
        <div style="background: #F5F5F5; padding: 12px; border-radius: 8px; margin-bottom: 15px;">
          <div style="font-weight: bold; margin-bottom: 8px;">ğŸ”§ Raison :</div>
          <div style="font-size: 13px; color: #666; line-height: 1.5;">
            Le sÃ©quenceur peut contenir des lignes de calibration qui rÃ©initialisent cette limite.
          </div>
        </div>
        
        <div style="background: #E8F5E9; padding: 12px; border-radius: 8px; border-left: 4px solid #4CAF50;">
          <div style="font-weight: bold; color: #2E7D32; margin-bottom: 5px;">ğŸ’¡ En mode sÃ©quenceur :</div>
          <div style="font-size: 13px; color: #555;">
            Vous avez le <strong>contrÃ´le total</strong> des valeurs de chaque ligne.
          </div>
        </div>
        
        <div style="margin-top: 20px; text-align: center; font-weight: bold; color: #333;">
          Continuer ?
        </div>
      </div>
      <div class="modal-buttons">
        <button class="button btn-danger" onclick="cancelSequencerLimitChange()">Annuler</button>
        <button class="button btn-success" onclick="confirmSequencerLimitChange()">Confirmer</button>
      </div>
    </div>
  </div>

  <div class="container">
    <!-- Common Status (COMPACT VERSION) -->
    <div class="status-compact" style="background:white; border-radius:8px; box-shadow:0 2px 8px rgba(0,0,0,0.1); margin-bottom:15px; overflow:hidden;">
      
      <!-- Header Row: Ã‰tat + Actions -->
      <div style="display:flex; justify-content:space-between; align-items:center; padding:8px 15px; background:#E3F2FD; border-bottom:1px solid #BBDEFB;">
        <span style="font-weight:bold; font-size:15px; color:#1976D2;">
          Ã‰tat: <span id="state" style="color:#333;">Initialisation...</span>
        </span>
        <div style="display:flex; gap:6px;">
          <button class="btn-compact btn-primary" id="btnCalibrateCommon" title="Calibrer les limites">ğŸ” Calib</button>
          <button class="btn-compact btn-info" id="btnShowLogs" title="Afficher logs">ğŸ“‹ Logs</button>
          
          <button class="btn-compact btn-success" id="btnShowStats" title="Afficher statistiques">ğŸ“Š Stats</button>
          <button class="btn-compact" id="btnShowSystem" title="Afficher statistiques systÃ¨me" style="background: #2196F3; color: white;">âš™ï¸ Sys</button>
        </div>
      </div>
      
      <!-- Row 2: Position + Course -->
      <div style="padding:6px 15px; font-size:13px; border-bottom:1px solid #f0f0f0;">
        ğŸ“ <strong>Position:</strong> <span id="position">0.0 mm (0 steps)</span>
        &nbsp;&nbsp;â€¢&nbsp;&nbsp;
        <strong>Course:</strong> <span id="totalDist">-- mm</span>
        <button id="btnConfigMaxDist" class="btn-icon" title="Limiter course" style="padding:2px 6px; font-size:13px; background:transparent; border:1px solid #ddd; border-radius:3px; cursor:pointer; margin-left:4px;">âš™ï¸</button>
      </div>
      
      <!-- Max Distance Config Panel (collapsible) -->
      <div id="maxDistConfigPanel" style="display:none; padding:10px 15px; background:#FFF3E0; border-bottom:1px solid #FFE0B2;">
        <div style="font-weight:bold; color:#FF9800; margin-bottom:6px; font-size:12px;">âš™ï¸ Limitation de course</div>
        <div style="font-size:11px; color:#666; margin-bottom:8px;">
          â„¹ï¸ Limite la zone utilisable sans recalibrer
        </div>
        <div style="display:flex; align-items:center; gap:8px; margin-bottom:6px;">
          <span style="font-size:11px; font-weight:bold; min-width:45px;">Limite:</span>
          <input type="range" id="maxDistLimitSlider" min="50" max="100" value="100" step="1" style="flex:1; height:6px;" disabled>
          <span id="maxDistLimitValue" style="font-weight:bold; font-size:12px; min-width:40px;">100%</span>
          <span id="maxDistLimitMM" style="color:#666; font-size:11px; min-width:70px;">(-- mm)</span>
        </div>
        <div style="display:flex; gap:6px;">
          <button id="btnApplyMaxDistLimit" class="btn-compact btn-success" disabled>âœ… OK</button>
          <button id="btnCancelMaxDistLimit" class="btn-compact btn-secondary">âœ• Annuler</button>
        </div>
        <div style="font-size:10px; color:#d32f2f; margin-top:6px; display:none;" id="maxDistLimitWarning">
          âš ï¸ Modification en Ã©tat PRÃŠT uniquement
        </div>
      </div>
      
      <!-- Row 3: Vitesses -->
      <div style="padding:6px 15px; font-size:13px; border-bottom:1px solid #f0f0f0;">
        âš¡ <strong>Vitesse:</strong> <span id="currentSpeed">â†—ï¸ --  â€¢  â†™ï¸ --</span>
        <span style="color:#999; font-size:11px; margin-left:8px;">(-- c/min)</span>
      </div>
      
      <!-- Row 4: Distance + Progress Bar (colonnes fixes) -->
      <div style="padding:6px 15px; font-size:13px; display:grid; grid-template-columns: 280px 1fr 50px; gap:10px; align-items:center; border-bottom:1px solid #f0f0f0;">
        <div style="white-space:nowrap;">
          ğŸ“Š <strong>Distance:</strong> <span id="milestoneIcon" style="font-size: 20px; margin-left: 8px; cursor: help; display: inline-block; transition: transform 0.3s;" title=""></span> <span id="totalTraveled">0.000 m</span> <button class="btn-icon" id="btnResetDistanceCommon" title="RÃ©initialiser distance" style="padding:2px 6px; font-size:13px; background:transparent; border:1px solid #ddd; border-radius:3px; cursor:pointer; margin-left:4px;">â†»</button>
          
        </div>
        <div style="height:8px; background:#e0e0e0; border-radius:4px; overflow:hidden;">
          <div id="progressMini" style="width:0%; height:100%; background:linear-gradient(90deg,#2196F3,#21CBF3); transition:width 0.3s;"></div>
        </div>
        <span id="progressPct" style="font-weight:bold; font-size:12px; text-align:right;">0.0%</span>
      </div>
      
      <!-- Pending Changes Alert (conditional) -->
      <div id="pendingChanges" style="display:none; padding:6px 15px; background:#FFF3E0; color:#FF9800; font-weight:bold; font-size:12px; border-bottom:1px solid #FFE0B2;">
        â³ Changements en attente (fin de cycle)
      </div>
      
    </div>

    <!-- Logs Panel (hidden by default) -->
    <div id="logsPanel" style="display: none; background: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); margin-bottom: 15px;">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; border-bottom: 2px solid #2196F3; padding-bottom: 8px;">
        <h3 style="margin: 0; color: #2196F3; font-size: 18px;">ğŸ“‹ Logs & Debug</h3>
        <button id="btnCloseLogs" style="background: #f44336; color: white; border: none; padding: 4px 10px; border-radius: 5px; cursor: pointer; font-size: 14px;">âœ•</button>
      </div>

      <!-- Log Console -->
      <div style="margin-bottom: 12px;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
          <label style="font-weight: bold; color: #333; font-size: 13px;">Console temps rÃ©el:</label>
          <div style="display: flex; gap: 6px;">
            <button class="button btn-secondary" id="btnClearLogsPanel" style="padding: 4px 10px; font-size: 11px;">ğŸ—‘ï¸ Effacer</button>
          </div>
        </div>
        <div id="logConsolePanel" style="height: 180px; overflow: auto; background: #1e1e1e; color: #d4d4d4; padding: 8px; border-radius: 4px; font-family: 'Courier New', monospace; font-size: 11px; white-space: pre-wrap; border: 1px solid #333;">(les logs apparaÃ®tront ici...)</div>
      </div>

      <!-- Debug Controls -->
      <div style="background: #f5f5f5; padding: 10px; border-radius: 6px; margin-bottom: 12px;">
        <label style="font-weight: bold; color: #333; display: block; margin-bottom: 8px; font-size: 13px;">âš™ï¸ Niveau de debug:</label>
        <div style="display: flex; gap: 8px; align-items: center;">
          <label style="display: flex; align-items: center; cursor: pointer;">
            <input type="checkbox" id="debugLevelCheckbox" style="width: 16px; height: 16px; margin-right: 6px;">
            <span style="font-size: 12px;">Activer logs DEBUG (verbose)</span>
          </label>
          <span style="color: #666; font-size: 11px; margin-left: auto;">âš ï¸ Peut ralentir</span>
        </div>
      </div>

      <!-- Historical Logs -->
      <div style="background: #fff3cd; padding: 10px; border-radius: 6px; border-left: 4px solid #ffc107;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
          <label style="font-weight: bold; color: #856404; font-size: 13px;">ğŸ“š Historique des logs:</label>
          <button class="button btn-danger" id="btnClearAllLogFiles" style="padding: 4px 10px; font-size: 11px;">ğŸ—‘ï¸ Nettoyer tout</button>
        </div>
        <div id="logFilesList" style="max-height: 130px; overflow-y: auto; background: white; padding: 8px; border-radius: 4px; border: 1px solid #ddd;">
          <div style="color: #999; font-style: italic; font-size: 11px;">Chargement de la liste...</div>
        </div>
      </div>
    </div>

    <!-- Statistics Panel -->
    <div id="statsPanel" style="display: none; background: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); margin-bottom: 15px;">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; border-bottom: 2px solid #4CAF50; padding-bottom: 8px;">
        <h3 style="margin: 0; color: #4CAF50; font-size: 18px;">ğŸ“Š Statistiques</h3>
        <button id="btnCloseStats" style="background: #f44336; color: white; border: none; padding: 4px 10px; border-radius: 5px; cursor: pointer; font-size: 14px;">âœ•</button>
      </div>

      <!-- Stats Table -->
      <div style="margin-bottom: 20px; overflow-x: auto;">
        <table id="statsTable" style="width: 100%; border-collapse: collapse; font-size: 13px;">
          <thead>
            <tr style="background: #f5f5f5; border-bottom: 2px solid #4CAF50;">
              <th style="padding: 8px; text-align: left; font-weight: bold;">Date</th>
              <th style="padding: 8px; text-align: center; font-weight: bold;">Jour</th>
              <th style="padding: 8px; text-align: center; font-weight: bold;">ğŸ†</th>
              <th style="padding: 8px; text-align: right; font-weight: bold;">Distance</th>
            </tr>
          </thead>
          <tbody id="statsTableBody">
            <tr>
              <td colspan="4" style="padding: 20px; text-align: center; color: #999; font-style: italic;">Aucune statistique disponible</td>
            </tr>
          </tbody>
          <tfoot>
            <tr style="background: #e8f5e9; border-top: 2px solid #4CAF50; font-weight: bold;">
              <td style="padding: 10px;">TOTAL</td>
              <td style="padding: 10px; text-align: center;">ğŸ†</td>
              <td id="statsTotalMilestone" style="padding: 10px; text-align: center; font-size: 18px;">ğŸ¯</td>
              <td id="statsTotalDistance" style="padding: 10px; text-align: right; color: #4CAF50; font-size: 15px;">0 km</td>
            </tr>
          </tfoot>
        </table>
      </div>

      <!-- Stats Action Buttons -->
      <div style="margin-bottom: 20px; text-align: center; display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
        <button id="btnExportStats" class="button" style="padding: 8px 20px; font-size: 13px; background: #4CAF50; color: white;">
          ğŸ“¥ Exporter
        </button>
        <button id="btnImportStats" class="button" style="padding: 8px 20px; font-size: 13px; background: #2196F3; color: white;">
          ğŸ“¤ Importer
        </button>
        <button id="btnClearStats" class="button btn-danger" style="padding: 8px 20px; font-size: 13px;">
          ğŸ—‘ï¸ Effacer tout
        </button>
      </div>
      
      <!-- Hidden file input for import -->
      <input type="file" id="statsFileInput" accept=".json" style="display: none;">

      <!-- Histogram -->
      <div style="background: #f9f9f9; padding: 12px; border-radius: 6px; border: 1px solid #ddd;">
        <h4 style="margin: 0 0 12px 0; color: #333; font-size: 14px;">ğŸ“ˆ Historique (3 mois glissants)</h4>
        <canvas id="statsChart" style="max-height: 250px;"></canvas>
      </div>
    </div>

    <!-- System Stats Panel (hidden by default like Stats panel) -->
    <div id="systemPanel" style="display: none; background: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); margin-bottom: 15px;">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; border-bottom: 2px solid #2196F3; padding-bottom: 8px;">
        <h3 style="margin: 0; color: #2196F3; font-size: 18px;">âš™ï¸ SystÃ¨me</h3>
        <button id="btnCloseSystem" style="background: #f44336; color: white; border: none; padding: 4px 10px; border-radius: 5px; cursor: pointer; font-size: 14px;">âœ•</button>
      </div>

      <!-- System Stats Grid -->
      <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; font-size: 13px;">
        <div style="background: #f5f5f5; padding: 10px; border-radius: 6px;">
          <div style="color: #666; font-size: 11px; margin-bottom: 4px;">CPU</div>
          <div id="sysCpuFreq" style="font-weight: bold; color: #333; font-size: 15px;">-- MHz</div>
        </div>
        
        <div style="background: #f5f5f5; padding: 10px; border-radius: 6px;">
          <div style="color: #666; font-size: 11px; margin-bottom: 4px;">ğŸŒ¡ï¸ TempÃ©rature</div>
          <div id="sysTemp" style="font-weight: bold; color: #333; font-size: 15px;">-- Â°C</div>
        </div>
        
        <div style="background: #f5f5f5; padding: 10px; border-radius: 6px;">
          <div style="color: #666; font-size: 11px; margin-bottom: 4px;">ğŸ’¾ RAM</div>
          <div id="sysRam" style="font-weight: bold; color: #333; font-size: 15px;">-- KB libre</div>
          <div id="sysRamPercent" style="font-size: 11px; color: #666; margin-top: 2px;">--% utilisÃ©</div>
        </div>
        
        <div style="background: #f5f5f5; padding: 10px; border-radius: 6px;">
          <div style="color: #666; font-size: 11px; margin-bottom: 4px;">ğŸ§  PSRAM</div>
          <div id="sysPsram" style="font-weight: bold; color: #333; font-size: 15px;">-- MB libre</div>
          <div id="sysPsramPercent" style="font-size: 11px; color: #666; margin-top: 2px;">--% utilisÃ©</div>
        </div>
        
        <div style="background: #f5f5f5; padding: 10px; border-radius: 6px;">
          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px;">
            <div style="color: #666; font-size: 11px;">ğŸ“¶ WiFi</div>
            <button id="btnRefreshWifi" style="background: #2196F3; color: white; border: none; padding: 3px 8px; border-radius: 4px; cursor: pointer; font-size: 10px;" title="Reconnecter le WiFi">
              ğŸ”„
            </button>
          </div>
          <div id="sysWifi" style="font-weight: bold; color: #333; font-size: 15px;">-- dBm</div>
          <div id="sysWifiQuality" style="font-size: 11px; color: #666; margin-top: 2px;">--</div>
        </div>
        
        <div style="background: #f5f5f5; padding: 10px; border-radius: 6px;">
          <div style="color: #666; font-size: 11px; margin-bottom: 4px;">âš¡ Uptime</div>
          <div id="sysUptime" style="font-weight: bold; color: #333; font-size: 15px;">--</div>
        </div>
      </div>

      <!-- Logging Configuration -->
      <div style="margin-top: 15px; background: #f5f5f5; padding: 12px; border-radius: 6px;">
        <div style="font-weight: bold; color: #333; font-size: 13px; margin-bottom: 10px;">ğŸ“‹ Configuration des logs</div>
        
        <!-- Enable/Disable Logging -->
        <div style="margin-bottom: 10px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; user-select: none;">
            <input type="checkbox" id="chkLoggingEnabled" checked style="width: 18px; height: 18px; cursor: pointer;">
            <span style="font-size: 13px; color: #333;">Activer les logs (console + fichiers)</span>
          </label>
          <div style="font-size: 11px; color: #666; margin-left: 26px; margin-top: 4px;">
            âš ï¸ DÃ©sactiver rÃ©duit l'utilisation CPU mais supprime tous les logs
          </div>
        </div>
        
        <!-- Debug Level Toggle -->
        <div style="margin-bottom: 4px;">
          <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; user-select: none;">
            <input type="checkbox" id="chkDebugLevel" style="width: 18px; height: 18px; cursor: pointer;">
            <span style="font-size: 13px; color: #333;">Activer logs DEBUG (verbose)</span>
          </label>
          <div style="font-size: 11px; color: #666; margin-left: 26px; margin-top: 4px;">
            â„¹ï¸ Niveau INFO (messages normaux) par dÃ©faut
          </div>
        </div>
      </div>

      <!-- Reboot Button -->
      <div style="margin-top: 15px;">
        <button id="btnReboot" class="button btn-danger" style="width: 100%; padding: 12px; font-size: 14px; font-weight: bold;">
          ğŸ”„ RedÃ©marrer l'ESP32
        </button>
      </div>
    </div>

    <!-- Welcome message (shown before first calibration) -->
    <div class="welcome-message" id="welcomeMessage">
      <h2>ğŸ‘‹ Bienvenue!</h2>
      <p>ğŸ”§ Avant de commencer, veuillez effectuer une calibration pour dÃ©tecter les limites de course.</p>
      <p>ğŸ‘† Cliquez sur le bouton <strong>"ğŸ” Calibrer"</strong> dans la section "Outils communs" ci-dessus.</p>
      <p style="font-size: 14px; opacity: 0.8; margin-top: 20px;">
        âš™ï¸ Les modes de contrÃ´le apparaÃ®tront automatiquement aprÃ¨s la calibration.
      </p>
    </div>

    <!-- Tabs Navigation (after status) -->
    <div class="tabs hidden-until-calibrated" id="tabsContainer">
      <button class="tab active" data-tab="simple">ğŸ”„ Simple</button>
      <button class="tab" data-tab="pursuit">ğŸ¯ Poursuite</button>
      <button class="tab" data-tab="oscillation">ã€°ï¸ Oscillation</button>
      <button class="tab" data-tab="chaos">ğŸ² Chaos</button>
      <button class="tab" data-tab="tableau">ğŸ“‹ SÃ©quenceur</button>
    </div>

    <!-- MODE SIMPLE Tab Content -->
    <div class="tab-content active hidden-until-calibrated" id="tabSimple">
      <div class="controls">
        
      <!-- Position/Distance - 2-Column Grid -->
      <div class="form-row-compact">
        <div class="form-group-compact" style="display: block;">
          <div>
            <label class="label-inline">Position dÃ©part:</label>
            <input type="number" id="startPosition" min="0" step="0.1" value="0" class="input-compact">
            <span class="unit-label">mm</span>
          </div>
          <div style="margin-top: 8px;">
            <button class="preset-btn-sm btn-preset" data-start="0">0mm</button>
            <button class="preset-btn-sm btn-preset" data-start="25">25mm</button>
            <button class="preset-btn-sm btn-preset" data-start="50">50mm</button>
            <button class="preset-btn-sm btn-preset" data-start="75">75mm</button>
            <button class="preset-btn-sm btn-preset" data-start="100">100mm</button>
          </div>
        </div>
        
        <div class="form-group-compact" style="display: block;">
          <div>
            <label class="label-inline">Distance:</label>
            <input type="number" id="distance" min="0" step="0.1" value="50" class="input-compact">
            <span class="unit-label">mm</span>
          </div>
          <div style="margin-top: 8px;">
            <button class="preset-btn-sm btn-preset" data-distance="25">25mm</button>
            <button class="preset-btn-sm btn-preset" data-distance="50">50mm</button>
            <button class="preset-btn-sm btn-preset" data-distance="75">75mm</button>
            <button class="preset-btn-sm btn-preset" data-distance="100">100mm</button>
            <button class="preset-btn-sm btn-preset" data-distance="125">125mm</button>
          </div>
        </div>
      </div>
      
      <!-- SÃ©parateur -->
      <div style="border-top: 1px solid #ddd; margin: 15px 0;"></div>
      
      <!-- Speed Mode Toggle - Radio Buttons -->
      <div class="form-group-compact" style="margin-bottom: 15px;">
        <label class="label-inline">âš™ï¸ Vitesse:</label>
        <div class="radio-inline">
          <label>
            <input type="radio" name="speedMode" id="speedModeUnified" checked>
            UnifiÃ©e
          </label>
          <label>
            <input type="radio" name="speedMode" id="speedModeSeparate">
            SÃ©parÃ©e
          </label>
        </div>
      </div>
      
      <!-- Unified Speed - Single Line -->
      <div id="speedUnifiedGroup" class="speed-control-inline" style="margin-bottom: 12px;">
        <label class="label-inline">Vitesse:</label>
        <input type="number" id="speedUnified" min="0" max="20" step="0.1" value="5" class="input-compact">
        <button class="preset-btn-sm btn-preset" data-speed-unified="0.5" title="Ultra lent">0.5 ğŸŒ</button>
        <button class="preset-btn-sm btn-preset" data-speed-unified="1" title="TrÃ¨s lent">1</button>
        <button class="preset-btn-sm btn-preset" data-speed-unified="2">2</button>
        <button class="preset-btn-sm btn-preset" data-speed-unified="3">3</button>
        <button class="preset-btn-sm btn-preset active" data-speed-unified="5" title="Normal">5 âœ“</button>
        <button class="preset-btn-sm btn-preset" data-speed-unified="10">10</button>
        <button class="preset-btn-sm btn-preset" data-speed-unified="15">15</button>
        <button class="preset-btn-sm btn-preset" data-speed-unified="20" title="Maximum">20 âš¡</button>
      </div>
      
      <!-- Separate Speeds - Stacked -->
      <div id="speedSeparateGroup" style="display: none; margin-bottom: 12px;">
        <div class="speed-control-inline" style="margin-bottom: 8px;">
          <label class="label-inline">Aller:</label>
          <input type="number" id="speedForward" min="0" max="20" step="0.1" value="5" class="input-compact">
          <button class="preset-btn-sm btn-preset" data-speed-forward="0.5">0.5 ğŸŒ</button>
          <button class="preset-btn-sm btn-preset" data-speed-forward="1">1</button>
          <button class="preset-btn-sm btn-preset" data-speed-forward="2">2</button>
          <button class="preset-btn-sm btn-preset" data-speed-forward="3">3</button>
          <button class="preset-btn-sm btn-preset active" data-speed-forward="5">5 âœ“</button>
          <button class="preset-btn-sm btn-preset" data-speed-forward="10">10</button>
          <button class="preset-btn-sm btn-preset" data-speed-forward="15">15</button>
          <button class="preset-btn-sm btn-preset" data-speed-forward="20">20 âš¡</button>
        </div>
        <div class="speed-control-inline">
          <label class="label-inline">Retour:</label>
          <input type="number" id="speedBackward" min="0" max="20" step="0.1" value="5" class="input-compact">
          <button class="preset-btn-sm btn-preset" data-speed-backward="0.5">0.5 ğŸŒ</button>
          <button class="preset-btn-sm btn-preset" data-speed-backward="1">1</button>
          <button class="preset-btn-sm btn-preset" data-speed-backward="2">2</button>
          <button class="preset-btn-sm btn-preset" data-speed-backward="3">3</button>
          <button class="preset-btn-sm btn-preset active" data-speed-backward="5">5 âœ“</button>
          <button class="preset-btn-sm btn-preset" data-speed-backward="10">10</button>
          <button class="preset-btn-sm btn-preset" data-speed-backward="15">15</button>
          <button class="preset-btn-sm btn-preset" data-speed-backward="20">20 âš¡</button>
        </div>
      </div>

      <!-- SÃ©parateur -->
      <div style="border-top: 1px solid #ddd; margin: 15px 0;"></div>

      <!-- Deceleration - Collapsible Section -->
      <div class="section-collapsible collapsed" id="decelSection">
        <div class="section-collapsible-header" onclick="toggleDecelSection()">
          <span class="collapse-icon">â–¼</span> <span id="decelHeaderText">ğŸ¯ DÃ©cÃ©lÃ©ration - dÃ©sactivÃ©e</span>
        </div>
        
        <div class="section-collapsible-content">
          <!-- Zone -->
          <div class="speed-control-inline" style="margin-bottom: 10px;">
            <label class="label-inline">Zone:</label>
            <input type="number" id="decelZoneMM" min="10" max="200" step="5" value="50" class="input-compact">
            <span class="unit-label">mm</span>
            <button class="preset-btn-sm btn-preset" data-decel-zone="10">10</button>
            <button class="preset-btn-sm btn-preset" data-decel-zone="25">25</button>
            <button class="preset-btn-sm btn-preset active" data-decel-zone="50">50</button>
            <button class="preset-btn-sm btn-preset" data-decel-zone="75">75</button>
          </div>
          
          <!-- Mode, Effect, DÃ©but/Fin - All on one line -->
          <div class="speed-control-inline" style="margin-bottom: 10px;">
            <label class="label-inline">Mode:</label>
            <select id="decelModeSelect" style="width: 120px; padding: 6px; font-size: 13px; border: 1px solid #ddd; border-radius: 4px;">
              <option value="0">LinÃ©aire</option>
              <option value="1" selected>SinusoÃ¯dal</option>
              <option value="2">Triangle Inv.</option>
              <option value="3">Sinus Inv.</option>
            </select>
            
            <span style="margin-left: 10px; font-size: 13px; font-weight: 500;">Effet:</span>
            <input type="range" id="decelEffectPercent" min="0" max="100" step="5" value="75" style="width: 100px;">
            <span id="effectValue" style="font-weight: bold; min-width: 35px; font-size: 13px;">75%</span>
            
            <span style="margin-left: 10px; font-size: 13px;">-</span>
            <label style="margin-left: 5px; font-size: 13px;">
              <input type="checkbox" id="decelZoneStart" checked style="margin-right: 3px;">
              DÃ©but
            </label>
            <label style="margin-left: 10px; font-size: 13px;">
              <input type="checkbox" id="decelZoneEnd" checked style="margin-right: 3px;">
              Fin
            </label>
          </div>
          
          <!-- Canvas Preview -->
          <canvas id="decelPreview" class="canvas-compact" width="300" height="100"></canvas>
        </div>
      </div>

      <!-- ===== CYCLE PAUSE SECTION ===== -->
      <div class="section-collapsible collapsed" style="margin-bottom: 20px;">
        <div class="section-collapsible-header" onclick="toggleCyclePauseSection()">
          <span class="collapse-icon">â–¼</span> <span id="cyclePauseHeaderText">â¸ï¸ Pause entre cycles - dÃ©sactivÃ©e</span>
        </div>
        
        <div class="section-collapsible-content">
          <!-- Mode Selection: Fixed / Random -->
          <div class="speed-control-inline" style="margin-bottom: 15px;">
            <label class="label-inline">Mode:</label>
            <label style="margin-right: 15px; font-size: 13px;">
              <input type="radio" name="cyclePauseMode" value="fixed" id="pauseModeFixed" checked style="margin-right: 5px;">
              â±ï¸ Fixe
            </label>
            <label style="font-size: 13px;">
              <input type="radio" name="cyclePauseMode" value="random" id="pauseModeRandom" style="margin-right: 5px;">
              ğŸ² AlÃ©atoire
            </label>
          </div>
          
          <!-- Fixed Mode: Single Duration -->
          <div id="pauseFixedControls" class="speed-control-inline" style="margin-bottom: 10px;">
            <label class="label-inline">DurÃ©e:</label>
            <input type="number" id="cyclePauseDuration" min="0.1" max="60" step="0.1" value="1.5" class="input-compact">
            <span class="unit-label">s</span>
            <button class="preset-btn-sm btn-preset" data-pause-duration="0.5">0.5s</button>
            <button class="preset-btn-sm btn-preset active" data-pause-duration="1.5">1.5s</button>
            <button class="preset-btn-sm btn-preset" data-pause-duration="3">3s</button>
            <button class="preset-btn-sm btn-preset" data-pause-duration="5">5s</button>
            <button class="preset-btn-sm btn-preset" data-pause-duration="10">10s</button>
          </div>
          
          <!-- Random Mode: Min/Max Range -->
          <div id="pauseRandomControls" style="display: none;">
            <div class="speed-control-inline" style="margin-bottom: 10px;">
              <label class="label-inline">Min:</label>
              <input type="number" id="cyclePauseMin" min="0.1" max="60" step="0.1" value="1.5" class="input-compact">
              <span class="unit-label">s</span>
              <button class="preset-btn-sm btn-preset" data-pause-min="0.5">0.5s</button>
              <button class="preset-btn-sm btn-preset active" data-pause-min="1.5">1.5s</button>
              <button class="preset-btn-sm btn-preset" data-pause-min="3">3s</button>
            </div>
            
            <div class="speed-control-inline" style="margin-bottom: 10px;">
              <label class="label-inline">Max:</label>
              <input type="number" id="cyclePauseMax" min="0.1" max="60" step="0.1" value="5.0" class="input-compact">
              <span class="unit-label">s</span>
              <button class="preset-btn-sm btn-preset" data-pause-max="3">3s</button>
              <button class="preset-btn-sm btn-preset active" data-pause-max="5">5s</button>
              <button class="preset-btn-sm btn-preset" data-pause-max="10">10s</button>
              <button class="preset-btn-sm btn-preset" data-pause-max="15">15s</button>
            </div>
          </div>
          
          <!-- Real-time Pause Indicator -->
          <div id="cyclePauseStatus" style="margin-top: 10px; padding: 8px; background: #f0f0f0; border-radius: 5px; font-size: 13px; text-align: center; display: none;">
            <strong>â±ï¸ En pause:</strong> <span id="cyclePauseRemaining">0.0s</span> restantes
          </div>
        </div>
      </div>

    <div class="button-group">
      <button class="button btn-success" id="btnStart">â–¶ DÃ©marrer</button>
      <button class="button btn-warning" id="btnPause">â¸ Pause</button>
      <button class="button btn-danger" id="btnStop">â¹ ArrÃªter</button>
      <button class="button btn-info" id="btnManagePlaylistSimple">
        ğŸ“‹ Playlist (0/20)
      </button>
    </div>
    

    </div>
    </div>
    <!-- END MODE SIMPLE -->

    <!-- MODE POURSUITE Tab Content -->
    <div class="tab-content hidden-until-calibrated" id="tabPursuit">
      <div class="controls">
        
        <!-- Pursuit Controls -->
        <div style="display: flex; gap: 30px; align-items: flex-start; margin-bottom: 20px;">
          
          <!-- Left Side: Gauge -->
          <div style="flex: 0 0 200px;">
            <div style="text-align: center; margin-bottom: 10px;">
              <strong style="color: #333;">Jauge de Position</strong>
            </div>
            
            <!-- Gauge Container -->
            <div id="gaugeContainer" style="position: relative; width: 120px; height: 500px; margin: 0 auto; background: linear-gradient(180deg, #f44336 0%, #FF9800 20%, #FFC107 40%, #4CAF50 60%, #2196F3 80%, #9C27B0 100%); border: 3px solid #333; border-radius: 10px; cursor: crosshair; box-shadow: 0 4px 10px rgba(0,0,0,0.2);">
              
              <!-- Target Cursor (user control) -->
              <div id="gaugeCursor" style="position: absolute; left: -5px; right: -5px; height: 8px; background: #FF5722; border: 3px solid white; border-radius: 4px; cursor: grab; box-shadow: 0 2px 8px rgba(0,0,0,0.5); transition: top 0.05s linear; z-index: 10;">
                <div style="position: absolute; right: -60px; top: -8px; background: #FF5722; color: white; padding: 4px 8px; border-radius: 4px; font-size: 11px; font-weight: bold; white-space: nowrap;">
                  CIBLE
                </div>
              </div>
              
              <!-- Current Position Indicator -->
              <div id="gaugePosition" style="position: absolute; left: 0; right: 0; height: 6px; background: #00E676; border: 2px solid white; border-radius: 3px; box-shadow: 0 2px 8px rgba(0,255,118,0.6); transition: top 0.1s linear; z-index: 5;">
                <div style="position: absolute; left: -60px; top: -8px; background: #00E676; color: white; padding: 4px 8px; border-radius: 4px; font-size: 11px; font-weight: bold; white-space: nowrap;">
                  RÃ‰EL
                </div>
              </div>
              
              <!-- Software Limit Line (dynamically positioned if limit < 100%) -->
              <div id="gaugeLimitLine" style="position: absolute; left: -8px; right: -8px; height: 3px; background: #000; border-top: 2px dashed #FF5722; display: none; z-index: 15;">
                <div style="position: absolute; right: -90px; top: -10px; background: #000; color: white; padding: 2px 6px; border-radius: 3px; font-size: 10px; font-weight: bold; white-space: nowrap;">
                  ğŸš« LIMITE
                </div>
              </div>
              
              <!-- Scale markers -->
              <div style="position: absolute; right: -40px; top: 0; height: 100%; display: flex; flex-direction: column; justify-content: space-between; font-size: 11px; color: #666;">
                <span>FIN â–¶</span>
                <span>75% â–¶</span>
                <span>50% â–¶</span>
                <span>25% â–¶</span>
                <span>0mm â–¶</span>
              </div>
            </div>
            
            <div style="text-align: center; margin-top: 15px; font-size: 12px; color: #666;">
              <div><strong>Cible:</strong> <span id="targetPositionMM" style="color: #FF5722;">0.0</span> mm</div>
              <div><strong>Actuel:</strong> <span id="currentPositionMM" style="color: #00E676;">0.0</span> mm</div>
              <div><strong>Ã‰cart:</strong> <span id="positionError" style="color: #666;">0.0</span> mm</div>
            </div>
          </div>
          
          <!-- Right Side: Settings -->
          <div style="flex: 1;">
            <!-- Checkbox Activer - COMPACT -->
            <div style="padding: 10px 15px; background: #E3F2FD; border-radius: 6px; margin-bottom: 15px;">
              <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                <input type="checkbox" id="pursuitActiveCheckbox" autocomplete="off">
                <span style="font-weight: 500; color: #1976D2;">ğŸ¯ Activer poursuite</span>
              </label>
              <small style="color: #666; display: block; margin-top: 4px; font-size: 11px; padding-left: 28px;">
                âš ï¸ Le moteur suivra automatiquement le curseur
              </small>
            </div>
            
            <!-- Vitesse max - COMPACT -->
            <div class="form-group-compact" style="display: block;">
              <div>
                <label class="label-inline">Vitesse max:</label>
                <input type="number" id="pursuitMaxSpeed" min="0.5" max="20" step="0.5" value="10" class="input-compact">
                <span class="unit-label">(0-20)</span>
              </div>
              <div style="margin-top: 8px;">
                <button class="preset-btn-sm btn-preset" data-pursuit-speed="2">2ğŸŒ</button>
                <button class="preset-btn-sm btn-preset" data-pursuit-speed="5">5</button>
                <button class="preset-btn-sm btn-preset active" data-pursuit-speed="10">10âœ“</button>
                <button class="preset-btn-sm btn-preset" data-pursuit-speed="15">15</button>
                <button class="preset-btn-sm btn-preset" data-pursuit-speed="20">20âš¡</button>
              </div>
            </div>
          </div>
        </div>

        <div class="button-group">
          <button class="button btn-success" id="btnActivatePursuit">â–¶ DÃ©marrer</button>
          <button class="button btn-danger" id="btnStopPursuit">â¹ ArrÃªter</button>
        </div>
      </div>
    </div>
    <!-- END MODE POURSUITE -->

    <!-- MODE OSCILLATION Tab Content -->
    <div class="tab-content hidden-until-calibrated" id="tabOscillation">
      <div class="controls">
        
        <!-- Help Section (masquÃ©e par dÃ©faut) -->
        <div id="oscHelpSection" style="display: none; background: #fff3cd; border-left: 4px solid #ffc107; padding: 12px; margin-bottom: 15px; border-radius: 4px; font-size: 12px;">
          <strong style="color: #856404;">ğŸ’¡ Conseils d'utilisation:</strong>
          <ul style="margin: 8px 0 0 20px; color: #856404;">
            <li><strong>Forme sinusoÃ¯dale:</strong> Mouvement fluide et doux, idÃ©al pour tests mÃ©caniques (comme une vague ğŸŒŠ)</li>
            <li><strong>Forme triangle:</strong> AccÃ©lÃ©ration/dÃ©cÃ©lÃ©ration linÃ©aire constante (mouvement mÃ©canique)</li>
            <li><strong>Forme carrÃ©e:</strong> Changements de direction instantanÃ©s (attention aux contraintes mÃ©caniques!)</li>
            <li><strong>Rampes:</strong> Ã‰vitent les Ã -coups au dÃ©marrage/arrÃªt en augmentant/rÃ©duisant progressivement l'amplitude</li>
            <li><strong>Limites auto:</strong> L'amplitude est automatiquement limitÃ©e aux bornes calibrÃ©es</li>
            <li><strong>Modification temps rÃ©el:</strong> Vous pouvez changer les paramÃ¨tres pendant l'oscillation!</li>
          </ul>
        </div>

        <!-- Configuration principale - COMPACT -->
        <div class="form-row-compact">
          <!-- Centre -->
          <div class="form-group-compact" style="display: block;">
            <div>
              <label class="label-inline">Centre:</label>
              <input type="number" id="oscCenter" min="0" step="0.1" value="0" class="input-compact">
              <span class="unit-label">mm</span>
            </div>
            <div style="margin-top: 8px;">
              <button class="preset-btn-sm btn-preset" data-osc-center="25">25mm</button>
              <button class="preset-btn-sm btn-preset" data-osc-center="50">50mm</button>
              <button class="preset-btn-sm btn-preset" data-osc-center="75">75mm</button>
              <button class="preset-btn-sm btn-preset" data-osc-center="110">110mm</button>
            </div>
          </div>
          
          <!-- Amplitude -->
          <div class="form-group-compact" style="display: block;">
            <div>
              <label class="label-inline">Amplitude Â±:</label>
              <input type="number" id="oscAmplitude" min="1" step="0.1" value="20" class="input-compact">
              <span class="unit-label">mm</span>
            </div>
            <div style="margin-top: 8px;">
              <button class="preset-btn-sm btn-preset" data-osc-amplitude="10">10mm</button>
              <button class="preset-btn-sm btn-preset" data-osc-amplitude="25">25mm</button>
              <button class="preset-btn-sm btn-preset" data-osc-amplitude="50">50mm</button>
              <button class="preset-btn-sm btn-preset" data-osc-amplitude="75">75mm</button>
              <button class="preset-btn-sm btn-preset" data-osc-amplitude="100">100mm</button>
            </div>
          </div>
        </div>
        
        <!-- Warning limite (compact) -->
        <div id="oscLimitWarning" style="display:none; color: #f44336; font-size: 12px; padding: 5px 10px; background: #ffe5e5; border-radius: 4px; margin-bottom: 10px;">
          âš ï¸ Limites dÃ©passÃ©es! Ajuster centre ou amplitude.
        </div>
        
        <!-- SÃ©parateur -->
        <div style="border-top: 1px solid #ddd; margin: 15px 0;"></div>
        
        <!-- Forme + FrÃ©quence inline -->
        <div class="speed-control-inline" style="margin-bottom: 12px;">
          <label class="label-inline">Forme:</label>
          <select id="oscWaveform" style="width: 150px; padding: 5px; font-size: 12px; border: 2px solid #ddd; border-radius: 4px;">
            <option value="0">SinusoÃ¯dale</option>
            <option value="1">Triangle</option>
            <option value="2">CarrÃ©e</option>
          </select>
          <label class="label-inline" style="margin-left: 15px;">FrÃ©quence:</label>
          <input type="number" id="oscFrequency" min="0.01" max="10" step="0.01" value="0.5" class="input-compact">
          <span class="unit-label">Hz</span>
          <button class="preset-btn-sm btn-preset" data-osc-frequency="0.1">0.1Hz</button>
          <button class="preset-btn-sm btn-preset" data-osc-frequency="0.25">0.25Hz</button>
          <button class="preset-btn-sm btn-preset" data-osc-frequency="0.5">0.5Hz</button>
          <button class="preset-btn-sm btn-preset" data-osc-frequency="1">1Hz</button>
          <button class="preset-btn-sm btn-preset" data-osc-frequency="2">2Hz</button>
        </div>
        
        <!-- SÃ©parateur -->
        <div style="border-top: 1px solid #ddd; margin: 15px 0;"></div>

        <!-- Rampes inline (pas d'accordion) -->
        <div class="speed-control-inline" style="margin-bottom: 10px;">
          <label style="display: flex; align-items: center; cursor: pointer;">
            <input type="checkbox" id="oscRampInEnable" checked style="width: auto; margin-right: 5px;">
            <span style="font-size: 12px;">Rampe entrÃ©e:</span>
          </label>
          <input type="number" id="oscRampInDuration" min="100" step="100" value="2000" class="input-compact" style="width: 70px;">
          <span class="unit-label">ms</span>
          
          <label style="display: flex; align-items: center; cursor: pointer; margin-left: 20px;">
            <input type="checkbox" id="oscRampOutEnable" checked style="width: auto; margin-right: 5px;">
            <span style="font-size: 12px;">Rampe sortie:</span>
          </label>
          <input type="number" id="oscRampOutDuration" min="100" step="100" value="2000" class="input-compact" style="width: 70px;">
          <span class="unit-label">ms</span>
        </div>
        
        <!-- Cycles + Retour centre inline -->
        <div class="speed-control-inline" style="margin-bottom: 12px;">
          <label class="label-inline">Cycles:</label>
          <input type="number" id="oscCycleCount" min="0" step="1" value="0" class="input-compact" style="width: 60px;">
          <span class="unit-label" style="font-size: 11px;">(0=Infini)</span>
          
          <label style="display: flex; align-items: center; cursor: pointer; margin-left: 20px;">
            <input type="checkbox" id="oscReturnCenter" checked style="width: auto; margin-right: 5px;">
            <span style="font-size: 12px;">Retour centre</span>
          </label>
        </div>
        
        <!-- SÃ©parateur -->
        <div style="border-top: 1px solid #ddd; margin: 15px 0;"></div>

        <!-- Ã‰tat temps rÃ©el - COMPACT -->
        <div style="background: #e3f2fd; padding: 10px; border-radius: 4px; margin-bottom: 15px;">
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 12px;">
            <div>
              <strong>Amplitude:</strong>
              <span id="oscCurrentAmplitude" style="color: #f5576c; font-weight: bold;">--</span> mm
            </div>
            <div>
              <strong>Cycles:</strong>
              <span id="oscCompletedCycles" style="color: #f5576c; font-weight: bold;">0</span>
            </div>
            <div>
              <strong>Rampe:</strong>
              <span id="oscRampStatus" style="color: #666;">--</span>
            </div>
            <div>
              <strong>Limites:</strong>
              <span id="oscLimitStatus" style="font-weight: bold;">--</span>
            </div>
          </div>
        </div>
        
        <!-- ===== CYCLE PAUSE SECTION (OSCILLATION) ===== -->
        <div class="section-collapsible collapsed" style="margin-bottom: 20px;">
          <div class="section-collapsible-header" onclick="toggleCyclePauseOscSection()">
            <span class="collapse-icon">â–¼</span> <span id="cyclePauseOscHeaderText">â¸ï¸ Pause entre cycles - dÃ©sactivÃ©e</span>
          </div>
          
          <div class="section-collapsible-content">
            <!-- Mode Selection: Fixed / Random -->
            <div class="speed-control-inline" style="margin-bottom: 15px;">
              <label class="label-inline">Mode:</label>
              <label style="margin-right: 15px; font-size: 13px;">
                <input type="radio" name="cyclePauseModeOsc" value="fixed" id="pauseModeFixedOsc" checked style="margin-right: 5px;">
                â±ï¸ Fixe
              </label>
              <label style="font-size: 13px;">
                <input type="radio" name="cyclePauseModeOsc" value="random" id="pauseModeRandomOsc" style="margin-right: 5px;">
                ğŸ² AlÃ©atoire
              </label>
            </div>
            
            <!-- Fixed Mode: Single Duration -->
            <div id="pauseFixedControlsOsc" class="speed-control-inline" style="margin-bottom: 10px;">
              <label class="label-inline">DurÃ©e:</label>
              <input type="number" id="cyclePauseDurationOsc" min="0.1" max="60" step="0.1" value="1.5" class="input-compact">
              <span class="unit-label">s</span>
              <button class="preset-btn-sm btn-preset" data-pause-duration-osc="0.5">0.5s</button>
              <button class="preset-btn-sm btn-preset active" data-pause-duration-osc="1.5">1.5s</button>
              <button class="preset-btn-sm btn-preset" data-pause-duration-osc="3">3s</button>
              <button class="preset-btn-sm btn-preset" data-pause-duration-osc="5">5s</button>
              <button class="preset-btn-sm btn-preset" data-pause-duration-osc="10">10s</button>
            </div>
            
            <!-- Random Mode: Min/Max Range -->
            <div id="pauseRandomControlsOsc" style="display: none;">
              <div class="speed-control-inline" style="margin-bottom: 10px;">
                <label class="label-inline">Min:</label>
                <input type="number" id="cyclePauseMinOsc" min="0.1" max="60" step="0.1" value="1.5" class="input-compact">
                <span class="unit-label">s</span>
                <button class="preset-btn-sm btn-preset" data-pause-min-osc="0.5">0.5s</button>
                <button class="preset-btn-sm btn-preset active" data-pause-min-osc="1.5">1.5s</button>
                <button class="preset-btn-sm btn-preset" data-pause-min-osc="3">3s</button>
              </div>
              
              <div class="speed-control-inline" style="margin-bottom: 10px;">
                <label class="label-inline">Max:</label>
                <input type="number" id="cyclePauseMaxOsc" min="0.1" max="60" step="0.1" value="5.0" class="input-compact">
                <span class="unit-label">s</span>
                <button class="preset-btn-sm btn-preset" data-pause-max-osc="3">3s</button>
                <button class="preset-btn-sm btn-preset active" data-pause-max-osc="5">5s</button>
                <button class="preset-btn-sm btn-preset" data-pause-max-osc="10">10s</button>
                <button class="preset-btn-sm btn-preset" data-pause-max-osc="15">15s</button>
              </div>
            </div>
            
            <!-- Real-time Pause Indicator -->
            <div id="cyclePauseStatusOsc" style="margin-top: 10px; padding: 8px; background: #f0f0f0; border-radius: 5px; font-size: 13px; text-align: center; display: none;">
              <strong>â±ï¸ En pause:</strong> <span id="cyclePauseRemainingOsc">0.0s</span> restantes
            </div>
          </div>
        </div>
        
        <!-- Boutons de contrÃ´le (comme Simple - en bas) -->
        <div class="button-group">
          <button class="button btn-success" id="btnStartOscillation">â–¶ï¸ DÃ©marrer</button>
          <button class="button btn-warning" id="btnPauseOscillation">â¸ Pause</button>
          <button class="button btn-danger" id="btnStopOscillation">â¹ï¸ ArrÃªter</button>
          <button class="button btn-info" id="btnManagePlaylistOscillation">
            ğŸ“‹ Playlist (0/20)
          </button>
          <button class="button btn-help" onclick="toggleOscHelp()" style="padding: 12px 20px;">â“</button>
        </div>
        

      </div>
    </div>
    <!-- END MODE OSCILLATION -->

    <!-- MODE CHAOS Tab Content -->
    <div class="tab-content hidden-until-calibrated" id="tabChaos">
      <div class="controls">
        
        <!-- Help Section (masquÃ©e par dÃ©faut) -->
        <div id="chaosHelpSection" style="display: none; background: #fff3cd; border-left: 4px solid #ffc107; padding: 12px; margin-bottom: 15px; border-radius: 4px; font-size: 12px;">
          <strong style="color: #856404;">ğŸ’¡ Patterns Chaos (11 patterns):</strong>
          <p style="margin: 8px 0 0 0; color: #856404; font-weight: bold;">ğŸŒŠ Patterns DOUX (mouvements continus - 45%):</p>
          <ul style="margin: 5px 0 10px 20px; color: #856404;">
            <li><strong>WAVE:</strong> Vagues lentes et continues, fluide, 25-75% vitesse, 4-8s</li>
            <li><strong>PENDULUM:</strong> Balancier rÃ©gulier, oscillations douces, 30-90% vitesse, 3-6s</li>
            <li><strong>SPIRAL:</strong> Spirale progressive expansion/contraction, 20-75% vitesse, 5-10s</li>
            <li><strong>BREATHING:</strong> Respiration apaisante, petites amplitudes 10-50%, pauses alÃ©atoires, 15-60% vitesse, 2-5s</li>
          </ul>
          <p style="margin: 8px 0 0 0; color: #856404; font-weight: bold;">âš¡ Patterns DYNAMIQUES (sauts de position - 55%):</p>
          <ul style="margin: 5px 0 10px 20px; color: #856404;">
            <li><strong>ZIGZAG:</strong> Va-et-vient modÃ©rÃ©s, sauts max 60%, 40-100% vitesse, 1-2.5s</li>
            <li><strong>SWEEP:</strong> Balayages bout-Ã -bout, 30-90% vitesse, 2-4s</li>
            <li><strong>PULSE:</strong> Impulsions depuis centre Â±40%, 50-100% vitesse, 0.8-1.5s</li>
            <li><strong>DRIFT:</strong> DÃ©rive micro-changements 25%, 20-70% vitesse, 3-6s</li>
            <li><strong>BURST:</strong> Sauts ultrarapides 70%, 60-100% vitesse, 0.6-1.2s</li>
            <li><strong>BRUTE FORCE:</strong> BÃ©lier 3 phases: entrÃ©e rapide 70-100%, sortie lente 20-30%, pause 200-1500ms</li>
            <li><strong>LIBERATOR:</strong> Extraction 3 phases: entrÃ©e lente 20-30%, sortie rapide 70-100%, pause 200-1500ms</li>
          </ul>
          <p style="margin: 8px 0 0 0; color: #856404;">
            âœ¨ <strong>45% doux, 55% dynamiques.</strong> DegrÃ© de folie module vitesse/durÃ©e/sauts/pauses.
          </p>
        </div>

        <!-- Configuration principale -->
        <div class="form-row-compact">
          <div class="form-group-compact" style="display: block;">
            <div>
              <label class="label-inline">Centre:</label>
              <input type="number" id="chaosCenterPos" min="0" step="0.1" value="110" class="input-compact">
              <span class="unit-label">mm</span>
            </div>
            <div style="margin-top: 8px;">
              <button class="preset-btn-sm btn-preset" data-chaos-center="25">25mm</button>
              <button class="preset-btn-sm btn-preset" data-chaos-center="50">50mm</button>
              <button class="preset-btn-sm btn-preset" data-chaos-center="75">75mm</button>
              <button class="preset-btn-sm btn-preset" data-chaos-center="110">110mm</button>
            </div>
          </div>
          <div class="form-group-compact" style="display: block;">
            <div>
              <label class="label-inline">Amplitude Â±:</label>
              <input type="number" id="chaosAmplitude" min="1" step="0.1" value="50" class="input-compact">
              <span class="unit-label">mm</span>
            </div>
            <div style="margin-top: 8px;">
              <button class="preset-btn-sm btn-preset" data-chaos-amplitude="10">10mm</button>
              <button class="preset-btn-sm btn-preset" data-chaos-amplitude="25">25mm</button>
              <button class="preset-btn-sm btn-preset" data-chaos-amplitude="50">50mm</button>
              <button class="preset-btn-sm btn-preset" data-chaos-amplitude="75">75mm</button>
              <button class="preset-btn-sm btn-preset" data-chaos-amplitude="100">100mm</button>
            </div>
          </div>
        </div>

        <!-- SÃ©parateur -->
        <div style="border-top: 1px solid #ddd; margin: 15px 0;"></div>

        <!-- Vitesse max -->
        <div class="speed-control-inline" style="margin-bottom: 12px;">
          <label class="label-inline">Vitesse max:</label>
          <input type="number" id="chaosMaxSpeed" min="0.5" max="20" step="0.5" value="10" class="input-compact">
          <button class="preset-btn-sm btn-preset" data-chaos-speed="0.5">0.5 ğŸŒ</button>
          <button class="preset-btn-sm btn-preset" data-chaos-speed="1">1</button>
          <button class="preset-btn-sm btn-preset" data-chaos-speed="2">2</button>
          <button class="preset-btn-sm btn-preset" data-chaos-speed="5">5 âœ“</button>
          <button class="preset-btn-sm btn-preset" data-chaos-speed="10">10</button>
          <button class="preset-btn-sm btn-preset" data-chaos-speed="15">15</button>
          <button class="preset-btn-sm btn-preset" data-chaos-speed="20">20 âš¡</button>
        </div>

        <!-- DegrÃ© de folie -->
        <div class="speed-control-inline" style="margin-bottom: 12px;">
          <label class="label-inline">ğŸ”¥ DegrÃ© folie: <span id="crazinessValue" style="font-weight: bold; color: #C850C0;">50</span>%</label>
          <input type="range" id="chaosCraziness" min="0" max="100" step="5" value="50" style="width: 180px; margin-left: 10px;">
          <button class="preset-btn-sm btn-preset" data-chaos-craziness="0">0% ğŸ˜´</button>
          <button class="preset-btn-sm btn-preset" data-chaos-craziness="25">25%</button>
          <button class="preset-btn-sm btn-preset" data-chaos-craziness="50">50% âœ“</button>
          <button class="preset-btn-sm btn-preset" data-chaos-craziness="75">75%</button>
          <button class="preset-btn-sm btn-preset" data-chaos-craziness="100">100% ğŸ”¥</button>
        </div>

        <!-- DurÃ©e -->
        <div class="speed-control-inline" style="margin-bottom: 12px;">
          <label class="label-inline">DurÃ©e:</label>
          <input type="number" id="chaosDuration" min="0" step="1" value="0" class="input-compact" style="width: 70px;">
          <span class="unit-label">s (0=Infini)</span>
          <button class="preset-btn-sm btn-preset" data-chaos-duration="30">30s</button>
          <button class="preset-btn-sm btn-preset" data-chaos-duration="60">60s</button>
          <button class="preset-btn-sm btn-preset" data-chaos-duration="120">120s</button>
          <button class="preset-btn-sm btn-preset" data-chaos-duration="0">âˆ</button>
        </div>

        <!-- SÃ©parateur -->
        <div style="border-top: 1px solid #ddd; margin: 15px 0;"></div>

        <!-- Accordion: Options avancÃ©es -->
        <details style="margin-bottom: 15px; border: 1px solid #ddd; border-radius: 4px; padding: 10px; background: #f9f9f9;">
          <summary style="cursor: pointer; font-weight: bold; font-size: 13px; color: #333;">â–¼ Options avancÃ©es</summary>
          
          <!-- Patterns actifs -->
          <div style="margin-top: 10px; padding: 10px; background: #e8f5e9; border-radius: 4px; border-left: 3px solid #4caf50;">
            <label style="font-weight: bold; font-size: 12px; display: block; margin-bottom: 8px;">âœ… Patterns actifs:</label>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px; margin-bottom: 8px;">
              <label style="display: flex; align-items: center; background: white; padding: 5px; border-radius: 3px; cursor: pointer; font-size: 11px;">
                <input type="checkbox" id="patternWave" checked style="margin-right: 5px; transform: scale(1.1);">
                <span>ğŸŒŠ WAVE</span>
              </label>
              <label style="display: flex; align-items: center; background: white; padding: 5px; border-radius: 3px; cursor: pointer; font-size: 11px;">
                <input type="checkbox" id="patternPendulum" checked style="margin-right: 5px; transform: scale(1.1);">
                <span>ğŸ¯ PENDULUM</span>
              </label>
              <label style="display: flex; align-items: center; background: white; padding: 5px; border-radius: 3px; cursor: pointer; font-size: 11px;">
                <input type="checkbox" id="patternSpiral" checked style="margin-right: 5px; transform: scale(1.1);">
                <span>ğŸŒ€ SPIRAL</span>
              </label>
              <label style="display: flex; align-items: center; background: white; padding: 5px; border-radius: 3px; cursor: pointer; font-size: 11px;">
                <input type="checkbox" id="patternZigzag" checked style="margin-right: 5px; transform: scale(1.1);">
                <span>âš¡ ZIGZAG</span>
              </label>
              <label style="display: flex; align-items: center; background: white; padding: 5px; border-radius: 3px; cursor: pointer; font-size: 11px;">
                <input type="checkbox" id="patternSweep" checked style="margin-right: 5px; transform: scale(1.1);">
                <span>â†”ï¸ SWEEP</span>
              </label>
              <label style="display: flex; align-items: center; background: white; padding: 5px; border-radius: 3px; cursor: pointer; font-size: 11px;">
                <input type="checkbox" id="patternPulse" checked style="margin-right: 5px; transform: scale(1.1);">
                <span>ğŸ’« PULSE</span>
              </label>
              <label style="display: flex; align-items: center; background: white; padding: 5px; border-radius: 3px; cursor: pointer; font-size: 11px;">
                <input type="checkbox" id="patternDrift" checked style="margin-right: 5px; transform: scale(1.1);">
                <span>ğŸŒ«ï¸ DRIFT</span>
              </label>
              <label style="display: flex; align-items: center; background: white; padding: 5px; border-radius: 3px; cursor: pointer; font-size: 11px;">
                <input type="checkbox" id="patternBurst" checked style="margin-right: 5px; transform: scale(1.1);">
                <span>ğŸ”¥ BURST</span>
              </label>
              <label style="display: flex; align-items: center; background: white; padding: 5px; border-radius: 3px; cursor: pointer; font-size: 11px;">
                <input type="checkbox" id="patternCalm" checked style="margin-right: 5px; transform: scale(1.1);">
                <span>ğŸ˜Œ BREATHING</span>
              </label>
              <label style="display: flex; align-items: center; background: white; padding: 5px; border-radius: 3px; cursor: pointer; font-size: 11px;">
                <input type="checkbox" id="patternBruteForce" checked style="margin-right: 5px; transform: scale(1.1);">
                <span>ğŸ”¨ BRUTE FORCE</span>
              </label>
              <label style="display: flex; align-items: center; background: white; padding: 5px; border-radius: 3px; cursor: pointer; font-size: 11px;">
                <input type="checkbox" id="patternLiberator" checked style="margin-right: 5px; transform: scale(1.1);">
                <span>ğŸ”“ LIBERATOR</span>
              </label>
            </div>
            <div style="display: flex; gap: 5px; margin-top: 8px;">
              <button class="preset-btn-sm btn-preset" id="btnEnableAllPatterns" style="flex: 1; font-size: 10px; padding: 4px;">âœ… Tout</button>
              <button class="preset-btn-sm btn-preset" id="btnEnableSoftPatterns" style="flex: 1; font-size: 10px; padding: 4px;">ğŸŒŠ Doux</button>
              <button class="preset-btn-sm btn-preset" id="btnEnableDynamicPatterns" style="flex: 1; font-size: 10px; padding: 4px;">âš¡ Dynamiques</button>
            </div>
          </div>

          <!-- Seed (optionnel) -->
          <div style="margin-top: 10px;">
            <label class="label-inline" style="font-size: 12px;">Seed (optionnel):</label>
            <input type="number" id="chaosSeed" min="0" step="1" value="0" class="input-compact" style="width: 90px;">
            <span class="unit-label" style="font-size: 11px;">(0=alÃ©atoire)</span>
          </div>
        </details>

        <!-- SÃ©parateur -->
        <div style="border-top: 1px solid #ddd; margin: 15px 0;"></div>

        <!-- Real-time Stats Section -->
        <div id="chaosStats" style="display: none; background: #e3f2fd; padding: 10px; border-radius: 4px; margin-bottom: 15px;">
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 12px;">
            <div><strong>Pattern:</strong> <span id="statPattern" style="color: #C850C0;">--</span></div>
            <div><strong>Position:</strong> <span id="statPosition" style="color: #2196F3;">--</span> mm</div>
            <div><strong>Plage:</strong> <span id="statRange" style="color: #2196F3;">--</span> mm</div>
            <div><strong>Patterns:</strong> <span id="statCount" style="color: #2196F3;">0</span></div>
          </div>
          <div id="statTimer" style="margin-top: 8px; text-align: center; font-size: 12px;">
            â±ï¸ Temps: <span id="statElapsed">0</span>s
          </div>
        </div>

        <!-- Boutons de contrÃ´le -->
        <div class="button-group">
          <button class="button btn-success" id="btnStartChaos">â–¶ï¸ DÃ©marrer</button>
          <button class="button btn-warning" id="btnPauseChaos">â¸ Pause</button>
          <button class="button btn-danger" id="btnStopChaos">â¹ï¸ ArrÃªter</button>
          <button class="button btn-info" id="btnManagePlaylistChaos">
            ğŸ“‹ Playlist (0/20)
          </button>
          <button class="button btn-help" onclick="toggleChaosHelp()" style="padding: 12px 20px;">â“</button>
        </div>
      </div>
    </div>
    <!-- END MODE CHAOS -->

    <!-- MODE SÃ©quenceur Tab Content -->
    <div class="tab-content hidden-until-calibrated" id="tabTableau">
      <div class="controls">
        
        <!-- Toolbar -->
        <div style="display: flex; gap: 8px; margin-bottom: 12px; flex-wrap: wrap;">
          <button class="button btn-success" id="btnAddLine" style="flex: 1; min-width: 110px; padding: 8px; font-size: 13px;">â• Ajouter</button>
          <button class="button btn-warning" id="btnClearAll" style="flex: 1; min-width: 110px; padding: 8px; font-size: 13px;">ğŸ—‘ï¸ Effacer</button>
          <button class="button btn-primary" id="btnImportSeq" style="flex: 1; min-width: 110px; padding: 8px; font-size: 13px;">ğŸ“¥ Import</button>
          <button class="button btn-primary" id="btnExportSeq" style="flex: 1; min-width: 110px; padding: 8px; font-size: 13px;">ğŸ“¤ Export</button>
          <button class="button btn-info" id="btnDownloadTemplate" style="flex: 1; min-width: 110px; padding: 8px; font-size: 13px; background: #17a2b8;" title="TÃ©lÃ©charger un template JSON avec exemples">ğŸ“„ Template</button>
        </div>

        <!-- Phase 2: Batch Operations Toolbar (hidden by default) -->
        <div id="sequenceBatchToolbar" class="sequence-batch-toolbar">
          <div class="sequence-batch-info">
            <span id="batchSelectionCount">0 ligne(s) sÃ©lectionnÃ©e(s)</span>
          </div>
          <div class="sequence-batch-actions">
            <button class="sequence-batch-btn" onclick="batchEnableLines(true)">
              <span>âœ“</span> Activer
            </button>
            <button class="sequence-batch-btn" onclick="batchEnableLines(false)">
              <span>âœ—</span> DÃ©sactiver
            </button>
            <div id="sequenceTrashZone" class="sequence-trash-zone">
              <span class="trash-icon">ğŸ—‘ï¸</span>
              <span>Glisser ici</span>
            </div>
            <button class="sequence-batch-btn" onclick="clearSelection()">
              <span>âœ–</span> Annuler
            </button>
          </div>
        </div>

        <!-- Sequence Table Container -->
        <div style="overflow-x: auto; margin-bottom: 20px; border: 2px solid #ddd; border-radius: 8px; background: white; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
          <table id="sequenceTable" style="width: 100%; border-collapse: collapse; font-size: 11px;">
            <thead>
              <tr style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                <th style="padding: 8px 4px; text-align: center; border-right: 1px solid rgba(255,255,255,0.2); width: 30px;">âœ“</th>
                <th style="padding: 8px 4px; text-align: center; border-right: 1px solid rgba(255,255,255,0.2); width: 30px;">#</th>
                <th style="padding: 8px 4px; text-align: center; border-right: 1px solid rgba(255,255,255,0.2); width: 40px;">Type</th>
                <th style="padding: 8px 6px; text-align: center; border-right: 1px solid rgba(255,255,255,0.2);">DÃ©but<br><small style="font-size: 9px;">(mm)</small></th>
                <th style="padding: 8px 6px; text-align: center; border-right: 1px solid rgba(255,255,255,0.2);">Dist.<br><small style="font-size: 9px;">(mm)</small></th>
                <th style="padding: 8px 6px; text-align: center; border-right: 1px solid rgba(255,255,255,0.2);">Vitesses<br><small style="font-size: 9px;">A/R</small></th>
                <th style="padding: 8px 6px; text-align: center; border-right: 1px solid rgba(255,255,255,0.2);">DÃ©cel.</th>
                <th style="padding: 8px 4px; text-align: center; border-right: 1px solid rgba(255,255,255,0.2); width: 45px;">Cycles</th>
                <th style="padding: 8px 4px; text-align: center; border-right: 1px solid rgba(255,255,255,0.2); width: 50px;">â±ï¸<br><small style="font-size: 9px;">(s)</small></th>
                <th style="padding: 8px 4px; text-align: center;">Actions</th>
              </tr>
            </thead>
            <tbody id="sequenceTableBody">
              <tr>
                <td colspan="10" style="padding: 40px; text-align: center; color: #999;">
                  <div style="font-size: 48px; margin-bottom: 10px;">ğŸ“‹</div>
                  <div style="font-size: 16px;">Aucune ligne - Cliquez sur "â• Ajouter ligne" pour commencer</div>
                </td>
              </tr>
            </tbody>
          </table>
        </div>

        <!-- Permanent Trash Drop Zone -->
        <div id="sequenceTrashDropZone" class="sequence-trash-drop-zone">
          <span class="trash-icon">ğŸ—‘ï¸</span>
          <span>Glisser une ligne ici pour la supprimer</span>
        </div>

        <!-- Execution Controls -->
        <div style="background: #f5f5f5; padding: 12px; border-radius: 8px; margin-bottom: 15px;">
          <div style="display: flex; gap: 8px; margin-bottom: 12px; flex-wrap: wrap;">
            <button class="button btn-success" id="btnStartSequence" style="flex: 1; min-width: 130px; font-size: 14px; padding: 10px;">
              â–¶ï¸ Unique
            </button>
            <button class="button btn-primary" id="btnLoopSequence" style="flex: 1; min-width: 130px; font-size: 14px; padding: 10px; background: #FF9800;">
              ğŸ” Boucle
            </button>
            <button class="button btn-warning" id="btnPauseSequence" style="flex: 1; min-width: 90px; font-size: 14px; padding: 10px;" disabled>
              â¸ï¸ Pause
            </button>
            <button class="button btn-danger" id="btnStopSequence" style="flex: 1; min-width: 90px; font-size: 14px; padding: 10px;" disabled>
              â¹ï¸ Stop
            </button>
            <button class="button btn-primary" id="btnSkipLine" style="flex: 1; min-width: 110px; font-size: 14px; padding: 10px; background: #9C27B0;" disabled>
              â­ï¸ Suivant
            </button>
          </div>

          <!-- Sequence Status - COMPACT -->
          <div style="display: flex; gap: 20px; flex-wrap: wrap; font-size: 12px; padding: 10px 15px; background: white; border-radius: 6px; border: 1px solid #ddd;">
            <div><span style="color: #666;">Mode:</span> <strong id="seqMode" style="color: #333;">ArrÃªtÃ©</strong></div>
            <div><span style="color: #666;">Ligne:</span> <strong id="seqCurrentLine" style="color: #2196F3;">-- / --</strong></div>
            <div><span style="color: #666;">Cycle:</span> <strong id="seqLineCycle" style="color: #4CAF50;">--</strong></div>
            <div><span style="color: #666;">Boucles:</span> <strong id="seqLoopCount" style="color: #FF9800;">0</strong></div>
            <div><span style="color: #666;">â±ï¸ Pause:</span> <strong id="seqPauseRemaining" style="color: #9C27B0;">-- ms</strong></div>
          </div>
        </div>

      </div>
    </div>
    <!-- END MODE SÃ©quenceur -->

    <!-- Modal for Line Editing -->
    <div id="editLineModal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.7); z-index: 9999; overflow-y: auto;" onclick="closeEditLineModalOnOverlayClick(event)">
      <div style="max-width: 600px; margin: 50px auto; background: white; border-radius: 10px; box-shadow: 0 10px 40px rgba(0,0,0,0.3); overflow: hidden;" onclick="event.stopPropagation()">
        
        <!-- Modal Header -->
        <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 20px; display: flex; justify-content: space-between; align-items: center;">
          <h3 style="margin: 0; font-size: 20px;">âœï¸ Ã‰diter la ligne #<span id="editLineNumber">--</span></h3>
          <button id="btnCloseModal" style="background: rgba(255,255,255,0.2); border: none; color: white; font-size: 24px; cursor: pointer; width: 35px; height: 35px; border-radius: 50%; line-height: 1;">Ã—</button>
        </div>

        <!-- Modal Body -->
        <div style="padding: 25px;">
          <form id="editLineForm">
            
            <!-- Movement Type Selection -->
            <div class="type-selection-row">
              <label class="label-inline">ğŸ›ï¸ Type:</label>
              <div class="type-selection-buttons">
                <label class="radio-label-inline">
                  <input type="radio" name="movementType" id="editTypeVaet" value="0" checked style="width: auto;">
                  <span>ğŸ”„ Va-et-vient</span>
                </label>
                <label class="radio-label-inline">
                  <input type="radio" name="movementType" id="editTypeOsc" value="1" style="width: auto;">
                  <span>ã€°ï¸ Oscillation</span>
                </label>
                <label class="radio-label-inline">
                  <input type="radio" name="movementType" id="editTypeChaos" value="2" style="width: auto;">
                  <span>ğŸŒ€ Chaos</span>
                </label>
                <label class="radio-label-inline">
                  <input type="radio" name="movementType" id="editTypeCalibration" value="4" style="width: auto;">
                  <span>ğŸ“ Calibration</span>
                </label>
              </div>
            </div>

            <!-- PLAYLIST PRESETS LOADING (for all modes) -->
            <div id="playlistLoaderSimple" style="background: #E3F2FD; padding: 12px; margin: 15px 0; border-radius: 6px; border: 2px solid #2196F3;">
              <label style="font-weight: 500; color: #1976D2; display: block; margin-bottom: 8px;">ğŸ“‹ Charger un preset Simple:</label>
              <div style="display: flex; gap: 8px; margin-bottom: 8px;">
                <select id="editSimplePresetSelect" onchange="previewSequencerPreset('simple', this.value)" style="flex: 1; padding: 8px; border: 1px solid #2196F3; border-radius: 4px;">
                  <option value="">-- SÃ©lectionner un preset --</option>
                </select>
                <button type="button" onclick="previewSequencerPreset('simple', document.getElementById('editSimplePresetSelect').value)" style="padding: 8px 12px; background: #64B5F6; color: white; border: none; border-radius: 4px; cursor: pointer;" title="Voir les dÃ©tails">
                  ğŸ‘ï¸
                </button>
              </div>
              <button type="button" onclick="loadPresetIntoSequencerModal('simple')" style="width: 100%; padding: 8px; background: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 500;">
                â¬‡ï¸ Charger les valeurs
              </button>
            </div>

            <div id="playlistLoaderOscillation" style="background: #FFF3E0; padding: 12px; margin: 15px 0; border-radius: 6px; border: 2px solid #FF9800; display: none;">
              <label style="font-weight: 500; color: #F57C00; display: block; margin-bottom: 8px;">ğŸ“‹ Charger un preset Oscillation:</label>
              <div style="display: flex; gap: 8px; margin-bottom: 8px;">
                <select id="editOscillationPresetSelect" onchange="previewSequencerPreset('oscillation', this.value)" style="flex: 1; padding: 8px; border: 1px solid #FF9800; border-radius: 4px;">
                  <option value="">-- SÃ©lectionner un preset --</option>
                </select>
                <button type="button" onclick="previewSequencerPreset('oscillation', document.getElementById('editOscillationPresetSelect').value)" style="padding: 8px 12px; background: #FFB74D; color: white; border: none; border-radius: 4px; cursor: pointer;" title="Voir les dÃ©tails">
                  ğŸ‘ï¸
                </button>
              </div>
              <button type="button" onclick="loadPresetIntoSequencerModal('oscillation')" style="width: 100%; padding: 8px; background: #FF9800; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 500;">
                â¬‡ï¸ Charger les valeurs
              </button>
            </div>

            <div id="playlistLoaderChaos" style="background: #FCE4EC; padding: 12px; margin: 15px 0; border-radius: 6px; border: 2px solid #E91E63; display: none;">
              <label style="font-weight: 500; color: #C2185B; display: block; margin-bottom: 8px;">ğŸ“‹ Charger un preset Chaos:</label>
              <div style="display: flex; gap: 8px; margin-bottom: 8px;">
                <select id="editChaosPresetSelect" onchange="previewSequencerPreset('chaos', this.value)" style="flex: 1; padding: 8px; border: 1px solid #E91E63; border-radius: 4px;">
                  <option value="">-- SÃ©lectionner un preset --</option>
                </select>
                <button type="button" onclick="previewSequencerPreset('chaos', document.getElementById('editChaosPresetSelect').value)" style="padding: 8px 12px; background: #F06292; color: white; border: none; border-radius: 4px; cursor: pointer;" title="Voir les dÃ©tails">
                  ğŸ‘ï¸
                </button>
              </div>
              <button type="button" onclick="loadPresetIntoSequencerModal('chaos')" style="width: 100%; padding: 8px; background: #E91E63; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 500;">
                â¬‡ï¸ Charger les valeurs
              </button>
            </div>

            <!-- VA-ET-VIENT FIELDS -->
            <div id="vaetFields">
              <!-- Position & Distance -->
              <div class="grid-2col-12">
                <div>
                  <label class="label-inline">Position dÃ©part:</label>
                  <input type="number" name="startPositionMM" id="editStartPos" step="0.1" min="0" class="input-modal">
                </div>
                <div>
                  <label class="label-inline">Distance (mm):</label>
                  <input type="number" name="distanceMM" id="editDistance" step="0.1" min="1" class="input-modal">
                </div>
              </div>

              <!-- Speeds -->
              <div class="grid-2col-12">
                <div>
                  <label class="label-inline">Vitesse aller (/20):</label>
                  <input type="number" name="speedForward" id="editSpeedFwd" min="0" max="20" step="0.1" value="5.0" class="input-modal">
                </div>
                <div>
                  <label class="label-inline">Vitesse retour (/20):</label>
                  <input type="number" name="speedBackward" id="editSpeedBack" min="0" max="20" step="0.1" value="5.0" class="input-modal">
                </div>
              </div>

              <!-- Deceleration Section -->
              <fieldset style="border: 1px solid #667eea; border-radius: 6px; padding: 10px; margin-bottom: 10px;">
                <legend style="color: #667eea; font-weight: 500; padding: 0 8px; font-size: 12px;">DÃ©cÃ©lÃ©ration</legend>
                
                <div class="flex-gap-15 mb-8" style="font-size: 12px;">
                  <label style="display: flex; align-items: center; gap: 4px; cursor: pointer;">
                    <input type="checkbox" name="decelStartEnabled" id="editDecelStart" style="width: 16px; height: 16px;">
                    <span>Activer DÃ‰BUT</span>
                  </label>
                  <label style="display: flex; align-items: center; gap: 4px; cursor: pointer;">
                    <input type="checkbox" name="decelEndEnabled" id="editDecelEnd" style="width: 16px; height: 16px;" checked>
                    <span>Activer FIN</span>
                  </label>
                </div>

                <div class="grid-2col-12" style="margin-bottom: 8px; gap: 10px;">
                  <div>
                    <label class="label-inline">Zone (mm):</label>
                    <input type="number" name="decelZoneMM" id="editDecelZone" min="10" max="200" step="5" value="20" class="input-modal">
                  </div>
                  <div>
                    <label class="label-inline">Effet (%): <span id="editEffectValue" style="font-weight: bold; color: #667eea;">50</span></label>
                    <input type="range" name="decelEffectPercent" id="editDecelEffect" min="0" max="100" step="5" value="50" style="width: 100%; margin-top: 3px;">
                  </div>
                </div>

                <div>
                  <label class="label-inline">Mode courbe:</label>
                  <select name="decelMode" id="editDecelMode" class="input-modal">
                    <option value="0">LinÃ©aire</option>
                    <option value="1" selected>SinusoÃ¯dal</option>
                    <option value="2">Triangle InversÃ©</option>
                    <option value="3">Sinus InversÃ©</option>
                  </select>
                </div>
              </fieldset>

              <!-- Cycle Pause Section (VA-ET-VIENT) -->
              <fieldset style="border: 1px solid #f39c12; border-radius: 6px; padding: 10px; margin-bottom: 10px;">
                <legend style="color: #f39c12; font-weight: 500; padding: 0 8px; font-size: 12px;">â¸ï¸ Pause entre cycles</legend>
                
                <div class="flex-gap-15 mb-8" style="font-size: 12px;">
                  <label style="display: flex; align-items: center; gap: 4px; cursor: pointer;">
                    <input type="checkbox" name="vaetCyclePauseEnabled" id="editVaetPauseEnabled" style="width: 16px; height: 16px;">
                    <span>Activer pause</span>
                  </label>
                  <label style="display: flex; align-items: center; gap: 4px; cursor: pointer;">
                    <input type="checkbox" name="vaetCyclePauseIsRandom" id="editVaetPauseRandom" style="width: 16px; height: 16px;">
                    <span>AlÃ©atoire (range)</span>
                  </label>
                </div>

                <div class="grid-2col-12" style="margin-bottom: 8px; gap: 10px;" id="vaetPauseFixedDiv">
                  <div>
                    <label class="label-inline">DurÃ©e pause (s):</label>
                    <input type="number" name="vaetCyclePauseDurationSec" id="editVaetPauseDuration" min="0" max="60" step="0.1" value="0.0" class="input-modal">
                  </div>
                </div>

                <div class="grid-2col-12" style="margin-bottom: 8px; gap: 10px; display: none;" id="vaetPauseRandomDiv">
                  <div>
                    <label class="label-inline">Min (s):</label>
                    <input type="number" name="vaetCyclePauseMinSec" id="editVaetPauseMin" min="0" max="60" step="0.1" value="0.5" class="input-modal">
                  </div>
                  <div>
                    <label class="label-inline">Max (s):</label>
                    <input type="number" name="vaetCyclePauseMaxSec" id="editVaetPauseMax" min="0" max="60" step="0.1" value="3.0" class="input-modal">
                  </div>
                </div>
              </fieldset>
            </div>
            
            <!-- END VA-ET-VIENT FIELDS -->

            <!-- OSCILLATION FIELDS -->
            <div id="oscFields" style="display: none;">
              
              <!-- Center & Amplitude -->
              <div class="grid-2col-12">
                <div>
                  <label class="label-inline">Centre (mm):</label>
                  <input type="number" name="oscCenterPositionMM" id="editOscCenter" step="0.1" min="0" value="100" class="input-modal">
                </div>
                <div>
                  <label class="label-inline">Amplitude (mm):</label>
                  <input type="number" name="oscAmplitudeMM" id="editOscAmplitude" step="0.1" min="1" value="50" class="input-modal">
                </div>
              </div>

              <!-- Waveform & Frequency -->
              <div class="grid-2col-12">
                <div>
                  <label class="label-inline">Forme d'onde:</label>
                  <select name="oscWaveform" id="editOscWaveform" class="input-modal">
                    <option value="0">ã€°ï¸ SinusoÃ¯dal</option>
                    <option value="1">ğŸ“ Triangle</option>
                    <option value="2">â¬œ CarrÃ©</option>
                  </select>
                </div>
                <div>
                  <label class="label-inline">FrÃ©quence (Hz):</label>
                  <input type="number" name="oscFrequencyHz" id="editOscFrequency" step="0.01" min="0.01" max="10" value="0.5" class="input-modal">
                </div>
              </div>

              <!-- Ramping -->
              <div class="flex-gap-12" style="flex-direction: column; font-size: 12px; margin-bottom: 12px;">
                <label style="display: flex; align-items: center; gap: 4px; cursor: pointer;">
                  <input type="checkbox" name="oscEnableRampIn" id="editOscRampIn" style="width: 16px; height: 16px;">
                  <span>Rampe entrÃ©e</span>
                </label>
                <label style="display: flex; align-items: center; gap: 4px; cursor: pointer;">
                  <input type="checkbox" name="oscEnableRampOut" id="editOscRampOut" style="width: 16px; height: 16px;">
                  <span>Rampe sortie</span>
                </label>
              </div>

              <!-- Ramp Durations -->
              <div class="grid-2col-12">
                <div>
                  <label class="label-inline">DurÃ©e rampe IN (ms):</label>
                  <input type="number" name="oscRampInDurationMs" id="editOscRampInDur" min="100" max="10000" step="100" value="1000" class="input-modal">
                </div>
                <div>
                  <label class="label-inline">DurÃ©e rampe OUT (ms):</label>
                  <input type="number" name="oscRampOutDurationMs" id="editOscRampOutDur" min="100" max="10000" step="100" value="1000" class="input-modal">
                </div>
              </div>

              <!-- Cycle Pause Section (OSCILLATION) -->
              <fieldset style="border: 1px solid #f39c12; border-radius: 6px; padding: 10px; margin-top: 10px;">
                <legend style="color: #f39c12; font-weight: 500; padding: 0 8px; font-size: 12px;">â¸ï¸ Pause entre cycles</legend>
                
                <div class="flex-gap-15 mb-8" style="font-size: 12px;">
                  <label style="display: flex; align-items: center; gap: 4px; cursor: pointer;">
                    <input type="checkbox" name="oscCyclePauseEnabled" id="editOscPauseEnabled" style="width: 16px; height: 16px;">
                    <span>Activer pause</span>
                  </label>
                  <label style="display: flex; align-items: center; gap: 4px; cursor: pointer;">
                    <input type="checkbox" name="oscCyclePauseIsRandom" id="editOscPauseRandom" style="width: 16px; height: 16px;">
                    <span>AlÃ©atoire (range)</span>
                  </label>
                </div>

                <div class="grid-2col-12" style="margin-bottom: 8px; gap: 10px;" id="oscPauseFixedDiv">
                  <div>
                    <label class="label-inline">DurÃ©e pause (s):</label>
                    <input type="number" name="oscCyclePauseDurationSec" id="editOscPauseDuration" min="0" max="60" step="0.1" value="0.0" class="input-modal">
                  </div>
                </div>

                <div class="grid-2col-12" style="margin-bottom: 8px; gap: 10px; display: none;" id="oscPauseRandomDiv">
                  <div>
                    <label class="label-inline">Min (s):</label>
                    <input type="number" name="oscCyclePauseMinSec" id="editOscPauseMin" min="0" max="60" step="0.1" value="0.5" class="input-modal">
                  </div>
                  <div>
                    <label class="label-inline">Max (s):</label>
                    <input type="number" name="oscCyclePauseMaxSec" id="editOscPauseMax" min="0" max="60" step="0.1" value="3.0" class="input-modal">
                  </div>
                </div>
              </fieldset>

            </div>
            <!-- END OSCILLATION FIELDS -->

            <!-- CHAOS FIELDS -->
            <div id="chaosFields" style="display: none;">
              
              <!-- Center & Amplitude -->
              <div class="grid-2col-12">
                <div>
                  <label class="label-inline">Centre (mm):</label>
                  <input type="number" name="chaosCenterPositionMM" id="editChaosCenter" step="0.1" min="0" value="110" class="input-modal">
                </div>
                <div>
                  <label class="label-inline">Amplitude (mm):</label>
                  <input type="number" name="chaosAmplitudeMM" id="editChaosAmplitude" step="0.1" min="1" value="50" class="input-modal">
                </div>
              </div>

              <!-- Speed & Craziness -->
              <div class="grid-2col-12">
                <div>
                  <label class="label-inline">Vitesse max (/20):</label>
                  <input type="number" name="chaosMaxSpeedLevel" id="editChaosSpeed" min="1" max="20" step="0.5" value="10" class="input-modal">
                </div>
                <div>
                  <label class="label-inline">ğŸ² Folie (%):</label>
                  <input type="number" name="chaosCrazinessPercent" id="editChaosCraziness" min="0" max="100" step="5" value="50" class="input-modal">
                </div>
              </div>

              <!-- Duration & Seed -->
              <div class="grid-2col-12">
                <div>
                  <label class="label-inline">â±ï¸ DurÃ©e (s) 5-600:</label>
                  <input type="number" name="chaosDurationSeconds" id="editChaosDuration" min="5" max="600" step="5" value="30" class="input-modal">
                </div>
                <div>
                  <label class="label-inline">ğŸŒ± Seed (0=alÃ©a):</label>
                  <input type="number" name="chaosSeed" id="editChaosSeed" min="0" max="9999999" step="1" value="0" class="input-modal">
                </div>
              </div>

              <!-- Patterns Selection -->
              <div class="mb-10">
                <label class="label-inline">ğŸ­ Patterns actifs:</label>
                <div class="grid-4col-patterns">
                  <label class="checkbox-label-sm">
                    <input type="checkbox" name="chaosPattern0" checked style="width: 14px; height: 14px;">
                    <span>âš¡ ZigZag</span>
                  </label>
                  <label class="checkbox-label-sm">
                    <input type="checkbox" name="chaosPattern1" checked style="width: 14px; height: 14px;">
                    <span>ğŸ“Š Sweep</span>
                  </label>
                  <label class="checkbox-label-sm">
                    <input type="checkbox" name="chaosPattern2" checked style="width: 14px; height: 14px;">
                    <span>ğŸ’¥ Pulse</span>
                  </label>
                  <label class="checkbox-label-sm">
                    <input type="checkbox" name="chaosPattern3" checked style="width: 14px; height: 14px;">
                    <span>ğŸŒŠ Drift</span>
                  </label>
                  <label class="checkbox-label-sm">
                    <input type="checkbox" name="chaosPattern4" checked style="width: 14px; height: 14px;">
                    <span>ğŸ’¨ Burst</span>
                  </label>
                  <label class="checkbox-label-sm">
                    <input type="checkbox" name="chaosPattern5" checked style="width: 14px; height: 14px;">
                    <span>ã€°ï¸ Wave</span>
                  </label>
                  <label class="checkbox-label-sm">
                    <input type="checkbox" name="chaosPattern6" checked style="width: 14px; height: 14px;">
                    <span>âš–ï¸ Pendul</span>
                  </label>
                  <label class="checkbox-label-sm">
                    <input type="checkbox" name="chaosPattern7" checked style="width: 14px; height: 14px;">
                    <span>ğŸŒ€ Spiral</span>
                  </label>
                  <label class="checkbox-label-sm">
                    <input type="checkbox" name="chaosPattern8" checked style="width: 14px; height: 14px;">
                    <span>ğŸ˜Œ Breathing</span>
                  </label>
                  <label class="checkbox-label-sm">
                    <input type="checkbox" name="chaosPattern9" checked style="width: 14px; height: 14px;">
                    <span>ğŸ”¨ BruteForce</span>
                  </label>
                  <label class="checkbox-label-sm">
                    <input type="checkbox" name="chaosPattern10" checked style="width: 14px; height: 14px;">
                    <span>ğŸ”“ Liberator</span>
                  </label>
                </div>
              </div>

            </div>
            <!-- END CHAOS FIELDS -->

            <!-- COMMON FIELDS (Cycles & Pause) -->
            <!-- Cycles & Pause -->
            <div class="grid-2col-12 mb-12">
              <div id="cyclesFieldDiv">
                <label class="label-inline">Cycles (1-1000):</label>
                <input type="number" name="cycleCount" id="editCycles" min="1" max="1000" step="1" value="1" class="input-modal">
              </div>
              <div id="pauseFieldDiv">
                <label class="label-inline">â±ï¸ Pause (s) 0-60:</label>
                <input type="number" name="pauseAfterSec" id="editPause" min="0" max="60" step="0.1" value="0" class="input-modal">
              </div>
            </div>

            <!-- Validation Error Display -->
            <div id="editValidationErrors" style="display: none; margin-bottom: 10px; padding: 10px; background: #ffebee; border-left: 4px solid #f44336; border-radius: 5px; font-size: 12px;">
              <div style="font-weight: bold; color: #d32f2f; margin-bottom: 5px;">âŒ Erreurs de validation :</div>
              <ul id="editValidationErrorsList" style="margin: 0; padding-left: 20px; color: #c62828; font-size: 13px;">
              </ul>
            </div>

            <!-- Action Buttons -->
            <div class="flex-gap-10 flex-end">
              <button type="submit" id="btnSaveEdit" class="button btn-success" style="padding: 10px 24px; font-size: 14px;">
                ğŸ’¾ Enregistrer
              </button>
              <button type="button" id="btnCancelEdit" class="button btn-secondary" style="padding: 10px 24px; font-size: 14px; background: #999;">
                âŒ Annuler
              </button>
            </div>

          </form>
        </div>
      </div>
    </div>
    <!-- END EDIT MODAL -->

  </div>

  <!-- External JavaScript Modules -->
  <script src="/js/app.js"></script>
  <script src="/js/utils.js"></script>
  
  <script>
    // ========================================================================
    // MAIN APPLICATION CODE
    // ========================================================================
    // Note: AppState, WS_CMD, PlaylistState, SystemState loaded from app.js
    // Note: showNotification, validateNumericInput, etc. loaded from utils.js
    
    // ========================================================================
    // PLAYLIST LOAD FROM BACKEND
    // ========================================================================
    
    // Load playlists from backend
    function loadPlaylists(callback) {
      fetch('/api/playlists')
        .then(response => response.json())
        .then(data => {
          PlaylistState.simple = data.simple || [];
          PlaylistState.oscillation = data.oscillation || [];
          PlaylistState.chaos = data.chaos || [];
          PlaylistState.loaded = true;
          
          // Update button counters
          updatePlaylistButtonCounters();
          
          console.log('ğŸ“‹ Playlists loaded:', 
            'Simple=' + PlaylistState.simple.length,
            'Oscillation=' + PlaylistState.oscillation.length,
            'Chaos=' + PlaylistState.chaos.length);
          
          // Execute callback if provided
          if (callback && typeof callback === 'function') {
            callback();
          }
        })
        .catch(error => {
          console.error('âŒ Error loading playlists:', error);
          PlaylistState.loaded = false;
        });
    }
    
    // Update playlist button counters
    function updatePlaylistButtonCounters() {
      const btnSimple = document.getElementById('btnManagePlaylistSimple');
      const btnOsc = document.getElementById('btnManagePlaylistOscillation');
      const btnChaos = document.getElementById('btnManagePlaylistChaos');
      
      if (btnSimple) {
        btnSimple.innerHTML = 'ğŸ“‹ Playlist (' + PlaylistState.simple.length + '/20)';
      }
      if (btnOsc) {
        btnOsc.innerHTML = 'ğŸ“‹ Playlist (' + PlaylistState.oscillation.length + '/20)';
      }
      if (btnChaos) {
        btnChaos.innerHTML = 'ğŸ“‹ Playlist (' + PlaylistState.chaos.length + '/20)';
      }
    }
    
    // Note: MILESTONES array and getMilestoneInfo() loaded from app.js
    
    // ========================================================================
    // GLOBAL STATE - Position Tracking
    // ========================================================================
    let currentPositionMM = 0; // Current motor position in millimeters
    
    // ========================================================================
    // MAXGLOSPE GLOBAL STATE (MAX_SPEED_LEVEL) - Max speed level (don't forget to update .ino if changed))
    // ========================================================================
    let maxSpeedLevel = 35; // Max speed level in mm/s

    // Initialize speed input max attributes based on maxSpeedLevel
    function initSpeedLimits() {
      const speedInputs = [
        'speedUnified',
        'speedForward', 
        'speedBackward',
        'pursuitMaxSpeed',
        'chaosMaxSpeed',
        'editSpeedFwd',
        'editSpeedBack',
        'editChaosSpeed'
      ];
      
      speedInputs.forEach(id => {
        const input = document.getElementById(id);
        if (input) {
          input.setAttribute('max', maxSpeedLevel);
        }
      });
      
      // Update labels that show the max value
      const maxLabels = document.querySelectorAll('.unit-label');
      maxLabels.forEach(label => {
        if (label.textContent.includes('0-20')) {
          label.textContent = `(0-${maxSpeedLevel})`;
        }
        if (label.textContent.includes('/20')) {
          label.textContent = label.textContent.replace('/20', `/${maxSpeedLevel}`);
        }
      });
    }

    // ========================================================================
    // DOM CACHE - Performance Optimization
    // ========================================================================
    // Cache frequently accessed DOM elements to avoid repeated getElementById() calls
    const DOM = {};
    
    function initDOMCache() {
      // Status elements (updated ~50 times/second via WebSocket)
      DOM.state = document.getElementById('state');
      DOM.position = document.getElementById('position');
      DOM.currentStep = document.getElementById('currentStep');
      DOM.totalDist = document.getElementById('totalDist');
      DOM.totalTraveled = document.getElementById('totalTraveled');
      DOM.milestoneIcon = document.getElementById('milestoneIcon');
      DOM.progress = document.getElementById('progress');
      DOM.debugMovement = document.getElementById('debugMovement');
      
      // Input fields
      DOM.startPosition = document.getElementById('startPosition');
      DOM.distance = document.getElementById('distance');
      DOM.speedUnified = document.getElementById('speedUnified');
      DOM.speedForward = document.getElementById('speedForward');
      DOM.speedBackward = document.getElementById('speedBackward');
      
      // Info displays (removed in compact mode)
      DOM.speedUnifiedInfo = document.getElementById('speedUnifiedInfo'); // Removed
      DOM.speedForwardInfo = document.getElementById('speedForwardInfo'); // Removed
      DOM.speedBackwardInfo = document.getElementById('speedBackwardInfo'); // Removed
      DOM.maxStart = document.getElementById('maxStart'); // Removed in compact mode
      DOM.maxDist = document.getElementById('maxDist'); // Removed in compact mode
      
      // Buttons
      DOM.btnStart = document.getElementById('btnStart');
      DOM.btnCalibrateCommon = document.getElementById('btnCalibrateCommon');
      
      // Pursuit elements
      DOM.gaugePosition = document.getElementById('gaugePosition');
      DOM.gaugeCursor = document.getElementById('gaugeCursor');
      DOM.gaugeContainer = document.getElementById('gaugeContainer');
      DOM.gaugeLimitLine = document.getElementById('gaugeLimitLine');
      DOM.currentPositionMM = document.getElementById('currentPositionMM');
      DOM.targetPositionMM = document.getElementById('targetPositionMM');
      DOM.positionError = document.getElementById('positionError');
      DOM.pursuitActiveCheckbox = document.getElementById('pursuitActiveCheckbox');
      DOM.btnActivatePursuit = document.getElementById('btnActivatePursuit');
      
      // Max distance limit elements
      DOM.btnConfigMaxDist = document.getElementById('btnConfigMaxDist');
      DOM.maxDistConfigPanel = document.getElementById('maxDistConfigPanel');
      DOM.maxDistLimitSlider = document.getElementById('maxDistLimitSlider');
      DOM.maxDistLimitValue = document.getElementById('maxDistLimitValue');
      DOM.maxDistLimitMM = document.getElementById('maxDistLimitMM');
      DOM.btnApplyMaxDistLimit = document.getElementById('btnApplyMaxDistLimit');
      DOM.btnCancelMaxDistLimit = document.getElementById('btnCancelMaxDistLimit');
      DOM.maxDistLimitWarning = document.getElementById('maxDistLimitWarning');
      
      // Oscillation elements
      DOM.oscCurrentAmplitude = document.getElementById('oscCurrentAmplitude');
      DOM.oscCompletedCycles = document.getElementById('oscCompletedCycles');
      DOM.oscRampStatus = document.getElementById('oscRampStatus');
      DOM.oscCenter = document.getElementById('oscCenter');
      DOM.oscAmplitude = document.getElementById('oscAmplitude');
      DOM.oscWaveform = document.getElementById('oscWaveform');
      DOM.oscFrequency = document.getElementById('oscFrequency');
      DOM.oscRampInDuration = document.getElementById('oscRampInDuration');
      DOM.oscRampOutDuration = document.getElementById('oscRampOutDuration');
      DOM.oscCycleCount = document.getElementById('oscCycleCount');
      DOM.oscRampInEnable = document.getElementById('oscRampInEnable');
      DOM.oscRampOutEnable = document.getElementById('oscRampOutEnable');
      DOM.oscReturnCenter = document.getElementById('oscReturnCenter');
      // DOM.oscRampInConfig = document.getElementById('oscRampInConfig'); // Removed in compact mode
      // DOM.oscRampOutConfig = document.getElementById('oscRampOutConfig'); // Removed in compact mode
      DOM.oscLimitWarning = document.getElementById('oscLimitWarning');
      DOM.oscLimitStatus = document.getElementById('oscLimitStatus');
      DOM.btnStartOscillation = document.getElementById('btnStartOscillation');
      
      // Logs panel
      DOM.logConsolePanel = document.getElementById('logConsolePanel');
      DOM.logsPanel = document.getElementById('logsPanel');
      DOM.btnShowLogs = document.getElementById('btnShowLogs');
      DOM.logFilesList = document.getElementById('logFilesList');
      
      // Sequencer
      DOM.seqMode = document.getElementById('seqMode');
      DOM.seqCurrentLine = document.getElementById('seqCurrentLine');
      DOM.seqLineCycle = document.getElementById('seqLineCycle');
      DOM.seqLoopCount = document.getElementById('seqLoopCount');
      DOM.seqPauseRemaining = document.getElementById('seqPauseRemaining');
      DOM.btnStartSequence = document.getElementById('btnStartSequence');
      DOM.btnLoopSequence = document.getElementById('btnLoopSequence');
      DOM.btnPauseSequence = document.getElementById('btnPauseSequence');
      DOM.btnStopSequence = document.getElementById('btnStopSequence');
      DOM.btnSkipLine = document.getElementById('btnSkipLine');
      
      // Pending changes
      DOM.pendingChanges = document.getElementById('pendingChanges');
      
      // Calibration overlay
      DOM.calibrationOverlay = document.getElementById('calibrationOverlay');
      
      // Reboot overlay
      DOM.rebootOverlay = document.getElementById('rebootOverlay');
      
      // Chaos stats
      DOM.chaosStats = document.getElementById('chaosStats');
      DOM.btnStartChaos = document.getElementById('btnStartChaos');
      DOM.btnStopChaos = document.getElementById('btnStopChaos');
      
      // Preset buttons (querySelectorAll cache for performance)
      DOM.presetStartButtons = document.querySelectorAll('[data-start]');
      DOM.presetDistanceButtons = document.querySelectorAll('[data-distance]');
      
      console.log('âœ… DOM cache initialized (' + Object.keys(DOM).length + ' elements)');
    }
    
    // ========================================================================
    // MODE SÃ©quenceur - Global Variables
    // ========================================================================
    let sequenceLines = [];
    let editingLineId = null;
    let isLoadingEditForm = false;  // Flag to prevent validation during initial load
    let currentLineIdMap = {};  // Map table index to lineId
    
    // Phase 2: Drag & Drop state
    let draggedLineId = null;
    let draggedLineIndex = null;
    let lastDragEnterTime = 0; // Throttle dragenter to avoid flicker
    
    // Phase 2: Multi-select state
    let selectedLineIds = new Set();
    let lastSelectedIndex = null;
    
    // ========================================================================
    // MODE SÃ©quenceur - Sequence Table Management
    // ========================================================================
    
    // Validate sequencer line against effectiveMaxDistanceMM
    function validateSequencerLine(line, movementType) {
      const effectiveMax = AppState.pursuit.effectiveMaxDistMM || AppState.pursuit.totalDistanceMM || 0;
      const errors = [];
      
      if (movementType === 0) {
        // VA-ET-VIENT validation
        const endPosition = line.startPositionMM + line.distanceMM;
        
        // Position dÃ©part
        if (line.startPositionMM < 0) {
          errors.push('âš ï¸ Position de dÃ©part ne peut pas Ãªtre nÃ©gative');
        }
        if (line.startPositionMM > effectiveMax) {
          errors.push(`âš ï¸ Position de dÃ©part (${line.startPositionMM.toFixed(1)}mm) dÃ©passe la course disponible (${effectiveMax.toFixed(1)}mm)`);
        }
        
        // Distance
        if (line.distanceMM <= 0) {
          errors.push('âš ï¸ Distance doit Ãªtre positive');
        }
        if (endPosition > effectiveMax) {
          errors.push(`âš ï¸ Position finale (${endPosition.toFixed(1)}mm) dÃ©passe la course disponible (${effectiveMax.toFixed(1)}mm)`);
        }
        
        // Vitesses
        if (line.speedForward < 0 || line.speedForward > 20) {
          errors.push('âš ï¸ Vitesse aller doit Ãªtre entre 0 et 20');
        }
        if (line.speedBackward < 0 || line.speedBackward > 20) {
          errors.push('âš ï¸ Vitesse retour doit Ãªtre entre 0 et 20');
        }
        
        // Zone dÃ©cÃ©lÃ©ration
        if (line.decelZoneMM < 10 || line.decelZoneMM > 200) {
          errors.push('âš ï¸ Zone de dÃ©cÃ©lÃ©ration doit Ãªtre entre 10 et 200 mm');
        }
        
      } else if (movementType === 1) {
        // OSCILLATION validation
        const minPos = line.oscCenterPositionMM - line.oscAmplitudeMM;
        const maxPos = line.oscCenterPositionMM + line.oscAmplitudeMM;
        
        // Centre & Amplitude
        if (minPos < 0) {
          errors.push(`âš ï¸ Position min (${minPos.toFixed(1)}mm) est nÃ©gative`);
        }
        if (maxPos > effectiveMax) {
          errors.push(`âš ï¸ Position max (${maxPos.toFixed(1)}mm) dÃ©passe la course disponible (${effectiveMax.toFixed(1)}mm)`);
        }
        if (line.oscAmplitudeMM <= 0) {
          errors.push('âš ï¸ Amplitude doit Ãªtre positive');
        }
        
        // FrÃ©quence
        if (line.oscFrequencyHz < 0.01 || line.oscFrequencyHz > 10) {
          errors.push('âš ï¸ FrÃ©quence doit Ãªtre entre 0.01 et 10 Hz');
        }
        
        // DurÃ©e rampes
        if (line.oscRampInDurationMs < 100 || line.oscRampInDurationMs > 10000) {
          errors.push('âš ï¸ DurÃ©e rampe IN doit Ãªtre entre 100 et 10000 ms');
        }
        if (line.oscRampOutDurationMs < 100 || line.oscRampOutDurationMs > 10000) {
          errors.push('âš ï¸ DurÃ©e rampe OUT doit Ãªtre entre 100 et 10000 ms');
        }
        
      } else if (movementType === 2) {
        // CHAOS validation
        const minPos = line.chaosCenterPositionMM - line.chaosAmplitudeMM;
        const maxPos = line.chaosCenterPositionMM + line.chaosAmplitudeMM;
        
        // Centre & Amplitude
        if (minPos < 0) {
          errors.push(`âš ï¸ Position min (${minPos.toFixed(1)}mm) est nÃ©gative`);
        }
        if (maxPos > effectiveMax) {
          errors.push(`âš ï¸ Position max (${maxPos.toFixed(1)}mm) dÃ©passe la course disponible (${effectiveMax.toFixed(1)}mm)`);
        }
        if (line.chaosAmplitudeMM <= 0) {
          errors.push('âš ï¸ Amplitude doit Ãªtre positive');
        }
        
        // Vitesse max
        if (line.chaosMaxSpeedLevel < 1 || line.chaosMaxSpeedLevel > 20) {
          errors.push('âš ï¸ Vitesse max doit Ãªtre entre 1 et 20');
        }
        
        // DegrÃ© de folie
        if (line.chaosCrazinessPercent < 0 || line.chaosCrazinessPercent > 100) {
          errors.push('âš ï¸ DegrÃ© de folie doit Ãªtre entre 0 et 100%');
        }
        
        // DurÃ©e
        if (line.chaosDurationSeconds < 5 || line.chaosDurationSeconds > 600) {
          errors.push('âš ï¸ DurÃ©e doit Ãªtre entre 5 et 600 secondes');
        }
        
        // Seed
        if (line.chaosSeed < 0 || line.chaosSeed > 9999999) {
          errors.push('âš ï¸ Seed doit Ãªtre entre 0 et 9999999');
        }
      } else if (movementType === 4) {
        // CALIBRATION - no validation needed (no parameters)
      }
      
      // Validation commune (Cycles & Pause)
      if (movementType !== 2 && movementType !== 4) {  // CHAOS uses duration, CALIBRATION force 1 cycle
        if (line.cycleCount < 1 || line.cycleCount > 1000) {
          errors.push('âš ï¸ Nombre de cycles doit Ãªtre entre 1 et 1000');
        }
      }
      
      if (line.pauseAfterMs < 0 || line.pauseAfterMs > 60000) {
        errors.push('âš ï¸ Pause doit Ãªtre entre 0 et 60 secondes');
      }
      
      return errors;
    }
    
    function addSequenceLine() {
      const effectiveMax = AppState.pursuit.effectiveMaxDistMM || AppState.pursuit.totalDistanceMM || 0;
      const center = effectiveMax / 2;
      
      const newLine = {
        enabled: true,
        movementType: 0,  // Default to VA-ET-VIENT
        
        // VA-ET-VIENT fields - use safe defaults
        startPositionMM: 0,
        distanceMM: Math.min(100, effectiveMax),  // Cap at effective max
        speedForward: 5.0,
        speedBackward: 5.0,
        decelStartEnabled: false,
        decelEndEnabled: true,
        decelZoneMM: 20,
        decelEffectPercent: 50,
        decelMode: 1,
        
        // VA-ET-VIENT cycle pause
        vaetCyclePauseEnabled: false,
        vaetCyclePauseIsRandom: false,
        vaetCyclePauseDurationSec: 0.0,
        vaetCyclePauseMinSec: 0.5,
        vaetCyclePauseMaxSec: 3.0,
        
        // OSCILLATION fields - center on effective max
        oscCenterPositionMM: center,
        oscAmplitudeMM: Math.min(50.0, center),  // Cap at center
        oscWaveform: 0,  // SINE
        oscFrequencyHz: 0.5,
        oscEnableRampIn: false,
        oscEnableRampOut: false,
        oscRampInDurationMs: 1000.0,
        oscRampOutDurationMs: 1000.0,
        
        // OSCILLATION cycle pause
        oscCyclePauseEnabled: false,
        oscCyclePauseIsRandom: false,
        oscCyclePauseDurationSec: 0.0,
        oscCyclePauseMinSec: 0.5,
        oscCyclePauseMaxSec: 3.0,
        
        // CHAOS fields - center on effective max
        chaosCenterPositionMM: center,
        chaosAmplitudeMM: Math.min(50.0, center),  // Cap at center
        chaosMaxSpeedLevel: 10.0,
        chaosCrazinessPercent: 50.0,
        chaosDurationSeconds: 30,
        chaosSeed: 0,
        chaosPatternsEnabled: [true, true, true, true, true, true, true, true, true, true, true],
        
        // COMMON fields
        cycleCount: 1,
        pauseAfterMs: 0
      };
      
      // Validate before sending
      const errors = validateSequencerLine(newLine, newLine.movementType);
      if (errors.length > 0) {
        alert('âŒ Impossible d\'ajouter la ligne :\n\n' + errors.join('\n'));
        return;
      }
      
      sendCommand(WS_CMD.ADD_SEQUENCE_LINE, newLine);
    }
    
    function deleteSequenceLine(lineId) {
      if (confirm('Supprimer cette ligne?')) {
        sendCommand(WS_CMD.DELETE_SEQUENCE_LINE, { lineId: lineId });
      }
    }
    
    function editSequenceLine(lineId) {
      console.log('ğŸ” editSequenceLine called with lineId:', lineId);
      console.log('ğŸ“‹ Available lines:', sequenceLines.map(l => ({id: l.lineId, start: l.startPositionMM})));
      
      const line = sequenceLines.find(l => l.lineId === lineId);
      if (!line) {
        console.error('âŒ Line not found! lineId:', lineId);
        return;
      }
      
      console.log('âœ… Found line:', line);
      editingLineId = lineId;
      isLoadingEditForm = true;  // Disable validation during load
      
      // Clear any previous validation errors before loading
      clearErrorFields();
      const errorContainer = document.getElementById('editValidationErrors');
      if (errorContainer) errorContainer.style.display = 'none';
      
      // Populate form
      document.getElementById('editLineNumber').textContent = sequenceLines.indexOf(line) + 1;
      
      // Movement type (default to VAET if not set)
      const movementType = line.movementType !== undefined ? line.movementType : 0;
      if (movementType === 0) {
        document.getElementById('editTypeVaet').checked = true;
      } else if (movementType === 1) {
        document.getElementById('editTypeOsc').checked = true;
      } else if (movementType === 2) {
        document.getElementById('editTypeChaos').checked = true;
      } else if (movementType === 4) {
        document.getElementById('editTypeCalibration').checked = true;
      }
      updateMovementTypeFields();  // Show/hide appropriate fields
      
      // VA-ET-VIENT fields
      document.getElementById('editStartPos').value = line.startPositionMM || 0;
      document.getElementById('editDistance').value = line.distanceMM || 100;
      document.getElementById('editSpeedFwd').value = line.speedForward || 5.0;
      document.getElementById('editSpeedBack').value = line.speedBackward || 5.0;
      document.getElementById('editDecelStart').checked = line.decelStartEnabled || false;
      document.getElementById('editDecelEnd').checked = line.decelEndEnabled !== undefined ? line.decelEndEnabled : true;
      document.getElementById('editDecelZone').value = line.decelZoneMM || 20;
      document.getElementById('editDecelEffect').value = line.decelEffectPercent || 50;
      document.getElementById('editEffectValue').textContent = line.decelEffectPercent || 50;
      document.getElementById('editDecelMode').value = line.decelMode !== undefined ? line.decelMode : 1;
      
      // OSCILLATION fields
      document.getElementById('editOscCenter').value = line.oscCenterPositionMM || 100;
      document.getElementById('editOscAmplitude').value = line.oscAmplitudeMM || 50;
      document.getElementById('editOscWaveform').value = line.oscWaveform !== undefined ? line.oscWaveform : 0;
      document.getElementById('editOscFrequency').value = line.oscFrequencyHz || 0.5;
      document.getElementById('editOscRampIn').checked = line.oscEnableRampIn || false;
      document.getElementById('editOscRampOut').checked = line.oscEnableRampOut || false;
      document.getElementById('editOscRampInDur').value = line.oscRampInDurationMs || 1000;
      document.getElementById('editOscRampOutDur').value = line.oscRampOutDurationMs || 1000;
      
      // VA-ET-VIENT Cycle Pause fields
      document.getElementById('editVaetPauseEnabled').checked = line.vaetCyclePauseEnabled || false;
      document.getElementById('editVaetPauseRandom').checked = line.vaetCyclePauseIsRandom || false;
      document.getElementById('editVaetPauseDuration').value = line.vaetCyclePauseDurationSec || 0.0;
      document.getElementById('editVaetPauseMin').value = line.vaetCyclePauseMinSec || 0.5;
      document.getElementById('editVaetPauseMax').value = line.vaetCyclePauseMaxSec || 3.0;
      
      // OSCILLATION Cycle Pause fields
      document.getElementById('editOscPauseEnabled').checked = line.oscCyclePauseEnabled || false;
      document.getElementById('editOscPauseRandom').checked = line.oscCyclePauseIsRandom || false;
      document.getElementById('editOscPauseDuration').value = line.oscCyclePauseDurationSec || 0.0;
      document.getElementById('editOscPauseMin').value = line.oscCyclePauseMinSec || 0.5;
      document.getElementById('editOscPauseMax').value = line.oscCyclePauseMaxSec || 3.0;
      
      // Trigger pause visibility updates
      document.getElementById('editVaetPauseEnabled').dispatchEvent(new Event('change'));
      document.getElementById('editOscPauseEnabled').dispatchEvent(new Event('change'));
      
      // CHAOS fields
      document.getElementById('editChaosCenter').value = line.chaosCenterPositionMM || 110;
      document.getElementById('editChaosAmplitude').value = line.chaosAmplitudeMM || 50;
      document.getElementById('editChaosSpeed').value = line.chaosMaxSpeedLevel || 10;
      document.getElementById('editChaosCraziness').value = line.chaosCrazinessPercent || 50;
      document.getElementById('editChaosDuration').value = line.chaosDurationSeconds || 30;
      document.getElementById('editChaosSeed').value = line.chaosSeed || 0;
      
      // Load chaos patterns (array of 8 booleans)
      if (line.chaosPatternsEnabled && line.chaosPatternsEnabled.length === 11) {
        for (let i = 0; i < 11; i++) {
          const checkbox = document.querySelector(`input[name="chaosPattern${i}"]`);
          if (checkbox) checkbox.checked = line.chaosPatternsEnabled[i];
        }
      }
      
      // COMMON fields
      document.getElementById('editCycles').value = line.cycleCount || 1;
      document.getElementById('editPause').value = ((line.pauseAfterMs || 0) / 1000).toFixed(1);  // Convert ms to seconds
      
      // Populate playlist dropdowns if playlists are loaded
      if (PlaylistState.loaded) {
        populateSequencerDropdown('simple');
        populateSequencerDropdown('oscillation');
        populateSequencerDropdown('chaos');
      }
      
      // Show modal
      document.getElementById('editLineModal').style.display = 'block';
      
      // Re-enable validation after form is fully loaded
      isLoadingEditForm = false;
    }
    
    function saveLineEdit(event) {
      event.preventDefault();
      
      const form = document.getElementById('editLineForm');
      const movementType = parseInt(form.movementType.value);
      
      const updatedLine = {
        lineId: editingLineId,
        enabled: true,  // Keep enabled when editing
        movementType: movementType,
        
        // VA-ET-VIENT fields
        startPositionMM: parseFloat(form.startPositionMM.value),
        distanceMM: parseFloat(form.distanceMM.value),
        speedForward: parseFloat(form.speedForward.value),
        speedBackward: parseFloat(form.speedBackward.value),
        decelStartEnabled: form.decelStartEnabled.checked,
        decelEndEnabled: form.decelEndEnabled.checked,
        decelZoneMM: parseFloat(form.decelZoneMM.value),
        decelEffectPercent: parseFloat(form.decelEffectPercent.value),
        decelMode: parseInt(form.decelMode.value),
        
        // OSCILLATION fields
        oscCenterPositionMM: parseFloat(form.oscCenterPositionMM.value),
        oscAmplitudeMM: parseFloat(form.oscAmplitudeMM.value),
        oscWaveform: parseInt(form.oscWaveform.value),
        oscFrequencyHz: parseFloat(form.oscFrequencyHz.value),
        oscEnableRampIn: form.oscEnableRampIn.checked,
        oscEnableRampOut: form.oscEnableRampOut.checked,
        oscRampInDurationMs: parseFloat(form.oscRampInDurationMs.value),
        oscRampOutDurationMs: parseFloat(form.oscRampOutDurationMs.value),
        
        // VA-ET-VIENT Cycle Pause
        vaetCyclePauseEnabled: form.vaetCyclePauseEnabled.checked,
        vaetCyclePauseIsRandom: form.vaetCyclePauseIsRandom.checked,
        vaetCyclePauseDurationSec: parseFloat(form.vaetCyclePauseDurationSec.value),
        vaetCyclePauseMinSec: parseFloat(form.vaetCyclePauseMinSec.value),
        vaetCyclePauseMaxSec: parseFloat(form.vaetCyclePauseMaxSec.value),
        
        // OSCILLATION Cycle Pause
        oscCyclePauseEnabled: form.oscCyclePauseEnabled.checked,
        oscCyclePauseIsRandom: form.oscCyclePauseIsRandom.checked,
        oscCyclePauseDurationSec: parseFloat(form.oscCyclePauseDurationSec.value),
        oscCyclePauseMinSec: parseFloat(form.oscCyclePauseMinSec.value),
        oscCyclePauseMaxSec: parseFloat(form.oscCyclePauseMaxSec.value),
        
        // CHAOS fields
        chaosCenterPositionMM: parseFloat(form.chaosCenterPositionMM.value),
        chaosAmplitudeMM: parseFloat(form.chaosAmplitudeMM.value),
        chaosMaxSpeedLevel: parseFloat(form.chaosMaxSpeedLevel.value),
        chaosCrazinessPercent: parseFloat(form.chaosCrazinessPercent.value),
        chaosDurationSeconds: parseInt(form.chaosDurationSeconds.value),
        chaosSeed: parseInt(form.chaosSeed.value),
        chaosPatternsEnabled: [
          form.chaosPattern0.checked,
          form.chaosPattern1.checked,
          form.chaosPattern2.checked,
          form.chaosPattern3.checked,
          form.chaosPattern4.checked,
          form.chaosPattern5.checked,
          form.chaosPattern6.checked,
          form.chaosPattern7.checked,
          form.chaosPattern8.checked,
          form.chaosPattern9.checked,
          form.chaosPattern10.checked
        ],
        
        // COMMON fields
        cycleCount: parseInt(form.cycleCount.value),
        pauseAfterMs: Math.round(parseFloat(form.pauseAfterSec.value) * 1000)  // Convert seconds to ms
      };
      
      // Validate before sending (should already be validated by real-time validation)
      const errors = validateSequencerLine(updatedLine, movementType);
      if (errors.length > 0) {
        // This shouldn't happen if validation is working, but just in case
        console.error('Validation errors on save:', errors);
        validateEditForm();  // Update UI
        return; // Don't close modal, let user fix
      }
      
      sendCommand(WS_CMD.UPDATE_SEQUENCE_LINE, updatedLine);
      closeEditModal();
    }
    
    // Validate edit form in real-time
    function validateEditForm() {
      // Skip validation during initial form load
      if (isLoadingEditForm) return;
      
      const form = document.getElementById('editLineForm');
      const movementType = parseInt(form.movementType.value);
      
      // Check for empty fields (indicates invalid character like "Ã©" was typed)
      const emptyFieldErrors = [];
      
      // VA-ET-VIENT fields
      if (movementType === 0) {
        if (form.startPositionMM.value.trim() === '') emptyFieldErrors.push('âš ï¸ Position de dÃ©part est incorrect');
        if (form.distanceMM.value.trim() === '') emptyFieldErrors.push('âš ï¸ Distance est incorrect');
        if (form.speedForward.value.trim() === '') emptyFieldErrors.push('âš ï¸ Vitesse aller est incorrect');
        if (form.speedBackward.value.trim() === '') emptyFieldErrors.push('âš ï¸ Vitesse retour est incorrect');
        if (form.decelZoneMM.value.trim() === '') emptyFieldErrors.push('âš ï¸ Zone dÃ©cÃ©lÃ©ration est incorrect');
      }
      
      // OSCILLATION fields
      if (movementType === 1) {
        if (form.oscCenterPositionMM.value.trim() === '') emptyFieldErrors.push('âš ï¸ Centre oscillation est incorrect');
        if (form.oscAmplitudeMM.value.trim() === '') emptyFieldErrors.push('âš ï¸ Amplitude oscillation est incorrect');
        if (form.oscFrequencyHz.value.trim() === '') emptyFieldErrors.push('âš ï¸ FrÃ©quence est incorrect');
        if (form.oscRampInDurationMs.value.trim() === '') emptyFieldErrors.push('âš ï¸ DurÃ©e rampe IN est incorrect');
        if (form.oscRampOutDurationMs.value.trim() === '') emptyFieldErrors.push('âš ï¸ DurÃ©e rampe OUT est incorrect');
      }
      
      // CHAOS fields
      if (movementType === 2) {
        if (form.chaosCenterPositionMM.value.trim() === '') emptyFieldErrors.push('âš ï¸ Centre chaos est incorrect');
        if (form.chaosAmplitudeMM.value.trim() === '') emptyFieldErrors.push('âš ï¸ Amplitude chaos est incorrect');
        if (form.chaosMaxSpeedLevel.value.trim() === '') emptyFieldErrors.push('âš ï¸ Vitesse max chaos est incorrect');
        if (form.chaosCrazinessPercent.value.trim() === '') emptyFieldErrors.push('âš ï¸ DegrÃ© de folie est incorrect');
        if (form.chaosDurationSeconds.value.trim() === '') emptyFieldErrors.push('âš ï¸ DurÃ©e chaos est incorrect');
        if (form.chaosSeed.value.trim() === '') emptyFieldErrors.push('âš ï¸ Seed est incorrect');
      }
      
      // COMMON fields (for all types except CALIBRATION)
      if (movementType !== 4) {
        if (movementType !== 2 && form.cycleCount.value.trim() === '') {
          emptyFieldErrors.push('âš ï¸ Nombre de cycles est incorrect');
        }
        if (form.pauseAfterSec.value.trim() === '') {
          emptyFieldErrors.push('âš ï¸ Pause est incorrect');
        }
      }
      
      // Build line object from current form values (ALL fields for complete validation)
      const line = {
        movementType: movementType,
        
        // VA-ET-VIENT
        startPositionMM: parseFloat(form.startPositionMM.value) || 0,
        distanceMM: parseFloat(form.distanceMM.value) || 0,
        speedForward: parseFloat(form.speedForward.value) || 0,
        speedBackward: parseFloat(form.speedBackward.value) || 0,
        decelZoneMM: parseFloat(form.decelZoneMM.value) || 0,
        
        // OSCILLATION
        oscCenterPositionMM: parseFloat(form.oscCenterPositionMM.value) || 0,
        oscAmplitudeMM: parseFloat(form.oscAmplitudeMM.value) || 0,
        oscFrequencyHz: parseFloat(form.oscFrequencyHz.value) || 0,
        oscRampInDurationMs: parseFloat(form.oscRampInDurationMs.value) || 0,
        oscRampOutDurationMs: parseFloat(form.oscRampOutDurationMs.value) || 0,
        
        // CHAOS
        chaosCenterPositionMM: parseFloat(form.chaosCenterPositionMM.value) || 0,
        chaosAmplitudeMM: parseFloat(form.chaosAmplitudeMM.value) || 0,
        chaosMaxSpeedLevel: parseFloat(form.chaosMaxSpeedLevel.value) || 0,
        chaosCrazinessPercent: parseFloat(form.chaosCrazinessPercent.value) || 0,
        chaosDurationSeconds: parseInt(form.chaosDurationSeconds.value) || 0,
        chaosSeed: parseInt(form.chaosSeed.value) || 0,
        
        // COMMON
        cycleCount: parseInt(form.cycleCount.value) || 0,
        pauseAfterMs: Math.round(parseFloat(form.pauseAfterSec.value) * 1000) || 0
      };
      
      // Validate (combine empty field errors with validation errors)
      const validationErrors = validateSequencerLine(line, movementType);
      const errors = emptyFieldErrors.concat(validationErrors);
      
      // Update UI
      const errorContainer = document.getElementById('editValidationErrors');
      const errorList = document.getElementById('editValidationErrorsList');
      const saveButton = document.getElementById('btnSaveEdit');
      
      if (errors.length > 0) {
        // Show errors
        errorContainer.style.display = 'block';
        errorList.innerHTML = errors.map(err => '<li>' + err + '</li>').join('');
        
        // Disable save button
        saveButton.disabled = true;
        saveButton.style.opacity = '0.5';
        saveButton.style.cursor = 'not-allowed';
        
        // Highlight error fields (including empty ones)
        highlightErrorFields(movementType, line, emptyFieldErrors);
      } else {
        // Hide errors
        errorContainer.style.display = 'none';
        errorList.innerHTML = '';
        
        // Enable save button
        saveButton.disabled = false;
        saveButton.style.opacity = '1';
        saveButton.style.cursor = 'pointer';
        
        // Clear all highlights
        clearErrorFields();
      }
    }
    
    // Highlight fields that have validation errors
    function highlightErrorFields(movementType, line, emptyFieldErrors) {
      clearErrorFields();
      
      const form = document.getElementById('editLineForm');
      const effectiveMax = AppState.pursuit.effectiveMaxDistMM || AppState.pursuit.totalDistanceMM || 0;
      
      // Check for empty fields and highlight them
      if (emptyFieldErrors && emptyFieldErrors.length > 0) {
        emptyFieldErrors.forEach(error => {
          if (error.includes('Position de dÃ©part')) {
            document.getElementById('editStartPos').style.border = '2px solid #f44336';
          }
          if (error.includes('Distance')) {
            document.getElementById('editDistance').style.border = '2px solid #f44336';
          }
          if (error.includes('Vitesse aller')) {
            document.getElementById('editSpeedFwd').style.border = '2px solid #f44336';
          }
          if (error.includes('Vitesse retour')) {
            document.getElementById('editSpeedBack').style.border = '2px solid #f44336';
          }
          if (error.includes('Zone dÃ©cÃ©lÃ©ration')) {
            document.getElementById('editDecelZone').style.border = '2px solid #f44336';
          }
          if (error.includes('Centre oscillation')) {
            document.getElementById('editOscCenter').style.border = '2px solid #f44336';
          }
          if (error.includes('Amplitude oscillation')) {
            document.getElementById('editOscAmplitude').style.border = '2px solid #f44336';
          }
          if (error.includes('FrÃ©quence')) {
            document.getElementById('editOscFrequency').style.border = '2px solid #f44336';
          }
          if (error.includes('DurÃ©e rampe IN')) {
            document.getElementById('editOscRampInDur').style.border = '2px solid #f44336';
          }
          if (error.includes('DurÃ©e rampe OUT')) {
            document.getElementById('editOscRampOutDur').style.border = '2px solid #f44336';
          }
          if (error.includes('Centre chaos')) {
            document.getElementById('editChaosCenter').style.border = '2px solid #f44336';
          }
          if (error.includes('Amplitude chaos')) {
            document.getElementById('editChaosAmplitude').style.border = '2px solid #f44336';
          }
          if (error.includes('Vitesse max chaos')) {
            document.getElementById('editChaosSpeed').style.border = '2px solid #f44336';
          }
          if (error.includes('DegrÃ© de folie')) {
            document.getElementById('editChaosCraziness').style.border = '2px solid #f44336';
          }
          if (error.includes('DurÃ©e chaos')) {
            document.getElementById('editChaosDuration').style.border = '2px solid #f44336';
          }
          if (error.includes('Seed')) {
            document.getElementById('editChaosSeed').style.border = '2px solid #f44336';
          }
          if (error.includes('Nombre de cycles')) {
            document.getElementById('editCycles').style.border = '2px solid #f44336';
          }
          if (error.includes('Pause')) {
            document.getElementById('editPause').style.border = '2px solid #f44336';
          }
        });
      }
      
      if (movementType === 0) {
        // VA-ET-VIENT
        const endPosition = line.startPositionMM + line.distanceMM;
        
        // Position dÃ©part
        if (line.startPositionMM < 0 || line.startPositionMM > effectiveMax) {
          document.getElementById('editStartPos').style.border = '2px solid #f44336';
        }
        
        // Distance
        if (endPosition > effectiveMax || line.distanceMM <= 0) {
          document.getElementById('editDistance').style.border = '2px solid #f44336';
        }
        
        // Vitesses
        if (line.speedForward < 0 || line.speedForward > 20) {
          document.getElementById('editSpeedFwd').style.border = '2px solid #f44336';
        }
        if (line.speedBackward < 0 || line.speedBackward > 20) {
          document.getElementById('editSpeedBack').style.border = '2px solid #f44336';
        }
        
        // Zone dÃ©cÃ©lÃ©ration
        if (line.decelZoneMM < 10 || line.decelZoneMM > 200) {
          document.getElementById('editDecelZone').style.border = '2px solid #f44336';
        }
        
      } else if (movementType === 1) {
        // OSCILLATION
        const minPos = line.oscCenterPositionMM - line.oscAmplitudeMM;
        const maxPos = line.oscCenterPositionMM + line.oscAmplitudeMM;
        
        // Centre & Amplitude
        if (minPos < 0 || maxPos > effectiveMax) {
          document.getElementById('editOscCenter').style.border = '2px solid #f44336';
        }
        if (line.oscAmplitudeMM <= 0 || maxPos > effectiveMax) {
          document.getElementById('editOscAmplitude').style.border = '2px solid #f44336';
        }
        
        // FrÃ©quence
        if (line.oscFrequencyHz < 0.01 || line.oscFrequencyHz > 10) {
          document.getElementById('editOscFrequency').style.border = '2px solid #f44336';
        }
        
        // DurÃ©e rampes
        if (line.oscRampInDurationMs < 100 || line.oscRampInDurationMs > 10000) {
          document.getElementById('editOscRampInDur').style.border = '2px solid #f44336';
        }
        if (line.oscRampOutDurationMs < 100 || line.oscRampOutDurationMs > 10000) {
          document.getElementById('editOscRampOutDur').style.border = '2px solid #f44336';
        }
        
      } else if (movementType === 2) {
        // CHAOS
        const minPos = line.chaosCenterPositionMM - line.chaosAmplitudeMM;
        const maxPos = line.chaosCenterPositionMM + line.chaosAmplitudeMM;
        
        // Centre & Amplitude
        if (minPos < 0 || maxPos > effectiveMax) {
          document.getElementById('editChaosCenter').style.border = '2px solid #f44336';
        }
        if (line.chaosAmplitudeMM <= 0 || maxPos > effectiveMax) {
          document.getElementById('editChaosAmplitude').style.border = '2px solid #f44336';
        }
        
        // Vitesse max
        if (line.chaosMaxSpeedLevel < 1 || line.chaosMaxSpeedLevel > 20) {
          document.getElementById('editChaosSpeed').style.border = '2px solid #f44336';
        }
        
        // DegrÃ© de folie
        if (line.chaosCrazinessPercent < 0 || line.chaosCrazinessPercent > 100) {
          document.getElementById('editChaosCraziness').style.border = '2px solid #f44336';
        }
        
        // DurÃ©e
        if (line.chaosDurationSeconds < 5 || line.chaosDurationSeconds > 600) {
          document.getElementById('editChaosDuration').style.border = '2px solid #f44336';
        }
        
        // Seed
        if (line.chaosSeed < 0 || line.chaosSeed > 9999999) {
          document.getElementById('editChaosSeed').style.border = '2px solid #f44336';
        }
      }
      
      // Validation commune
      if (movementType !== 2 && movementType !== 4) {  // CHAOS & CALIBRATION
        if (line.cycleCount < 1 || line.cycleCount > 1000) {
          document.getElementById('editCycles').style.border = '2px solid #f44336';
        }
      }
      
      if (line.pauseAfterMs < 0 || line.pauseAfterMs > 60000) {
        document.getElementById('editPause').style.border = '2px solid #f44336';
      }
    }
    
    // Clear all error field highlights
    function clearErrorFields() {
      const fields = [
        // VA-ET-VIENT
        'editStartPos', 'editDistance', 'editSpeedFwd', 'editSpeedBack', 'editDecelZone',
        // OSCILLATION
        'editOscCenter', 'editOscAmplitude', 'editOscFrequency',
        'editOscRampInDur', 'editOscRampOutDur',
        // CHAOS
        'editChaosCenter', 'editChaosAmplitude', 'editChaosSpeed', 'editChaosCraziness',
        'editChaosDuration', 'editChaosSeed',
        // COMMON
        'editCycles', 'editPause'
      ];
      fields.forEach(fieldId => {
        const field = document.getElementById(fieldId);
        if (field) field.style.border = '2px solid #ddd';
      });
    }
    
    // Toggle visibility of fields based on movement type
    function updateMovementTypeFields() {
      const isVaet = document.getElementById('editTypeVaet').checked;
      const isOsc = document.getElementById('editTypeOsc').checked;
      const isChaos = document.getElementById('editTypeChaos').checked;
      const isCalibration = document.getElementById('editTypeCalibration').checked;
      
      document.getElementById('vaetFields').style.display = isVaet ? 'block' : 'none';
      document.getElementById('oscFields').style.display = isOsc ? 'block' : 'none';
      document.getElementById('chaosFields').style.display = isChaos ? 'block' : 'none';
      
      // Show/hide playlist loaders based on type
      document.getElementById('playlistLoaderSimple').style.display = isVaet ? 'block' : 'none';
      document.getElementById('playlistLoaderOscillation').style.display = isOsc ? 'block' : 'none';
      document.getElementById('playlistLoaderChaos').style.display = isChaos ? 'block' : 'none';
      
      // Hide cycles field for CHAOS (uses duration) and CALIBRATION (always 1 cycle)
      document.getElementById('cyclesFieldDiv').style.display = (isChaos || isCalibration) ? 'none' : 'block';
      // Pause is available for all types
      document.getElementById('pauseFieldDiv').style.display = 'block';
      
      // Revalidate when type changes
      validateEditForm();
    }
    
    function closeEditModal() {
      document.getElementById('editLineModal').style.display = 'none';
      editingLineId = null;
      
      // Clear any validation errors when closing modal
      clearErrorFields();
      const errorContainer = document.getElementById('editValidationErrors');
      if (errorContainer) errorContainer.style.display = 'none';
      
      // Re-enable save button
      const saveButton = document.getElementById('btnSaveEdit');
      if (saveButton) {
        saveButton.disabled = false;
        saveButton.style.opacity = '1';
        saveButton.style.cursor = 'pointer';
      }
    }
    
    function closeEditLineModalOnOverlayClick(event) {
      // Only close if clicking on the overlay itself (not the content)
      if (event.target.id === 'editLineModal') {
        closeEditModal();
      }
    }
    
    // ========================================================================
    // PLAYLIST INTEGRATION IN SEQUENCER
    // ========================================================================
    
    /**
     * Populate sequencer modal dropdown with presets for a specific mode
     */
    function populateSequencerDropdown(mode) {
      const selectId = 'edit' + mode.charAt(0).toUpperCase() + mode.slice(1) + 'PresetSelect';
      const select = document.getElementById(selectId);
      if (!select) return;
      
      const presets = PlaylistState[mode] || [];
      
      // Clear existing options (except first "-- SÃ©lectionner --")
      select.innerHTML = '<option value="">-- SÃ©lectionner un preset --</option>';
      
      // Add presets (sorted by timestamp desc - most recent first)
      const sortedPresets = [...presets].sort((a, b) => b.timestamp - a.timestamp);
      sortedPresets.forEach(preset => {
        const option = document.createElement('option');
        option.value = preset.id;
        option.textContent = preset.name;
        select.appendChild(option);
      });
    }
    
    /**
     * Preview a preset from sequencer dropdown
     */
    function previewSequencerPreset(mode, presetId) {
      if (!presetId) {
        hidePlaylistTooltip();
        return;
      }
      
      const id = parseInt(presetId);
      const preset = PlaylistState[mode].find(p => p.id === id);
      
      if (!preset) {
        hidePlaylistTooltip();
        return;
      }
      
      const tooltipContent = generatePresetTooltip(mode, preset.config);
      const overlay = document.getElementById('playlistTooltipOverlay');
      
      if (overlay && tooltipContent) {
        overlay.innerHTML = `<div style="font-weight: 600; margin-bottom: 8px; font-size: 13px;">ğŸ“‹ ${preset.name}</div>` + tooltipContent;
        overlay.classList.add('visible');
        
        // Auto-hide after 5 seconds
        setTimeout(() => {
          overlay.classList.remove('visible');
        }, 5000);
      }
    }
    
    /**
     * Quick Add preset directly to sequencer (from playlist modal)
     */
    function quickAddToSequencer(mode, presetId) {
      const preset = PlaylistState[mode].find(p => p.id === presetId);
      if (!preset) {
        showNotification('âŒ Preset introuvable', 'error', 2000);
        return;
      }
      
      const config = preset.config;
      const effectiveMax = AppState.pursuit.effectiveMaxDistMM || AppState.pursuit.totalDistanceMM || 200;
      const center = effectiveMax / 2;
      
      // Build sequencer line based on mode
      let newLine = {
        enabled: true,
        cycleCount: 1,
        pauseAfterMs: 0
      };
      
      if (mode === 'simple') {
        newLine.movementType = 0;  // VA-ET-VIENT
        newLine.startPositionMM = config.startPositionMM || 0;
        newLine.distanceMM = config.distanceMM || 50;
        newLine.speedForward = config.speedLevelForward || 5;
        newLine.speedBackward = config.speedLevelBackward || 5;
        newLine.decelStartEnabled = config.decelStartEnabled || false;
        newLine.decelEndEnabled = config.decelEndEnabled !== undefined ? config.decelEndEnabled : true;
        newLine.decelZoneMM = config.decelZoneMM || 20;
        newLine.decelEffectPercent = config.decelEffectPercent || 50;
        newLine.decelMode = config.decelMode || 1;
        
        // VA-ET-VIENT Cycle Pause (from preset config)
        newLine.vaetCyclePauseEnabled = config.cyclePauseEnabled || false;
        newLine.vaetCyclePauseIsRandom = config.cyclePauseIsRandom || false;
        newLine.vaetCyclePauseDurationSec = config.cyclePauseDurationSec || 0.0;
        newLine.vaetCyclePauseMinSec = config.cyclePauseMinSec || 0.5;
        newLine.vaetCyclePauseMaxSec = config.cyclePauseMaxSec || 3.0;
        
        // Default oscillation fields
        newLine.oscCenterPositionMM = center;
        newLine.oscAmplitudeMM = Math.min(50, center);
        newLine.oscWaveform = 0;
        newLine.oscFrequencyHz = 0.5;
        newLine.oscEnableRampIn = false;
        newLine.oscEnableRampOut = false;
        newLine.oscRampInDurationMs = 1000;
        newLine.oscRampOutDurationMs = 1000;
        
        // Default chaos fields
        newLine.chaosCenterPositionMM = center;
        newLine.chaosAmplitudeMM = Math.min(50, center);
        newLine.chaosMaxSpeedLevel = 10;
        newLine.chaosCrazinessPercent = 50;
        newLine.chaosDurationSeconds = 30;
        newLine.chaosSeed = 0;
        newLine.chaosPatternsEnabled = [true, true, true, true, true, true, true, true, true, true, true];
        
      } else if (mode === 'oscillation') {
        newLine.movementType = 1;  // OSCILLATION
        newLine.oscCenterPositionMM = config.centerPositionMM || center;
        newLine.oscAmplitudeMM = config.amplitudeMM || 50;
        newLine.oscWaveform = config.waveform || 0;
        newLine.oscFrequencyHz = config.frequencyHz || 0.5;
        newLine.oscEnableRampIn = config.enableRampIn || false;
        newLine.oscEnableRampOut = config.enableRampOut || false;
        newLine.oscRampInDurationMs = config.rampInDurationMs || 1000;
        newLine.oscRampOutDurationMs = config.rampOutDurationMs || 1000;
        newLine.cycleCount = config.cycleCount || 1;
        
        // OSCILLATION Cycle Pause (from preset config)
        newLine.oscCyclePauseEnabled = config.cyclePauseEnabled || false;
        newLine.oscCyclePauseIsRandom = config.cyclePauseIsRandom || false;
        newLine.oscCyclePauseDurationSec = config.cyclePauseDurationSec || 0.0;
        newLine.oscCyclePauseMinSec = config.cyclePauseMinSec || 0.5;
        newLine.oscCyclePauseMaxSec = config.cyclePauseMaxSec || 3.0;
        
        // Default VA-ET-VIENT fields
        newLine.startPositionMM = 0;
        newLine.distanceMM = Math.min(100, effectiveMax);
        newLine.speedForward = 5;
        newLine.speedBackward = 5;
        newLine.decelStartEnabled = false;
        newLine.decelEndEnabled = true;
        newLine.decelZoneMM = 20;
        newLine.decelEffectPercent = 50;
        newLine.decelMode = 1;
        
        // Default chaos fields
        newLine.chaosCenterPositionMM = center;
        newLine.chaosAmplitudeMM = Math.min(50, center);
        newLine.chaosMaxSpeedLevel = 10;
        newLine.chaosCrazinessPercent = 50;
        newLine.chaosDurationSeconds = 30;
        newLine.chaosSeed = 0;
        newLine.chaosPatternsEnabled = [true, true, true, true, true, true, true, true, true, true, true];
        
      } else if (mode === 'chaos') {
        newLine.movementType = 2;  // CHAOS
        newLine.chaosCenterPositionMM = config.centerPositionMM || center;
        newLine.chaosAmplitudeMM = config.amplitudeMM || 50;
        newLine.chaosMaxSpeedLevel = config.maxSpeedLevel || 10;
        newLine.chaosCrazinessPercent = config.crazinessPercent || 50;
        newLine.chaosDurationSeconds = config.durationSeconds || 30;
        newLine.chaosSeed = config.seed || 0;
        newLine.chaosPatternsEnabled = config.patternsEnabled || [true, true, true, true, true, true, true, true, true, true, true];
        
        // Default VA-ET-VIENT fields
        newLine.startPositionMM = 0;
        newLine.distanceMM = Math.min(100, effectiveMax);
        newLine.speedForward = 5;
        newLine.speedBackward = 5;
        newLine.decelStartEnabled = false;
        newLine.decelEndEnabled = true;
        newLine.decelZoneMM = 20;
        newLine.decelEffectPercent = 50;
        newLine.decelMode = 1;
        
        // Default oscillation fields
        newLine.oscCenterPositionMM = center;
        newLine.oscAmplitudeMM = Math.min(50, center);
        newLine.oscWaveform = 0;
        newLine.oscFrequencyHz = 0.5;
        newLine.oscEnableRampIn = false;
        newLine.oscEnableRampOut = false;
        newLine.oscRampInDurationMs = 1000;
        newLine.oscRampOutDurationMs = 1000;
      }
      
      // Validate before sending
      const errors = validateSequencerLine(newLine, newLine.movementType);
      if (errors.length > 0) {
        showNotification('âŒ Preset invalide pour sÃ©quenceur:\n' + errors.join('\n'), 'error', 5000);
        return;
      }
      
      // Send to backend
      sendCommand(WS_CMD.ADD_SEQUENCE_LINE, newLine);
      showNotification('âœ… Ligne ajoutÃ©e au sÃ©quenceur: ' + preset.name, 'success', 3000);
      
      console.log('âœ… Quick Add to sequencer:', preset.name, newLine);
    }
    
    /**
     * Load a preset from playlist into sequencer edit modal
     */
    function loadPresetIntoSequencerModal(mode) {
      const selectId = 'edit' + mode.charAt(0).toUpperCase() + mode.slice(1) + 'PresetSelect';
      const select = document.getElementById(selectId);
      const presetId = parseInt(select.value);
      
      if (!presetId) {
        showNotification('âš ï¸ Veuillez sÃ©lectionner un preset', 'error', 2000);
        return;
      }
      
      const preset = PlaylistState[mode].find(p => p.id === presetId);
      if (!preset) {
        showNotification('âŒ Preset introuvable', 'error', 2000);
        return;
      }
      
      const config = preset.config;
      
      // Fill sequencer modal fields based on mode
      if (mode === 'simple') {
        document.getElementById('editStartPos').value = config.startPositionMM || 0;
        document.getElementById('editDistance').value = config.distanceMM || 50;
        document.getElementById('editSpeedFwd').value = config.speedLevelForward || 5;
        document.getElementById('editSpeedBack').value = config.speedLevelBackward || 5;
      } else if (mode === 'oscillation') {
        document.getElementById('editOscCenter').value = config.centerPositionMM || 100;
        document.getElementById('editOscAmplitude').value = config.amplitudeMM || 20;
        document.getElementById('editOscWaveform').value = config.waveform || 0;
        document.getElementById('editOscFrequency').value = config.frequencyHz || 1.0;
        document.getElementById('editOscRampIn').checked = config.enableRampIn || false;
        document.getElementById('editOscRampInDur').value = config.rampInDurationMs || 2000;
        document.getElementById('editOscRampOut').checked = config.enableRampOut || false;
        document.getElementById('editOscRampOutDur').value = config.rampOutDurationMs || 2000;
        
        // Cycles (0 = infinite not allowed in sequencer, use stored value or default to 10)
        const cycleValue = config.cycleCount === 0 ? 10 : config.cycleCount;
        document.getElementById('editCycles').value = cycleValue;
      } else if (mode === 'chaos') {
        document.getElementById('editChaosCenter').value = config.centerPositionMM || 100;
        document.getElementById('editChaosAmplitude').value = config.amplitudeMM || 40;
        document.getElementById('editChaosSpeed').value = config.maxSpeedLevel || 15;
        document.getElementById('editChaosCraziness').value = config.crazinessPercent || 50;
        document.getElementById('editChaosDuration').value = config.durationSeconds || 30;
        document.getElementById('editChaosSeed').value = 0; // Default seed
        
        // Set pattern checkboxes
        if (config.patternsEnabled && Array.isArray(config.patternsEnabled)) {
          for (let i = 0; i < config.patternsEnabled.length && i < 11; i++) {
            const checkbox = document.querySelector(`#chaosFields input[name="chaosPattern${i}"]`);
            if (checkbox) {
              checkbox.checked = config.patternsEnabled[i];
            }
          }
        }
      }
      
      // Trigger validation to update UI state
      validateEditForm();
      
      showNotification('âœ… Valeurs chargÃ©es depuis: ' + preset.name, 'success', 2000);
    }
    
    function moveSequenceLine(lineId, direction) {
      sendCommand(WS_CMD.MOVE_SEQUENCE_LINE, { lineId: lineId, direction: direction });
    }
    
    function duplicateSequenceLine(lineId) {
      sendCommand(WS_CMD.DUPLICATE_SEQUENCE_LINE, { lineId: lineId });
    }
    
    /**
     * Test a single line by disabling others (replaceSequence doesn't exist in backend)
     */
    function testSequenceLine(lineId) {
      const line = sequenceLines.find(l => l.lineId === lineId);
      if (!line) {
        showNotification('âŒ Ligne introuvable', 'error', 2000);
        return;
      }
      
      // Check if sequence is currently running
      if (AppState.sequencer && AppState.sequencer.isRunning) {
        showNotification('âš ï¸ ArrÃªtez la sÃ©quence en cours avant de tester', 'error', 3000);
        return;
      }
      
      // Backup current sequence state (enabled flags + cycle counts)
      window.sequenceBackup = sequenceLines.map(l => ({ 
        lineId: l.lineId, 
        enabled: l.enabled, 
        cycleCount: l.cycleCount 
      }));
      window.testedLineId = lineId;
      window.isTestingLine = true;
      
      console.log('ğŸ§ª Testing line #' + lineId + ' - Temporarily disabling other lines');
      
      // Disable all lines except the one we want to test
      sequenceLines.forEach(l => {
        if (l.lineId === lineId) {
          // Target line: ensure enabled (keep original cycle count - test full line!)
          if (!l.enabled) {
            sendCommand(WS_CMD.TOGGLE_SEQUENCE_LINE, { lineId: l.lineId, enabled: true });
            l.enabled = true;
          }
          // Don't modify cycleCount - we want to test the line as configured
        } else {
          // Other lines: temporarily disable
          if (l.enabled) {
            sendCommand(WS_CMD.TOGGLE_SEQUENCE_LINE, { lineId: l.lineId, enabled: false });
            l.enabled = false;
          }
        }
      });
      
      // Update visual state of lines without full re-render (to preserve selection)
      sequenceLines.forEach((l, idx) => {
        const row = document.querySelector(`tr[data-line-id="${l.lineId}"]`);
        if (row) {
          row.style.background = l.enabled ? 'white' : '#f5f5f5';
          row.style.opacity = l.enabled ? '1' : '0.6';
        }
      });
      
      // Disable ALL test buttons during test
      document.querySelectorAll('[id^="btnTestLine_"]').forEach(btn => {
        btn.disabled = true;
        btn.style.opacity = '0.5';
        btn.style.cursor = 'not-allowed';
      });
      
      // Start sequence after commands are sent
      setTimeout(() => {
        // Disable Unique and Boucle buttons JUST BEFORE starting
        // Use setButtonState to ensure it overrides any other state management
        console.log('ğŸ” About to disable buttons before startSequence, isTestingLine=', window.isTestingLine);
        if (DOM.btnStartSequence) {
          setButtonState(DOM.btnStartSequence, false);
          console.log('âœ… btnStartSequence disabled via setButtonState');
        }
        if (DOM.btnLoopSequence) {
          setButtonState(DOM.btnLoopSequence, false);
          console.log('âœ… btnLoopSequence disabled via setButtonState');
        }
        
        sendCommand(WS_CMD.START_SEQUENCE, {});
        const testedLine = sequenceLines.find(l => l.lineId === lineId);
        const cycleText = testedLine ? testedLine.cycleCount + ' cycle(s)' : '';
        showNotification('ğŸ§ª Test ligne #' + lineId + ' (' + cycleText + ')', 'info', 3000);
      }, 500);
    }
    
    /**
     * Restore original sequence after test
     */
    function restoreSequenceAfterTest() {
      if (!window.isTestingLine || !window.sequenceBackup) return;
      
      console.log('ğŸ”„ Restoring sequence original state');
      
      // Restore enabled flags only (cycleCount was not modified)
      window.sequenceBackup.forEach(backup => {
        const line = sequenceLines.find(l => l.lineId === backup.lineId);
        if (line && line.enabled !== backup.enabled) {
          sendCommand(WS_CMD.TOGGLE_SEQUENCE_LINE, { lineId: backup.lineId, enabled: backup.enabled });
          line.enabled = backup.enabled;
        }
      });
      
      // Clear test state FIRST (before re-render)
      window.isTestingLine = false;
      
      // Refresh UI (this will NOT re-disable buttons now that isTestingLine=false)
      renderSequenceTable();
      
      // Re-enable Unique and Boucle buttons immediately using setButtonState
      // No setTimeout needed since isTestingLine is already false
      if (DOM.btnStartSequence) {
        setButtonState(DOM.btnStartSequence, true);
        console.log('âœ… btnStartSequence re-enabled after test');
      }
      if (DOM.btnLoopSequence) {
        setButtonState(DOM.btnLoopSequence, true);
        console.log('âœ… btnLoopSequence re-enabled after test');
      }
      
      // Re-enable ALL test buttons
      document.querySelectorAll('[id^="btnTestLine_"]').forEach(btn => {
        btn.disabled = false;
        btn.style.opacity = '1';
        btn.style.cursor = 'pointer';
      });
      window.sequenceBackup = null;
      window.testedLineId = null;
      
      showNotification('âœ… SÃ©quence restaurÃ©e', 'success', 2000);
    }
    
    function toggleSequenceLine(lineId, enabled) {
      sendCommand(WS_CMD.TOGGLE_SEQUENCE_LINE, { lineId: lineId, enabled: enabled });
    }
    
    function clearSequence() {
      if (confirm('Effacer toutes les lignes du tableau?')) {
        sendCommand(WS_CMD.CLEAR_SEQUENCE, {});
      }
    }
    
    function exportSequence() {
      sendCommand(WS_CMD.EXPORT_SEQUENCE, {});
    }
    
    function importSequence() {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.json';
      
      input.onchange = function(e) {
        const file = e.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = function(event) {
          try {
            let jsonText = event.target.result;
            
            // Remove /* */ comments (JSON doesn't support comments)
            jsonText = jsonText.replace(/\/\*[\s\S]*?\*\//g, '');
            
            // Remove // comments
            jsonText = jsonText.replace(/\/\/.*/g, '');
            
            // Validate JSON before sending
            const parsed = JSON.parse(jsonText);
            
            console.log('ğŸ“¤ Sending import via HTTP:', parsed.lineCount, 'lines,', jsonText.length, 'bytes');
            
            // Use HTTP POST instead of WebSocket to avoid size limits
            fetch('/api/sequence/import', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: jsonText
            })
            .then(response => response.json())
            .then(data => {
              if (data.success) {
                console.log('âœ… Import successful:', data.message);
                alert('âœ… SÃ©quence importÃ©e avec succÃ¨s!');
                
                // Refresh sequence table without reloading page
                sendCommand(WS_CMD.GET_SEQUENCE_TABLE, {});
              } else {
                console.error('âŒ Import failed:', data.error);
                alert('âŒ Erreur import: ' + (data.error || 'Unknown error'));
              }
            })
            .catch(error => {
              console.error('âŒ HTTP request failed:', error);
              alert('âŒ Erreur rÃ©seau: ' + error.message);
            });
            
          } catch (error) {
            console.error('âŒ JSON parse error:', error);
            alert('Erreur JSON: ' + error.message + '\n\nVÃ©rifiez que le fichier est un JSON valide (pas de commentaires, virgules correctes, etc.)');
          }
        };
        reader.readAsText(file);
      };
      
      input.click();
    }
    
    /**
     * Download a JSON template with examples and documentation
     * Helps users create their own sequence files
     */
    function downloadTemplate() {
      const template = {
        version: "2.0",
        lineCount: 5,
        lines: [
          {
            lineId: 1,
            enabled: true,
            movementType: 4,  // CALIBRATION (toujours en premier!)
            cycleCount: 1,
            pauseAfterMs: 1000,
            // Note: Les autres champs sont ignorÃ©s pour la calibration
            startPositionMM: 0,
            distanceMM: 100,
            speedForward: 5.0,
            speedBackward: 5.0,
            decelStartEnabled: false,
            decelEndEnabled: false,
            decelZoneMM: 50.0,
            decelEffectPercent: 50.0,
            decelMode: 0,
            oscCenterPositionMM: 100.0,
            oscAmplitudeMM: 50.0,
            oscWaveform: 0,
            oscFrequencyHz: 0.1,
            oscEnableRampIn: false,
            oscEnableRampOut: false,
            oscRampInDurationMs: 1000.0,
            oscRampOutDurationMs: 1000.0,
            chaosCenterPositionMM: 110.0,
            chaosAmplitudeMM: 50.0,
            chaosMaxSpeedLevel: 10.0,
            chaosCrazinessPercent: 50.0,
            chaosDurationSeconds: 30,
            chaosSeed: 0,
            chaosPatternsEnabled: [true, true, true, true, true, true, true, true, true, true, true]
          },
          {
            lineId: 2,
            enabled: true,
            movementType: 0,  // VA-ET-VIENT (Simple)
            cycleCount: 10,
            pauseAfterMs: 500,
            // ParamÃ¨tres VA-ET-VIENT
            startPositionMM: 0.0,
            distanceMM: 100.0,
            speedForward: 8.0,
            speedBackward: 8.0,
            decelStartEnabled: true,
            decelEndEnabled: true,
            decelZoneMM: 20.0,
            decelEffectPercent: 75.0,
            decelMode: 1,  // 0=LINEAR, 1=SINE, 2=TRIANGLE_INV, 3=SINE_INV
            // Les autres champs (osc/chaos) ne sont pas utilisÃ©s mais doivent Ãªtre prÃ©sents
            oscCenterPositionMM: 100.0,
            oscAmplitudeMM: 50.0,
            oscWaveform: 0,
            oscFrequencyHz: 0.25,
            oscEnableRampIn: false,
            oscEnableRampOut: false,
            oscRampInDurationMs: 1000.0,
            oscRampOutDurationMs: 1000.0,
            chaosCenterPositionMM: 110.0,
            chaosAmplitudeMM: 50.0,
            chaosMaxSpeedLevel: 10.0,
            chaosCrazinessPercent: 50.0,
            chaosDurationSeconds: 30,
            chaosSeed: 0,
            chaosPatternsEnabled: [true, true, true, true, true, true, true, true, true, true, true]
          },
          {
            lineId: 3,
            enabled: true,
            movementType: 1,  // OSCILLATION
            cycleCount: 5,
            pauseAfterMs: 2000,
            // ParamÃ¨tres OSCILLATION (les autres champs doivent Ãªtre prÃ©sents)
            startPositionMM: 0.0,
            distanceMM: 100.0,
            speedForward: 5.0,
            speedBackward: 5.0,
            decelStartEnabled: false,
            decelEndEnabled: false,
            decelZoneMM: 50.0,
            decelEffectPercent: 50.0,
            decelMode: 0,
            oscCenterPositionMM: 100.0,
            oscAmplitudeMM: 80.0,
            oscWaveform: 0,  // 0=SINE, 1=TRIANGLE, 2=SQUARE
            oscFrequencyHz: 0.5,
            oscEnableRampIn: true,
            oscEnableRampOut: true,
            oscRampInDurationMs: 2000.0,
            oscRampOutDurationMs: 2000.0,
            chaosCenterPositionMM: 110.0,
            chaosAmplitudeMM: 50.0,
            chaosMaxSpeedLevel: 10.0,
            chaosCrazinessPercent: 50.0,
            chaosDurationSeconds: 30,
            chaosSeed: 0,
            chaosPatternsEnabled: [true, true, true, true, true, true, true, true, true, true, true]
          },
          {
            lineId: 4,
            enabled: true,
            movementType: 2,  // CHAOS
            cycleCount: 1,
            pauseAfterMs: 1000,
            // ParamÃ¨tres CHAOS (les autres champs doivent Ãªtre prÃ©sents)
            startPositionMM: 0.0,
            distanceMM: 100.0,
            speedForward: 5.0,
            speedBackward: 5.0,
            decelStartEnabled: false,
            decelEndEnabled: false,
            decelZoneMM: 50.0,
            decelEffectPercent: 50.0,
            decelMode: 0,
            oscCenterPositionMM: 100.0,
            oscAmplitudeMM: 50.0,
            oscWaveform: 0,
            oscFrequencyHz: 1.0,
            oscEnableRampIn: false,
            oscEnableRampOut: false,
            oscRampInDurationMs: 1000.0,
            oscRampOutDurationMs: 1000.0,
            chaosCenterPositionMM: 100.0,
            chaosAmplitudeMM: 80.0,
            chaosMaxSpeedLevel: 15.0,
            chaosCrazinessPercent: 75.0,
            chaosDurationSeconds: 60,
            chaosSeed: 12345,
            chaosPatternsEnabled: [false, false, false, false, false, true, true, true, true, false, false]  // Doux: WAVE, PENDULUM, SPIRAL, BREATHING
          },
          {
            lineId: 5,
            enabled: true,
            movementType: 0,  // VA-ET-VIENT (retour Ã  0)
            cycleCount: 1,
            pauseAfterMs: 0,
            startPositionMM: 0.0,
            distanceMM: 50.0,
            speedForward: 5.0,
            speedBackward: 5.0,
            decelStartEnabled: false,
            decelEndEnabled: true,
            decelZoneMM: 10.0,
            decelEffectPercent: 50.0,
            decelMode: 1,
            oscCenterPositionMM: 100.0,
            oscAmplitudeMM: 50.0,
            oscWaveform: 0,
            oscFrequencyHz: 2.0,
            oscEnableRampIn: false,
            oscEnableRampOut: false,
            oscRampInDurationMs: 1000.0,
            oscRampOutDurationMs: 1000.0,
            chaosCenterPositionMM: 110.0,
            chaosAmplitudeMM: 50.0,
            chaosMaxSpeedLevel: 10.0,
            chaosCrazinessPercent: 50.0,
            chaosDurationSeconds: 30,
            chaosSeed: 0,
            chaosPatternsEnabled: [true, true, true, true, true, true, true, true, true, true, true]
          }
        ]
      };
      
      // Create help documentation
      const help = {
        "ğŸ”§ GUIDE D'UTILISATION": {
          "Format": "JSON version 2.0",
          "Structure": "Objet avec 'version', 'lineCount' et 'lines' (array)",
          "Ordre": "âš ï¸ TOUJOURS commencer par CALIBRATION (movementType=4) !"
        },
        "ğŸ“‹ TYPES DE MOUVEMENT (movementType)": {
          "0": "VA-ET-VIENT (Simple) - Mouvement aller-retour classique",
          "1": "OSCILLATION - Mouvement sinusoÃ¯dal continu",
          "2": "CHAOS - Mouvements alÃ©atoires chaotiques",
          "4": "CALIBRATION - Calibration automatique (toujours en premier)"
        },
        "âš™ï¸ PARAMÃˆTRES COMMUNS": {
          "lineId": "ID unique de la ligne (entier)",
          "enabled": "Ligne active ? (true/false)",
          "cycleCount": "Nombre de cycles (1 forcÃ© pour CALIBRATION)",
          "pauseAfterMs": "Pause aprÃ¨s mouvement en millisecondes (0 = aucune)"
        },
        "ğŸ¯ VA-ET-VIENT (movementType=0)": {
          "startPositionMM": "Position de dÃ©part (mm)",
          "distanceMM": "Distance du mouvement (mm)",
          "speedForward": "Vitesse aller (1-20)",
          "speedBackward": "Vitesse retour (1-20)",
          "decelStartEnabled": "DÃ©cÃ©lÃ©ration au dÃ©part ? (true/false)",
          "decelEndEnabled": "DÃ©cÃ©lÃ©ration Ã  la fin ? (true/false)",
          "decelZoneMM": "Taille zone dÃ©cÃ©lÃ©ration (mm)",
          "decelEffectPercent": "Effet dÃ©cÃ©lÃ©ration (0-100%)",
          "decelMode": "Type: 0=LINEAR, 1=SINE, 2=TRIANGLE_INV, 3=SINE_INV"
        },
        "ğŸŒŠ OSCILLATION (movementType=1)": {
          "oscCenterPositionMM": "Position centrale (mm)",
          "oscAmplitudeMM": "Amplitude Â±amplitude (mm)",
          "oscWaveform": "Forme d'onde: 0=SINE, 1=TRIANGLE, 2=SQUARE",
          "oscFrequencyHz": "FrÃ©quence (0.1-10 Hz)",
          "oscEnableRampIn": "Rampe d'entrÃ©e ? (true/false)",
          "oscEnableRampOut": "Rampe de sortie ? (true/false)",
          "oscRampInDurationMs": "DurÃ©e rampe entrÃ©e (ms)",
          "oscRampOutDurationMs": "DurÃ©e rampe sortie (ms)"
        },
        "ğŸŒªï¸ CHAOS (movementType=2)": {
          "chaosCenterPositionMM": "Position centrale (mm)",
          "chaosAmplitudeMM": "Amplitude max Â±amplitude (mm)",
          "chaosMaxSpeedLevel": "Vitesse max (1-20)",
          "chaosCrazinessPercent": "DegrÃ© folie (0-100%)",
          "chaosDurationSeconds": "DurÃ©e en secondes (0=infini)",
          "chaosSeed": "Graine alÃ©atoire (0=auto)",
          "chaosPatternsEnabled": "Array[11] boolÃ©ens (ZIGZAG, SWEEP, PULSE, DRIFT, BURST, WAVE, PENDULUM, SPIRAL, BREATHING, BRUTE_FORCE, LIBERATOR)"
        },
        "ğŸ“ CALIBRATION (movementType=4)": {
          "Note": "Calibration automatique complÃ¨te",
          "cycleCount": "Toujours forcÃ© Ã  1",
          "Autres_params": "IgnorÃ©s mais doivent Ãªtre prÃ©sents dans le JSON"
        },
        "âš ï¸ IMPORTANT": {
          "Tous_les_champs": "TOUS les champs doivent Ãªtre prÃ©sents dans chaque ligne !",
          "Ordre_execution": "Les lignes sont exÃ©cutÃ©es dans l'ordre du tableau",
          "Validation": "Les valeurs sont validÃ©es cÃ´tÃ© backend (limites physiques)",
          "IDs": "Les lineId doivent Ãªtre uniques"
        }
      };
      
      // Combine template and help
      const fullDoc = {
        TEMPLATE: template,
        DOCUMENTATION: help
      };
      
      // Create downloadable file
      const jsonStr = JSON.stringify(fullDoc, null, 2);
      const blob = new Blob([jsonStr], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'sequence_template_avec_aide.json';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      showNotification('ğŸ“„ Template tÃ©lÃ©chargÃ© avec documentation complÃ¨te !', 'success', 3000);
    }
    
    function renderSequenceTable(data) {
      // If called without data, use existing sequenceLines (e.g., after restore)
      if (data && data.lines) {
        sequenceLines = data.lines;
      } else if (!sequenceLines || sequenceLines.length === 0) {
        console.error('Invalid sequence data');
        return;
      }
      
      // ğŸ”„ MIGRATION: Convert old microsecond values to speedLevel (0-20)
      // If speed > 20, it's likely an old microsecond value (50-500Âµs)
      sequenceLines.forEach(line => {
        if (line.speedForward > 20) {
          // Old microsecond value: convert to speedLevel
          // 500Âµs = 1, 50Âµs = 20 (linear: speedLevel = 21 - delay/25)
          line.speedForward = Math.max(1, Math.min(20, 21 - line.speedForward / 25));
          console.log('âš ï¸ Converted old speedForward from Âµs to speedLevel:', line.speedForward.toFixed(1));
        }
        if (line.speedBackward > 20) {
          line.speedBackward = Math.max(1, Math.min(20, 21 - line.speedBackward / 25));
          console.log('âš ï¸ Converted old speedBackward from Âµs to speedLevel:', line.speedBackward.toFixed(1));
        }
      });
      
      const tbody = document.getElementById('sequenceTableBody');
      tbody.innerHTML = '';
      
      if (sequenceLines.length === 0) {
        tbody.innerHTML = `
          <tr>
            <td colspan="9" style="padding: 40px; text-align: center; color: #999;">
              <div style="font-size: 48px; margin-bottom: 10px;">ğŸ“‹</div>
              <div style="font-size: 16px;">Aucune ligne - Cliquez sur "â• Ajouter ligne" pour commencer</div>
            </td>
          </tr>
        `;
        return;
      }
      
      sequenceLines.forEach((line, index) => {
        const row = document.createElement('tr');
        row.style.background = line.enabled ? 'white' : '#f5f5f5';
        row.style.opacity = line.enabled ? '1' : '0.6';
        row.style.borderBottom = '1px solid #ddd';
        row.style.transition = 'all 0.2s';
        
        // Phase 2: Drag & Drop attributes
        row.draggable = true;
        row.classList.add('sequence-line-draggable');
        row.setAttribute('data-line-id', line.lineId);
        row.setAttribute('data-line-index', index);
        
        // Phase 2: Multi-select - check if selected
        if (selectedLineIds.has(line.lineId)) {
          row.classList.add('sequence-line-selected');
        }
        
        // Add tooltip data
        const tooltipContent = generateSequenceLineTooltip(line);
        row.setAttribute('data-tooltip', tooltipContent.replace(/"/g, '&quot;'));
        row.setAttribute('data-line-number', index + 1);
        
        // Movement type icon and info
        const movementType = line.movementType !== undefined ? line.movementType : 0;
        let typeIcon = '';
        let typeInfo = '';
        let typeName = '';
        
        if (movementType === 0) {
          // VA-ET-VIENT
          typeIcon = 'ğŸ”„';
          typeName = 'Va-et-vient';
          typeInfo = `
            <div style="font-size: 10px; line-height: 1.2;">
              <div>${line.startPositionMM.toFixed(1)}mm</div>
              <div>Â±${line.distanceMM.toFixed(1)}mm</div>
            </div>
          `;
        } else if (movementType === 1) {
          // OSCILLATION
          typeIcon = 'ã€°ï¸';
          typeName = 'Oscillation';
          const waveformNames = ['SIN', 'TRI', 'SQR'];
          const waveformName = waveformNames[line.oscWaveform] || '?';
          typeInfo = `
            <div style="font-size: 10px; line-height: 1.2;">
              <div>C:${line.oscCenterPositionMM ? line.oscCenterPositionMM.toFixed(0) : '100'}mm</div>
              <div>A:Â±${line.oscAmplitudeMM ? line.oscAmplitudeMM.toFixed(0) : '50'}mm</div>
              <div>${waveformName} ${line.oscFrequencyHz ? line.oscFrequencyHz.toFixed(2) : '0.5'}Hz</div>
            </div>
          `;
        } else if (movementType === 2) {
          // CHAOS
          typeIcon = 'ğŸŒ€';
          typeName = 'Chaos';
          typeInfo = `
            <div style="font-size: 10px; line-height: 1.2;">
              <div>â±ï¸${line.chaosDurationSeconds || 30}s</div>
              <div>ğŸ²${line.chaosCrazinessPercent ? line.chaosCrazinessPercent.toFixed(0) : '50'}%</div>
            </div>
          `;
        } else if (movementType === 4) {
          // CALIBRATION
          typeIcon = 'ğŸ“';
          typeName = 'Calibration';
          typeInfo = `
            <div style="font-size: 10px; line-height: 1.2;">
              <div>Calibration</div>
              <div>complÃ¨te</div>
            </div>
          `;
        }
        
        // Deceleration summary - compact version (only for VAET)
        let decelSummary = '';
        if (movementType === 0 && (line.decelStartEnabled || line.decelEndEnabled)) {
          const parts = [];
          if (line.decelStartEnabled) parts.push('D');
          if (line.decelEndEnabled) parts.push('F');
          const modeLabels = ['Lin', 'Sin', 'Triâ»Â¹', 'Sinâ»Â¹'];
          decelSummary = `
            <div style="font-size: 10px; line-height: 1.3;">
              <div style="color: #4CAF50; font-weight: bold;">${parts.join('/')}</div>
              <div>${line.decelZoneMM}mm ${line.decelEffectPercent}%</div>
              <div>${modeLabels[line.decelMode] || '?'}</div>
            </div>
          `;
        } else {
          decelSummary = '<span style="color: #999; font-size: 10px;">--</span>';
        }
        
        // Speeds - different display based on type
        let speedsDisplay = '';
        if (movementType === 0) {
          // VA-ET-VIENT: Forward/Backward speeds
          speedsDisplay = `
            <div style="font-size: 11px; line-height: 1.3;">
              <div style="color: #2196F3; font-weight: bold;">â†—${line.speedForward.toFixed(1)}</div>
              <div style="color: #FF9800; font-weight: bold;">â†™${line.speedBackward.toFixed(1)}</div>
            </div>
          `;
        } else if (movementType === 1) {
          // OSCILLATION: Calculated speed (2Ï€ Ã— f Ã— A)
          const peakSpeedMMPerSec = 2 * Math.PI * line.oscFrequencyHz * line.oscAmplitudeMM;
          speedsDisplay = `
            <div style="font-size: 11px; font-weight: bold; color: #9C27B0;">
              ${peakSpeedMMPerSec.toFixed(0)} mm/s
            </div>
          `;
        } else {
          // CHAOS: Max speed
          speedsDisplay = `
            <div style="font-size: 11px; font-weight: bold; color: #E91E63;">
              ${line.chaosMaxSpeedLevel ? line.chaosMaxSpeedLevel.toFixed(1) : '10.0'}
            </div>
          `;
        }
        
        row.innerHTML = `
          <td style="padding: 4px 2px; text-align: center; border-right: 1px solid #eee;">
            <input type="checkbox" ${line.enabled ? 'checked' : ''} 
              onchange="toggleSequenceLine(${line.lineId}, this.checked)"
              style="width: 16px; height: 16px; cursor: pointer;">
          </td>
          <td style="padding: 4px 2px; text-align: center; font-weight: bold; color: #667eea; border-right: 1px solid #eee; font-size: 12px;">
            ${index + 1}
          </td>
          <td style="padding: 4px 2px; text-align: center; border-right: 1px solid #eee;" title="${movementType === 0 ? 'Va-et-vient' : (movementType === 1 ? 'Oscillation' : (movementType === 2 ? 'Chaos' : 'Calibration'))}">
            <div style="font-size: 16px;">${typeIcon}</div>
          </td>
          <td style="padding: 4px 2px; text-align: center; border-right: 1px solid #eee;">
            ${typeInfo}
          </td>
          <td style="padding: 4px 2px; text-align: center; border-right: 1px solid #eee;">
            <span style="color: #999; font-size: 10px;">--</span>
          </td>
          <td style="padding: 4px 2px; text-align: center; border-right: 1px solid #eee;">
            ${speedsDisplay}
          </td>
          <td style="padding: 4px 2px; text-align: center; border-right: 1px solid #eee;">
            ${decelSummary}
          </td>
          <td style="padding: 4px 2px; text-align: center; font-weight: bold; color: #FF9800; border-right: 1px solid #eee;">
            ${line.cycleCount}
          </td>
          <td style="padding: 4px 2px; text-align: center; color: ${line.pauseAfterMs > 0 ? '#9C27B0' : '#999'}; font-weight: ${line.pauseAfterMs > 0 ? 'bold' : 'normal'}; border-right: 1px solid #eee; font-size: 10px;">
            ${line.pauseAfterMs > 0 ? (line.pauseAfterMs / 1000).toFixed(1) + 's' : '--'}
          </td>
          <td style="padding: 4px 2px; text-align: center; white-space: nowrap;">
            <button onclick="testSequenceLine(${line.lineId})" 
              id="btnTestLine_${line.lineId}"
              style="background: #9C27B0; color: white; border: none; padding: 4px 6px; border-radius: 3px; cursor: pointer; margin: 1px; font-size: 12px;"
              title="Tester cette ligne">â–¶ï¸</button>
            <button onclick="editSequenceLine(${line.lineId})" 
              style="background: #2196F3; color: white; border: none; padding: 4px 6px; border-radius: 3px; cursor: pointer; margin: 1px; font-size: 12px;"
              title="Ã‰diter">âœï¸</button>
            <button onclick="duplicateSequenceLine(${line.lineId})"
              style="background: #4CAF50; color: white; border: none; padding: 4px 6px; border-radius: 3px; cursor: pointer; margin: 1px; font-size: 12px;"
              title="Dupliquer">ğŸ“‹</button>
            <span id="tooltipEye_${line.lineId}" class="sequence-tooltip-eye" data-line-id="${line.lineId}"
              style="display: inline-block; padding: 4px 6px; cursor: pointer; margin: 1px; font-size: 14px;"
              title="Voir dÃ©tails">ğŸ‘ï¸</span>
          </td>
        `;
        
        // Add line type attribute
        row.setAttribute('data-line-type', typeName);
        
        // Hover effect (no tooltip on row hover)
        row.onmouseenter = function() {
          if (line.enabled && !this.classList.contains('sequence-line-selected')) {
            this.style.background = '#f0f4ff';
          }
        };
        row.onmouseleave = function() {
          if (!this.classList.contains('sequence-line-selected')) {
            this.style.background = line.enabled ? 'white' : '#f5f5f5';
          }
        };
        
        // Phase 2: Drag events
        row.ondragstart = function(e) {
          draggedLineId = line.lineId;
          draggedLineIndex = index;
          this.classList.add('sequence-line-dragging');
          e.dataTransfer.effectAllowed = 'move';
          e.dataTransfer.setData('text/plain', line.lineId);
          
          // Highlight permanent trash zone
          const trashDropZone = document.getElementById('sequenceTrashDropZone');
          if (trashDropZone) {
            trashDropZone.classList.add('drag-active');
          }
        };
        
        row.ondragend = function(e) {
          this.classList.remove('sequence-line-dragging');
          
          // Remove spacer row
          const spacer = document.querySelector('.sequence-drop-spacer');
          if (spacer) {
            spacer.remove();
          }
          
          // Reset permanent trash zone
          const trashDropZone = document.getElementById('sequenceTrashDropZone');
          if (trashDropZone) {
            trashDropZone.classList.remove('drag-active');
          }
        };
        
        row.ondragover = function(e) {
          if (draggedLineId === line.lineId) return;
          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';
          
          // Smart spacer positioning based on mouse Y position within row
          if (draggedLineId !== line.lineId) {
            // Get row bounds
            const rect = this.getBoundingClientRect();
            const mouseY = e.clientY;
            const rowMiddle = rect.top + (rect.height / 2);
            
            // Determine if we should insert BEFORE or AFTER based on mouse position
            let insertAfter;
            if (draggedLineIndex < index) {
              // Dragging DOWN: only show spacer if mouse is in bottom half of row
              insertAfter = (mouseY > rowMiddle);
            } else {
              // Dragging UP: show spacer based on mouse position
              insertAfter = (mouseY > rowMiddle);
            }
            
            // Calculate final target position after insert
            let finalTargetIndex;
            if (insertAfter) {
              finalTargetIndex = index;
            } else {
              finalTargetIndex = index - 1;
            }
            
            // Don't show spacer if it would result in same position (no movement)
            // Also block if trying to insert on the dragged line itself
            if (finalTargetIndex === draggedLineIndex || index === draggedLineIndex) {
              const existingSpacer = document.querySelector('.sequence-drop-spacer');
              if (existingSpacer) existingSpacer.remove();
              return false;
            }
            
            // Throttle: only update if 200ms elapsed since last update (reduce flicker)
            const now = Date.now();
            if (now - lastDragEnterTime < 200) return false;
            lastDragEnterTime = now;
            
            // Check if spacer already exists at correct position
            const existingSpacer = document.querySelector('.sequence-drop-spacer');
            if (existingSpacer) {
              const spacerParent = existingSpacer.parentNode;
              const spacerNextSibling = existingSpacer.nextSibling;
              const spacerPrevSibling = existingSpacer.previousSibling;
              
              // Check if spacer is already at correct position
              if (insertAfter && spacerPrevSibling === this) {
                // Already after this row, no need to recreate
                return false;
              }
              if (!insertAfter && spacerNextSibling === this) {
                // Already before this row, no need to recreate
                return false;
              }
              
              // Remove if position changed
              existingSpacer.remove();
            }
            
            // Create spacer row
            const spacer = document.createElement('tr');
            spacer.className = 'sequence-drop-spacer';
            spacer.innerHTML = '<td colspan="10" style="height: 50px; padding: 0; border: none; background: transparent;"><div class="sequence-drop-placeholder-inner">â¬‡ InsÃ©rer ici â¬‡</div></td>';
            
            // Store target for drop handling
            spacer.dataset.targetLineId = line.lineId;
            spacer.dataset.targetIndex = index;
            
            // Make spacer droppable
            spacer.ondragover = function(e) {
              e.preventDefault();
              e.dataTransfer.dropEffect = 'move';
              return false;
            };
            
            spacer.ondrop = function(e) {
              e.preventDefault();
              e.stopPropagation();
              const targetRow = document.querySelector(`[data-line-id="${this.dataset.targetLineId}"]`);
              if (targetRow && targetRow.ondrop) {
                targetRow.ondrop(e);
              }
              return false;
            };
            
            // Insert spacer
            if (insertAfter) {
              this.parentNode.insertBefore(spacer, this.nextSibling);
            } else {
              this.parentNode.insertBefore(spacer, this);
            }
          }
          
          return false;
        };
        
        row.ondragenter = function(e) {
          // Just prevent default, ondragover handles everything
          if (draggedLineId === line.lineId) return;
          e.preventDefault();
        };
        
        row.ondragleave = function(e) {
          // Don't remove placeholder on leave - keep it visible
        };
        
        row.ondrop = function(e) {
          e.stopPropagation();
          e.preventDefault();
          
          // Remove spacer row
          const spacer = document.querySelector('.sequence-drop-spacer');
          if (spacer) {
            spacer.remove();
          }
          
          if (draggedLineId && draggedLineId !== line.lineId) {
            // Calculate direction: drag FROM draggedLineIndex TO index
            const targetIndex = index;
            let direction;
            
            if (draggedLineIndex < targetIndex) {
              // Moving down: need (targetIndex - draggedLineIndex) moves down
              direction = targetIndex - draggedLineIndex;
            } else {
              // Moving up: need -(draggedLineIndex - targetIndex) moves up
              direction = -(draggedLineIndex - targetIndex);
            }
            
            // Send multiple move commands to backend
            console.log(`ğŸ“¦ Drag: line ${draggedLineId} from index ${draggedLineIndex} to ${targetIndex} (${direction} moves)`);
            
            // Execute moves sequentially
            let movesRemaining = Math.abs(direction);
            const moveDirection = direction > 0 ? 1 : -1;
            
            const executeMove = () => {
              if (movesRemaining > 0) {
                sendCommand(WS_CMD.MOVE_SEQUENCE_LINE, { lineId: draggedLineId, direction: moveDirection });
                movesRemaining--;
                setTimeout(executeMove, 100); // Wait 100ms between moves
              } else {
                // After move complete: clear selection if dragged line was selected
                if (selectedLineIds.has(draggedLineId)) {
                  selectedLineIds.delete(draggedLineId);
                  updateBatchToolbar();
                  renderSequenceTable({ lines: sequenceLines });
                }
              }
            };
            
            executeMove();
          }
          
          return false;
        };
        
        // Phase 2: Multi-select click handler
        row.onclick = function(e) {
          // Don't trigger if clicking on buttons or checkbox
          if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT') {
            return;
          }
          
          if (e.shiftKey && lastSelectedIndex !== null) {
            // Shift+Click: select range
            const startIdx = Math.min(lastSelectedIndex, index);
            const endIdx = Math.max(lastSelectedIndex, index);
            
            for (let i = startIdx; i <= endIdx; i++) {
              if (i < sequenceLines.length) {
                selectedLineIds.add(sequenceLines[i].lineId);
              }
            }
          } else if (e.ctrlKey || e.metaKey) {
            // Ctrl+Click: toggle selection
            if (selectedLineIds.has(line.lineId)) {
              selectedLineIds.delete(line.lineId);
            } else {
              selectedLineIds.add(line.lineId);
            }
          } else {
            // Regular click: select only this line
            selectedLineIds.clear();
            selectedLineIds.add(line.lineId);
          }
          
          lastSelectedIndex = index;
          updateBatchToolbar();
          renderSequenceTable({ lines: sequenceLines }); // Re-render to show selection
        };
        
        tbody.appendChild(row);
        
        // NOW attach eye icon tooltip handler (after DOM insertion)
        setTimeout(() => {
          const eyeIcon = document.getElementById('tooltipEye_' + line.lineId);
          if (eyeIcon) {
            eyeIcon.onmouseenter = function(e) {
              showSequenceTooltip(row);
            };
            eyeIcon.onmouseleave = function() {
              hidePlaylistTooltip();
            };
          }
        }, 0);
      });
      
      // Add drag leave handler to tbody to cleanup spacer if leaving table
      tbody.ondragleave = function(e) {
        // Only remove if leaving tbody completely (not entering child element)
        if (!this.contains(e.relatedTarget)) {
          const spacer = document.querySelector('.sequence-drop-spacer');
          if (spacer) {
            spacer.remove();
          }
        }
      };
      
      // Update batch toolbar visibility
      updateBatchToolbar();
      
      // Initialize trash zones drag handlers (only once)
      initializeTrashZones();
      
      // Re-disable test buttons if testing (in case of re-render during test)
      // But do it synchronously to avoid timing issues
      if (window.isTestingLine) {
        document.querySelectorAll('[id^="btnTestLine_"]').forEach(btn => {
          btn.disabled = true;
          btn.style.opacity = '0.5';
          btn.style.cursor = 'not-allowed';
        });
        // Also re-disable start buttons using setButtonState
        if (DOM.btnStartSequence) setButtonState(DOM.btnStartSequence, false);
        if (DOM.btnLoopSequence) setButtonState(DOM.btnLoopSequence, false);
      }
    }
    
    /**
     * Phase 2: Initialize trash zones drag & drop handlers
     */
    function initializeTrashZones() {
      // Toolbar trash zone (batch operations)
      const trashZone = document.getElementById('sequenceTrashZone');
      if (trashZone && !trashZone.hasAttribute('data-initialized')) {
        trashZone.setAttribute('data-initialized', 'true');
      
      trashZone.ondragover = function(e) {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'move';
        this.classList.add('drag-over');
        return false;
      };
      
      trashZone.ondragleave = function(e) {
        if (!this.contains(e.relatedTarget)) {
          this.classList.remove('drag-over');
        }
      };
      
      trashZone.ondrop = function(e) {
        e.preventDefault();
        e.stopPropagation();
        this.classList.remove('drag-over');
        
        // Get dragged line(s)
        const linesToDelete = selectedLineIds.size > 0 ? 
          Array.from(selectedLineIds) : 
          [draggedLineId];
        
        if (linesToDelete.length === 0) return;
        
        // Confirm deletion
        const count = linesToDelete.length;
        const message = count === 1 ? 
          `âš ï¸ Supprimer la ligne sÃ©lectionnÃ©e ?\n\nCette action est irrÃ©versible.` :
          `âš ï¸ Supprimer ${count} lignes sÃ©lectionnÃ©es ?\n\nCette action est irrÃ©versible.`;
        
        if (!confirm(message)) return;
        
        console.log(`ğŸ—‘ï¸ Trash zone drop: deleting ${count} line(s)`);
        
        // Sort descending to delete from end
        const sortedIds = linesToDelete.sort((a, b) => b - a);
        
        sortedIds.forEach(lineId => {
          sendCommand(WS_CMD.DELETE_SEQUENCE_LINE, { lineId: lineId });
        });
        
        showNotification(`âœ… ${count} ligne(s) supprimÃ©e(s)`, 'success', 2000);
        
        // Clear selection
        clearSelection();
        
        return false;
      };
      }
      
      // Permanent trash drop zone (always visible)
      const trashDropZone = document.getElementById('sequenceTrashDropZone');
      if (trashDropZone && !trashDropZone.hasAttribute('data-initialized')) {
        trashDropZone.setAttribute('data-initialized', 'true');
        
        trashDropZone.ondragover = function(e) {
          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';
          return false;
        };
        
        trashDropZone.ondrop = function(e) {
          e.preventDefault();
          e.stopPropagation();
          
          // Get dragged line(s)
          const linesToDelete = selectedLineIds.size > 0 ? 
            Array.from(selectedLineIds) : 
            [draggedLineId];
          
          if (linesToDelete.length === 0) return;
          
          // Confirm deletion
          const count = linesToDelete.length;
          const message = count === 1 ? 
            `âš ï¸ Supprimer la ligne sÃ©lectionnÃ©e ?\n\nCette action est irrÃ©versible.` :
            `âš ï¸ Supprimer ${count} lignes sÃ©lectionnÃ©es ?\n\nCette action est irrÃ©versible.`;
          
          if (!confirm(message)) return;
          
          console.log(`ğŸ—‘ï¸ Permanent trash zone drop: deleting ${count} line(s)`);
          
          // Sort descending to delete from end
          const sortedIds = linesToDelete.sort((a, b) => b - a);
          
          sortedIds.forEach(lineId => {
            sendCommand(WS_CMD.DELETE_SEQUENCE_LINE, { lineId: lineId });
          });
          
          showNotification(`âœ… ${count} ligne(s) supprimÃ©e(s)`, 'success', 2000);
          
          // Clear selection
          clearSelection();
          
          return false;
        };
      }
    }
    
    /**
     * Phase 2: Update batch toolbar visibility and count
     */
    function updateBatchToolbar() {
      const toolbar = document.getElementById('sequenceBatchToolbar');
      const countDisplay = document.getElementById('batchSelectionCount');
      
      if (selectedLineIds.size > 0) {
        toolbar.classList.add('visible');
        countDisplay.textContent = `${selectedLineIds.size} ligne(s) sÃ©lectionnÃ©e(s)`;
      } else {
        toolbar.classList.remove('visible');
      }
    }
    
    /**
     * Phase 2: Clear all selections
     */
    function clearSelection() {
      selectedLineIds.clear();
      lastSelectedIndex = null;
      updateBatchToolbar();
      renderSequenceTable({ lines: sequenceLines });
    }
    
    /**
     * Phase 2: Batch enable/disable lines
     */
    function batchEnableLines(enabled) {
      if (selectedLineIds.size === 0) return;
      
      console.log(`ğŸ“¦ Batch ${enabled ? 'enable' : 'disable'} ${selectedLineIds.size} lines`);
      
      selectedLineIds.forEach(lineId => {
        sendCommand(WS_CMD.TOGGLE_SEQUENCE_LINE, { lineId: lineId, enabled: enabled });
        
        // Update local state
        const line = sequenceLines.find(l => l.lineId === lineId);
        if (line) {
          line.enabled = enabled;
        }
      });
      
      showNotification(`âœ… ${selectedLineIds.size} ligne(s) ${enabled ? 'activÃ©e(s)' : 'dÃ©sactivÃ©e(s)'}`, 'success', 2000);
      
      // Clear selection after operation
      clearSelection();
    }
    
    /**
     * Phase 2: Batch delete lines
     */
    function batchDeleteLines() {
      if (selectedLineIds.size === 0) return;
      
      const count = selectedLineIds.size;
      if (!confirm(`âš ï¸ Supprimer ${count} ligne(s) sÃ©lectionnÃ©e(s) ?\n\nCette action est irrÃ©versible.`)) {
        return;
      }
      
      console.log(`ğŸ“¦ Batch delete ${count} lines`);
      
      // Convert to array and sort by lineId descending (delete from end to avoid index shifts)
      const lineIdsArray = Array.from(selectedLineIds).sort((a, b) => b - a);
      
      lineIdsArray.forEach(lineId => {
        sendCommand(WS_CMD.DELETE_SEQUENCE_LINE, { lineId: lineId });
      });
      
      showNotification(`âœ… ${count} ligne(s) supprimÃ©e(s)`, 'success', 2000);
      
      // Clear selection
      clearSelection();
    }
    
    function updateSequenceStatus(status) {
      if (!status) return;
      
      // Update mode
      const modeText = status.isRunning 
        ? (status.isLoopMode ? 'ğŸ” BOUCLE INFINIE' : 'â–¶ï¸ LECTURE UNIQUE')
        : 'â¹ï¸ ArrÃªtÃ©';
      DOM.seqMode.textContent = modeText;
      DOM.seqMode.style.color = status.isRunning ? '#4CAF50' : '#999';
      
      // Update current line
      const lineText = status.isRunning 
        ? `${status.currentLineNumber} / ${status.totalLines}`
        : '-- / --';
      DOM.seqCurrentLine.textContent = lineText;
      
      // Update cycle
      DOM.seqLineCycle.textContent = 
        status.isRunning ? status.currentCycle : '--';
      
      // Update loop count
      DOM.seqLoopCount.textContent = status.loopCount || 0;
      
      // Update pause remaining
      const pauseText = status.pauseRemaining > 0 
        ? `${status.pauseRemaining} ms`
        : '-- ms';
      DOM.seqPauseRemaining.textContent = pauseText;
      
      // Button states: ONLY controlled by backend sequenceStatus
      // Backend says "running" = buttons disabled, "stopped" = buttons enabled
      const isRunning = status.isRunning;
      
      // Auto-restore sequence after test
      if (!isRunning && window.isTestingLine) {
        console.log('ğŸ”„ Test finished, scheduling restore...');
        setTimeout(() => {
          restoreSequenceAfterTest();
        }, 500);
      }
      
      // Start buttons: enable ONLY when backend confirms sequence stopped
      // BUT: Keep disabled during line test (will be re-enabled by restoreSequenceAfterTest)
      console.log('ğŸ” updateSequenceStatus: isRunning=', isRunning, 'isTestingLine=', window.isTestingLine);
      if (!isRunning && !window.isTestingLine) {
        const canStart = canStartOperation();
        console.log('ğŸŸ¢ Enabling start buttons, canStart=', canStart);
        setButtonState(DOM.btnStartSequence, canStart);
        setButtonState(DOM.btnLoopSequence, canStart);
      } else {
        console.log('ğŸ”´ Keeping start buttons disabled');
        // Force disable to override any other updates
        setButtonState(DOM.btnStartSequence, false);
        setButtonState(DOM.btnLoopSequence, false);
      }
      // If running or testing, keep disabled (already disabled on click or by testSequenceLine)
      
      // Control buttons: available while running
      setButtonState(DOM.btnPauseSequence, isRunning);
      setButtonState(DOM.btnStopSequence, isRunning);
      setButtonState(DOM.btnSkipLine, isRunning);
      
      // Update pause button text
      if (isRunning && status.isPaused) {
        DOM.btnPauseSequence.innerHTML = 'â–¶ï¸ Reprendre';
      } else {
        DOM.btnPauseSequence.innerHTML = 'â¸ï¸ Pause';
      }
      
      // Highlight active line using currentLineIndex (not currentLineId)
      const tbody = document.getElementById('sequenceTableBody');
      if (tbody) {
        const rows = tbody.querySelectorAll('tr');
        rows.forEach(row => {
          row.classList.remove('sequence-line-active');
        });
        
        if (isRunning && status.currentLineIndex !== undefined) {
          // Backend sends 0-based currentLineIndex
          const activeIndex = status.currentLineIndex;
          
          if (activeIndex >= 0 && activeIndex < rows.length) {
            rows[activeIndex].classList.add('sequence-line-active');
            
            // Scroll to active line
            rows[activeIndex].scrollIntoView({ behavior: 'smooth', block: 'nearest' });
          }
        }
      }
    }
    
    // ========================================================================
    // WEBSOCKET CONNECTION
    // ========================================================================
    
    function connectWebSocket() {
      AppState.ws = new WebSocket('ws://' + window.location.hostname + ':81');
      
      AppState.ws.onopen = function() {
        console.log('WebSocket connected');
        document.getElementById('state').textContent = 'ConnectÃ© au contrÃ´leur';
        
        // Initialize pattern toggle button state
        updatePatternToggleButton();
        
        // Request status after a short delay to ensure everything is ready
        setTimeout(function() {
          sendCommand(WS_CMD.GET_STATUS, {});
        }, 50);
      };
      
      AppState.ws.onmessage = function(event) {
        try {
          const data = JSON.parse(event.data);
          
          // Handle error messages (high priority)
          if (data.type === 'error') {
            showNotification(data.message, 'error');
            return;
          }
          
          // Handle specific message types for MODE TABLEAU
          if (data.type === 'sequenceTable') {
            renderSequenceTable(data.data);
            return;
          }
          
          if (data.type === 'sequenceStatus') {
            updateSequenceStatus(data);
            return;
          }
          
          if (data.type === 'exportData') {
            // Download JSON file
            const jsonStr = JSON.stringify(data.data, null, 2);
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'sequence_' + new Date().toISOString().slice(0,10) + '.json';
            a.click();
            URL.revokeObjectURL(url);
            return;
          }

          if (data.type === 'fsList') {
            // display the index.html timestamp in the sequence tab
            if (data.files && data.files.length > 0) {
              const idxFile = data.files.find(f => f.name === '/index.html' || f.name === 'index.html');
              if (idxFile) {
                const el = document.getElementById('fsIndexTimestamp');
                if (el) el.textContent = 'index.html: ' + idxFile.time;
              }
            }
            return;
          }

          if (data.type === 'log') {
            // Display log in the common logs panel
            if (DOM.logConsolePanel) {
              const level = data.level || 'INFO';
              const msg = data.message || '';
              
              // Color coding based on log level (VSCode Dark+ theme inspired)
              const colors = {
                'ERROR': '#f48771',   // Red
                'WARN': '#dcdcaa',    // Yellow
                'INFO': '#4ec9b0',    // Cyan
                'DEBUG': '#9cdcfe'    // Blue
              };
              const color = colors[level] || '#d4d4d4';
              
              const timestamp = new Date().toLocaleTimeString('fr-FR', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
              const lineEl = document.createElement('div');
              lineEl.style.color = color;
              lineEl.textContent = `[${timestamp}] [${level}] ${msg}`;
              DOM.logConsolePanel.appendChild(lineEl);
              DOM.logConsolePanel.scrollTop = DOM.logConsolePanel.scrollHeight;
              
              // Auto-scroll and limit to 500 lines
              while (DOM.logConsolePanel.children.length > 500) {
                DOM.logConsolePanel.removeChild(DOM.logConsolePanel.firstChild);
              }
            }
            return;
          }
          
          // Default: update main UI
          updateUI(data);
        } catch (e) {
          console.error('WebSocket parse error:', e, 'Raw data:', event.data);
          showNotification('Erreur de communication avec l\'ESP32', 'error');
        }
      };
      
      AppState.ws.onclose = function() {
        console.log('WebSocket disconnected. Reconnecting...');
        if (DOM.state) {
          DOM.state.textContent = 'DÃ©connectÃ© - Reconnexion...';
        }
        setTimeout(connectWebSocket, 2000);
      };
      
      AppState.ws.onerror = function(error) {
        console.error('WebSocket error:', error);
        if (DOM.state) {
          DOM.state.textContent = 'Erreur de connexion';
        }
        showNotification('Erreur WebSocket - VÃ©rifiez la connexion', 'error');
      };
    }
    
    // Note: showNotification() loaded from utils.js
    
    // ============================================================================
    // UI UPDATE
    // ============================================================================
    
    function updateUI(data) {
      // Defensive check: only process status-like messages which contain positionMM
      // Some incoming messages (logs, fsList, etc.) can be generic JSON and should
      // not be passed to updateUI. Guard against missing fields to avoid runtime
      // errors like "cannot read property 'toFixed' of undefined".
      if (!data || !('positionMM' in data)) {
        console.warn('updateUI: unexpected message, skipping', data);
        return;
      }
      // Update global state for mode change logic
      AppState.system.currentState = data.state;
      AppState.system.canStart = data.canStart || false;
      
      const stateText = ['Initialisation', 'Calibration...', 'PrÃªt', 'En marche', 'En pause', 'Erreur'];
      const stateClass = ['state-init', 'state-calibrating', 'state-ready', 'state-running', 'state-paused', 'state-error'];
      
      let displayText = stateText[data.state] || 'Inconnu';
      if (data.errorMessage && data.errorMessage !== '') {
        displayText += ' âš ï¸ ' + data.errorMessage;
      }
      
      DOM.state.textContent = displayText;
      DOM.state.className = 'status-value ' + (stateClass[data.state] || '');
      
      // Check if calibrating (used in multiple places below)
      const isCalibrating = data.state === SystemState.CALIBRATING;
      
      // Show/hide calibration overlay
      if (DOM.calibrationOverlay) {
        if (isCalibrating) {
          DOM.calibrationOverlay.classList.add('active');
        } else {
          DOM.calibrationOverlay.classList.remove('active');
        }
      }
      
      // Show tabs and controls after first successful calibration
      // Once calibrated (canStart = true), reveal the interface
      if (AppState.system.canStart && data.totalDistMM > 0) {
        const tabsContainer = document.getElementById('tabsContainer');
        const allTabContents = document.querySelectorAll('.tab-content');
        const welcomeMessage = document.getElementById('welcomeMessage');
        
        // Hide welcome message
        if (welcomeMessage && !welcomeMessage.classList.contains('hidden')) {
          welcomeMessage.classList.add('hidden');
        }
        
        // Show tabs
        if (tabsContainer && tabsContainer.classList.contains('hidden-until-calibrated')) {
          tabsContainer.classList.remove('hidden-until-calibrated');
        }
        
        // Show all tab contents
        allTabContents.forEach(tabContent => {
          if (tabContent.classList.contains('hidden-until-calibrated')) {
            tabContent.classList.remove('hidden-until-calibrated');
          }
        });
      }
      
      // Extra safety: check fields exist before accessing (defense-in-depth)
      if (data.positionMM !== undefined && data.currentStep !== undefined) {
        currentPositionMM = data.positionMM; // Update global position tracker
        DOM.position.textContent = 
          data.positionMM.toFixed(2) + ' mm (' + data.currentStep + ' steps)';
      }
      
      if (data.totalDistMM !== undefined) {
        // Display total distance with limit info if applicable
        let totalDistText = data.totalDistMM.toFixed(2) + ' mm';
        if (data.maxDistLimitPercent && data.maxDistLimitPercent < 100) {
          totalDistText += ' (' + data.effectiveMaxDistMM.toFixed(2) + ' mm @ ' + 
                          data.maxDistLimitPercent.toFixed(0) + '%)';
        }
        DOM.totalDist.textContent = totalDistText;
        if (DOM.maxDist) {
          DOM.maxDist.textContent = data.totalDistMM.toFixed(2);
        }
        
        // Update max dist limit slider if data received (but NOT while user is editing!)
        if (data.maxDistLimitPercent && !isEditingMaxDistLimit) {
          DOM.maxDistLimitSlider.value = data.maxDistLimitPercent.toFixed(0);
          updateMaxDistLimitUI();
        }
      }
      
      // Update pursuit mode variables
      if (data.totalDistMM !== undefined) {
        AppState.pursuit.totalDistanceMM = data.totalDistMM;
        
        // Store max distance limit percent in AppState (but not while user is editing!)
        if (data.maxDistLimitPercent !== undefined && !isEditingMaxDistLimit) {
          AppState.pursuit.maxDistLimitPercent = data.maxDistLimitPercent;
        }
        
        // Update gauge limit line
        if (data.maxDistLimitPercent && data.maxDistLimitPercent < 100 && data.effectiveMaxDistMM) {
          const limitPercent = (data.effectiveMaxDistMM / data.totalDistMM);
          const containerHeight = DOM.gaugeContainer ? DOM.gaugeContainer.offsetHeight : 500;
          const limitPixelPosition = containerHeight - (limitPercent * containerHeight);
          
          DOM.gaugeLimitLine.style.top = limitPixelPosition + 'px';
          DOM.gaugeLimitLine.style.display = 'block';
        } else if (DOM.gaugeLimitLine) {
          DOM.gaugeLimitLine.style.display = 'none';
        }
      }
      if (data.positionMM !== undefined) {
        AppState.pursuit.currentPositionMM = data.positionMM;
        updateGaugePosition(AppState.pursuit.currentPositionMM);
      }
      
      // Update speed display based on CURRENT ACTIVE MODE (not just data availability)
      const speedElement = document.getElementById('currentSpeed');
      const cpmSpan = speedElement ? speedElement.nextElementSibling : null;
      const currentMode = AppState.system.currentMode;
      
      if (currentMode === 'oscillation' && data.oscillation && data.oscillation.frequencyHz !== undefined && data.oscillation.amplitudeMM !== undefined) {
        // OSCILLATION MODE: Show ACTUAL speed (backend calculates with hardware limits)
        // If actualSpeedMMS is provided, use it (accounts for adaptive delay)
        // Otherwise fallback to theoretical peak speed calculation
        let displaySpeed;
        let isLimited = false;
        
        if (data.oscillation.actualSpeedMMS !== undefined && data.oscillation.actualSpeedMMS > 0) {
          // Use actual speed from backend (considers hardware limits)
          displaySpeed = parseFloat(data.oscillation.actualSpeedMMS);
          
          // Check if speed was limited
          const theoreticalSpeed = 2 * Math.PI * data.oscillation.frequencyHz * data.oscillation.amplitudeMM;
          isLimited = (displaySpeed < theoreticalSpeed - 1); // 1 mm/s tolerance
        } else {
          // Fallback: calculate theoretical peak speed
          displaySpeed = 2 * Math.PI * data.oscillation.frequencyHz * data.oscillation.amplitudeMM;
        }
        
        speedElement.innerHTML = 'ğŸŒŠ ' + displaySpeed.toFixed(0) + ' mm/s' + (isLimited ? ' âš ï¸' : '');
        
        if (cpmSpan) {
          cpmSpan.textContent = '(pic, f=' + data.oscillation.frequencyHz.toFixed(2) + ' Hz' + 
                                (isLimited ? ', limitÃ©' : '') + ')';
        }
      } else if (currentMode === 'chaos' && data.chaos && data.chaos.maxSpeedLevel !== undefined) {
        // CHAOS MODE: Show max speed level
        const speedMMPerSec = data.chaos.maxSpeedLevel * 10.0;
        speedElement.innerHTML = 'âš¡ ' + data.chaos.maxSpeedLevel.toFixed(1);
        
        if (cpmSpan) {
          cpmSpan.textContent = '(max ' + speedMMPerSec.toFixed(0) + ' mm/s)';
        }
      } else if (currentMode === 'pursuit' && pursuitMaxSpeedLevel !== undefined) {
        // PURSUIT MODE: Show max speed level from UI variable
        const speedMMPerSec = pursuitMaxSpeedLevel * 10.0;
        speedElement.innerHTML = 'âš¡ ' + pursuitMaxSpeedLevel.toFixed(1);
        
        if (cpmSpan) {
          cpmSpan.textContent = '(max ' + speedMMPerSec.toFixed(0) + ' mm/s)';
        }
      } else if (currentMode === 'sequencer') {
        // SEQUENCER MODE: Show mode indicator
        speedElement.innerHTML = '- (mode sÃ©quence)';
        if (cpmSpan) {
          cpmSpan.textContent = '';
        }
      } else if (currentMode === 'simple' && data.motion && data.cyclesPerMinForward !== undefined && data.cyclesPerMinBackward !== undefined) {
        // SIMPLE MODE: Show forward/backward speeds with cycles/min
        // Defense: Check motion fields exist before accessing
        if (data.motion.speedLevelForward !== undefined && data.motion.speedLevelBackward !== undefined) {
          const avgCpm = ((data.cyclesPerMinForward + data.cyclesPerMinBackward) / 2).toFixed(0);
          speedElement.innerHTML = 
            'â†—ï¸ ' + data.motion.speedLevelForward.toFixed(1) + 
            '&nbsp;&nbsp;â€¢&nbsp;&nbsp;' +
            'â†™ï¸ ' + data.motion.speedLevelBackward.toFixed(1);
          
          if (cpmSpan) {
            cpmSpan.textContent = '(' + avgCpm + ' c/min)';
          }
        }
      }
      
      if (data.totalTraveled !== undefined) {
        DOM.totalTraveled.textContent = (data.totalTraveled / 1000.0).toFixed(3) + " m";

        
        // Update milestone icon
        const milestoneInfo = getMilestoneInfo(data.totalTraveled / 1000.0); // Convert mm to m
        
        if (milestoneInfo.current) {
          // Build tooltip with progress info
          let tooltip = `${milestoneInfo.current.emoji} ${milestoneInfo.current.name} (${milestoneInfo.current.threshold}m)`;
          if (milestoneInfo.current.location !== "-") {
            tooltip += ` - ${milestoneInfo.current.location}`;
          }
          
          if (milestoneInfo.next) {
            tooltip += `\n\nâ­ï¸ Prochain: ${milestoneInfo.next.emoji} ${milestoneInfo.next.name} (${milestoneInfo.next.threshold}m)`;
            tooltip += `\nğŸ“Š Progression: ${milestoneInfo.progressPercent}%`;
          } else {
            tooltip += `\n\nğŸ‰ Dernier jalon atteint!`;
          }
          
          DOM.milestoneIcon.textContent = milestoneInfo.current.emoji;
          DOM.milestoneIcon.title = tooltip;
          
          // Check if milestone changed (achievement notification)
          if (AppState.milestone.lastThreshold < milestoneInfo.current.threshold) {
            // New milestone achieved!
            AppState.milestone.lastThreshold = milestoneInfo.current.threshold;
            
            // Trigger animation
            DOM.milestoneIcon.classList.remove('milestone-achievement');
            void DOM.milestoneIcon.offsetWidth; // Force reflow
            DOM.milestoneIcon.classList.add('milestone-achievement');
            
            // Show notification
            let message = `ğŸ‰ Jalon atteint: ${milestoneInfo.current.emoji} ${milestoneInfo.current.name} (${milestoneInfo.current.threshold}m)`;
            if (milestoneInfo.next) {
              message += `\nâ­ï¸ Prochain objectif: ${milestoneInfo.next.name} (${milestoneInfo.next.threshold}m) - ${milestoneInfo.progressPercent}%`;
            }
            showNotification(message, 'success', 6000);
          }
          
          AppState.milestone.current = milestoneInfo.current;
        } else {
          // No milestone reached yet
          if (milestoneInfo.next) {
            const tooltip = `â­ï¸ Prochain: ${milestoneInfo.next.emoji} ${milestoneInfo.next.name} (${milestoneInfo.next.threshold}m)\nğŸ“Š Progression: ${milestoneInfo.progressPercent}%`;
            DOM.milestoneIcon.textContent = 'ğŸœ';
            DOM.milestoneIcon.title = tooltip;
          } else {
            DOM.milestoneIcon.textContent = '';
            DOM.milestoneIcon.title = '';
          }
        }
      }
      
      if (data.totalDistMM > 0 && data.positionMM !== undefined) {
        const progress = (data.positionMM / data.totalDistMM) * 100;
        const progressMini = document.getElementById('progressMini');
        const progressPct = document.getElementById('progressPct');
        if (progressMini) progressMini.style.width = progress + '%';
        if (progressPct) progressPct.textContent = progress.toFixed(1) + '%';
      }
      
      // Sync input values with server state (but not if user is editing)
      // Also check activeElement to prevent overwriting during typing
      // Defense: Check data.motion exists before accessing fields
      if (data.motion) {
        if (AppState.editing.input !== 'startPosition' && document.activeElement !== DOM.startPosition && data.motion.startPositionMM !== undefined) {
          DOM.startPosition.value = data.motion.startPositionMM.toFixed(1);
        }
      }
      
      if (data.targetDistMM !== undefined && AppState.editing.input !== 'distance' && document.activeElement !== DOM.distance) {
        DOM.distance.value = data.targetDistMM.toFixed(1);
      }
      
      // Update speed values based on unified/separate mode
      const isSeparateMode = document.getElementById('speedModeSeparate')?.checked || false;
      
      // Defense: Check data.motion exists before accessing speed fields
      if (data.motion) {
        if (isSeparateMode) {
          // SEPARATE MODE: update forward and backward individually
          if (AppState.editing.input !== 'speedForward' && document.activeElement !== DOM.speedForward && data.motion.speedLevelForward !== undefined) {
            DOM.speedForward.value = data.motion.speedLevelForward.toFixed(1);
          }
          if (AppState.editing.input !== 'speedBackward' && document.activeElement !== DOM.speedBackward && data.motion.speedLevelBackward !== undefined) {
            DOM.speedBackward.value = data.motion.speedLevelBackward.toFixed(1);
          }
          // Speed info removed in compact mode
          if (DOM.speedForwardInfo && data.cyclesPerMinForward !== undefined) {
            DOM.speedForwardInfo.textContent = 
              'â‰ˆ ' + data.cyclesPerMinForward.toFixed(0) + ' cycles/min';
          }
          if (DOM.speedBackwardInfo && data.cyclesPerMinBackward !== undefined) {
            DOM.speedBackwardInfo.textContent = 
              'â‰ˆ ' + data.cyclesPerMinBackward.toFixed(0) + ' cycles/min';
          }
        } else {
          // UNIFIED MODE: show current speed (should be same for both directions)
          if (AppState.editing.input !== 'speedUnified' && document.activeElement !== DOM.speedUnified) {
            // Use backward speed as reference (shows what user just changed)
            // In unified mode, both speeds should be identical, but we show backward
            // to ensure the displayed value reflects the most recent change
            if (data.motion.speedLevelBackward !== undefined) {
              DOM.speedUnified.value = data.motion.speedLevelBackward.toFixed(1);
            }
            
            // Also keep separate fields in sync (hidden but used when switching modes)
            if (data.motion.speedLevelForward !== undefined) {
              DOM.speedForward.value = data.motion.speedLevelForward.toFixed(1);
            }
            if (data.motion.speedLevelBackward !== undefined) {
              DOM.speedBackward.value = data.motion.speedLevelBackward.toFixed(1);
            }
          }
          
          // Speed info removed in compact mode
          if (DOM.speedUnifiedInfo && data.cyclesPerMinForward !== undefined && data.cyclesPerMinBackward !== undefined) {
            const avgCyclesPerMin = (data.cyclesPerMinForward + data.cyclesPerMinBackward) / 2.0;
            DOM.speedUnifiedInfo.textContent = 
              'â‰ˆ ' + avgCyclesPerMin.toFixed(0) + ' cycles/min';
          }
        }
      }
      
      // Update max values and presets
      // Use effective max distance (factored) if available, otherwise total
      // Defense: Check data.motion exists before accessing startPositionMM
      if (data.totalDistMM !== undefined) {
        const effectiveMax = (data.effectiveMaxDistMM && data.effectiveMaxDistMM > 0) ? data.effectiveMaxDistMM : data.totalDistMM;
        const startPos = (data.motion && data.motion.startPositionMM !== undefined) ? data.motion.startPositionMM : 0;
        const maxAvailable = effectiveMax - startPos;
        
        DOM.startPosition.max = effectiveMax;
        DOM.distance.max = maxAvailable;
        
        // Show factored value if limit < 100% (only if elements exist)
        if (DOM.maxStart) {
          if (data.maxDistLimitPercent && data.maxDistLimitPercent < 100) {
            DOM.maxStart.textContent = effectiveMax.toFixed(2) + ' (' + data.maxDistLimitPercent.toFixed(0) + '% de ' + data.totalDistMM.toFixed(2) + ')';
          } else {
            DOM.maxStart.textContent = effectiveMax.toFixed(2);
          }
        }
        
        if (DOM.maxDist) {
          DOM.maxDist.textContent = maxAvailable.toFixed(2);
        }
        updateStartPresets(effectiveMax);
        updateDistancePresets(maxAvailable);
      }
      
      // Enable/disable start button
      const isRunning = data.state === SystemState.RUNNING;
      const isPausedState = data.state === SystemState.PAUSED;
      const canStart = canStartOperation() && !isRunning && !isPausedState;
      
      setButtonState(DOM.btnStart, canStart);
      
      // Enable/disable calibrate button (now in common tools section)
      if (DOM.btnCalibrateCommon) {
        if (!data.canCalibrate) {
          DOM.btnCalibrateCommon.disabled = true;
          DOM.btnCalibrateCommon.style.opacity = '0.5';
          DOM.btnCalibrateCommon.style.cursor = 'not-allowed';
        } else {
          DOM.btnCalibrateCommon.disabled = false;
          DOM.btnCalibrateCommon.style.opacity = '1';
          DOM.btnCalibrateCommon.style.cursor = 'pointer';
        }
      }
      
      // Disable inputs during calibration (but allow changes during running)
      const inputsEnabled = canStartOperation();
      
      // Update input fields state
      [DOM.startPosition, DOM.distance, DOM.speedUnified, DOM.speedForward, DOM.speedBackward].forEach(input => {
        if (input) {
          input.disabled = !inputsEnabled;
          input.style.opacity = inputsEnabled ? '1' : '0.6';
        }
      });
      
      // Update pursuit controls
      if (DOM.pursuitActiveCheckbox) DOM.pursuitActiveCheckbox.disabled = !inputsEnabled;
      setButtonState(DOM.btnActivatePursuit, inputsEnabled);
      
      // Update deceleration zone configuration from server
      if (data.decelZone && AppState.editing.input !== 'decelZone') {
        const section = document.getElementById('decelSection');
        const headerText = document.getElementById('decelHeaderText');
        
        // Defense: Only update full decelZone fields if enabled (Phase 1 optimization)
        // When disabled, backend sends only {enabled: false} to save bandwidth
        if (data.decelZone.enabled && data.decelZone.zoneMM !== undefined) {
          // Update section collapsed state and header text based on enabled
          if (section && headerText) {
            section.classList.remove('collapsed');
            headerText.textContent = 'ğŸ¯ DÃ©cÃ©lÃ©ration - activÃ©e';
          }
          
          // Safe access to optional fields
          if (data.decelZone.enableStart !== undefined) {
            const startCheckbox = document.getElementById('decelZoneStart');
            if (startCheckbox) startCheckbox.checked = data.decelZone.enableStart;
          }
          if (data.decelZone.enableEnd !== undefined) {
            const endCheckbox = document.getElementById('decelZoneEnd');
            if (endCheckbox) endCheckbox.checked = data.decelZone.enableEnd;
          }
          
          // Check if zone value was adapted by ESP32 (only if we just sent a request)
          const decelZoneInput = document.getElementById('decelZoneMM');
          const requestedZone = AppState.lastDecelZoneRequest;
          const receivedZone = data.decelZone.zoneMM;
          
          if (requestedZone !== undefined && Math.abs(requestedZone - receivedZone) > 0.1) {
            // Value was adapted - show notification once
            showNotification(`âš ï¸ Zone ajustÃ©e: ${requestedZone.toFixed(0)}mm â†’ ${receivedZone.toFixed(0)}mm (limite du mouvement)`, 'warning', 4000);
            // Clear the request flag to avoid showing notification again
            AppState.lastDecelZoneRequest = undefined;
          }
          
          if (decelZoneInput) {
            decelZoneInput.value = receivedZone;
          }
          
          // Effect percent (safe access)
          if (data.decelZone.effectPercent !== undefined) {
            const effectPercentInput = document.getElementById('decelEffectPercent');
            const effectValueSpan = document.getElementById('effectValue');
            if (effectPercentInput) {
              effectPercentInput.value = data.decelZone.effectPercent;
            }
            if (effectValueSpan) {
              effectValueSpan.textContent = data.decelZone.effectPercent.toFixed(0) + '%';
            }
          }
          
          // Update select dropdown for mode
          if (data.decelZone.mode !== undefined) {
            const decelModeSelect = document.getElementById('decelModeSelect');
            if (decelModeSelect) {
              decelModeSelect.value = data.decelZone.mode.toString();
            }
          }
          
          // Update zone preset active state
          document.querySelectorAll('[data-decel-zone]').forEach(btn => {
            const btnValue = parseInt(btn.getAttribute('data-decel-zone'));
            if (btnValue === data.decelZone.zoneMM) {
              btn.classList.add('active');
            } else {
              btn.classList.remove('active');
            }
          });
          
          // Redraw preview if enabled
          drawDecelPreview();
        } else {
          // Disabled state
          if (section && headerText) {
            section.classList.add('collapsed');
            headerText.textContent = 'ğŸ¯ DÃ©cÃ©lÃ©ration - dÃ©sactivÃ©e';
          }
        }
      }
      
      // Show pending changes indicator
      const pendingChanges = document.getElementById('pendingChanges');
      if (data.hasPending) {
        pendingChanges.style.display = 'block';
        pendingChanges.textContent = 'â³ Changements en attente: ' + 
          data.pendingStartPos.toFixed(1) + ' mm â†’ ' + 
          (data.pendingStartPos + data.pendingDist).toFixed(1) + ' mm (' +
          data.pendingDist.toFixed(1) + 'mm) @ ' + 
          'Aller: ' + data.pendingMotion.speedLevelForward.toFixed(1) + '/20, ' +
          'Retour: ' + data.pendingMotion.speedLevelBackward.toFixed(1) + '/20 (fin de cycle)';
      } else {
        pendingChanges.style.display = 'none';
      }
      
      // Update oscillation state display
      if (data.oscillation && data.oscillationState) {
        DOM.oscCurrentAmplitude.textContent = 
          data.oscillationState.currentAmplitude.toFixed(2);
        DOM.oscCompletedCycles.textContent = 
          data.oscillationState.completedCycles;
        
        let rampStatus = 'Aucune';
        if (data.oscillationState.isTransitioning) {
          rampStatus = 'ğŸ”„ Transition frÃ©quence...';
        } else if (data.oscillationState.isRampingIn) {
          rampStatus = 'ğŸ“ˆ Rampe entrÃ©e';
        } else if (data.oscillationState.isRampingOut) {
          rampStatus = 'ğŸ“‰ Rampe sortie';
        } else if (data.operationMode === 3 && data.state === SystemState.RUNNING) {  // MODE_OSCILLATION + RUNNING
          rampStatus = 'âœ… StabilisÃ©';
        }
        DOM.oscRampStatus.textContent = rampStatus;
        
        // ğŸ”’ DISABLE frequency controls during transition (500ms smooth change)
        const isTransitioning = data.oscillationState.isTransitioning || false;
        DOM.oscFrequency.disabled = isTransitioning;
        
        // Apply visual feedback during transition
        if (isTransitioning) {
          DOM.oscFrequency.style.backgroundColor = '#fff3cd';
          DOM.oscFrequency.style.cursor = 'not-allowed';
        } else {
          DOM.oscFrequency.style.backgroundColor = '';
          DOM.oscFrequency.style.cursor = '';
        }
        
        // Also disable preset buttons during transition
        document.querySelectorAll('[data-osc-frequency]').forEach(btn => {
          btn.disabled = isTransitioning;
          btn.style.opacity = isTransitioning ? '0.5' : '1';
          btn.style.cursor = isTransitioning ? 'not-allowed' : 'pointer';
        });
        
        // Sync oscillation config to UI (skip fields being edited OR having focus)
        if (AppState.editing.oscField !== 'oscCenter' && document.activeElement !== DOM.oscCenter) {
          DOM.oscCenter.value = data.oscillation.centerPositionMM.toFixed(1);
        }
        
        if (AppState.editing.oscField !== 'oscAmplitude' && document.activeElement !== DOM.oscAmplitude) {
          DOM.oscAmplitude.value = data.oscillation.amplitudeMM.toFixed(1);
        }
        
        if (AppState.editing.oscField !== 'oscWaveform' && document.activeElement !== DOM.oscWaveform) {
          DOM.oscWaveform.value = data.oscillation.waveform;
        }
        
        if (AppState.editing.oscField !== 'oscFrequency' && document.activeElement !== DOM.oscFrequency && !isTransitioning) {
          // Use effective frequency if available (accounts for speed limiting)
          const displayFreq = data.oscillation.effectiveFrequencyHz || data.oscillation.frequencyHz;
          const isFreqLimited = data.oscillation.effectiveFrequencyHz && 
                                Math.abs(data.oscillation.effectiveFrequencyHz - data.oscillation.frequencyHz) > 0.001;
          
          DOM.oscFrequency.value = displayFreq.toFixed(3);
          
          // Visual feedback if frequency is limited
          if (isFreqLimited) {
            DOM.oscFrequency.style.backgroundColor = '#ffe8e8';
            DOM.oscFrequency.style.fontWeight = 'bold';
            DOM.oscFrequency.style.color = '#d32f2f';
            DOM.oscFrequency.title = `âš ï¸ FrÃ©quence limitÃ©e de ${data.oscillation.frequencyHz.toFixed(2)} Hz Ã  ${displayFreq.toFixed(2)} Hz (vitesse max: 300 mm/s)`;
          } else {
            DOM.oscFrequency.style.backgroundColor = '';
            DOM.oscFrequency.style.fontWeight = '';
            DOM.oscFrequency.style.color = '';
            DOM.oscFrequency.title = '';
          }
        }
        
        if (AppState.editing.oscField !== 'oscRampInDuration' && document.activeElement !== DOM.oscRampInDuration) {
          DOM.oscRampInDuration.value = data.oscillation.rampInDurationMs;
        }
        
        if (AppState.editing.oscField !== 'oscRampOutDuration' && document.activeElement !== DOM.oscRampOutDuration) {
          DOM.oscRampOutDuration.value = data.oscillation.rampOutDurationMs;
        }
        
        if (AppState.editing.oscField !== 'oscCycleCount' && document.activeElement !== DOM.oscCycleCount) {
          DOM.oscCycleCount.value = data.oscillation.cycleCount;
        }
        
        // Checkboxes (not edited via focus)
        DOM.oscRampInEnable.checked = data.oscillation.enableRampIn;
        DOM.oscRampOutEnable.checked = data.oscillation.enableRampOut;
        DOM.oscReturnCenter.checked = data.oscillation.returnToCenter;
        
        // Update ramp visibility (removed in compact mode - always visible inline)
        // DOM.oscRampInConfig.style.display = 
        //   data.oscillation.enableRampIn ? 'block' : 'none';
        // DOM.oscRampOutConfig.style.display = 
        //   data.oscillation.enableRampOut ? 'block' : 'none';
        
        // Validate limits (only if not editing center or amplitude)
        if (AppState.editing.oscField !== 'oscCenter' && AppState.editing.oscField !== 'oscAmplitude') {
          validateOscillationLimits();
        }
        
        // Update preset buttons visual state
        updateOscillationPresets();
      }
      
      // ===== UPDATE CYCLE PAUSE DISPLAY (MODE SIMPLE) =====
      if (data.motion && data.motion.cyclePause) {
        const pauseStatus = document.getElementById('cyclePauseStatus');
        const pauseRemaining = document.getElementById('cyclePauseRemaining');
        
        if (data.motion.cyclePause.isPausing && pauseStatus && pauseRemaining) {
          // Use server-calculated remaining time
          const remainingSec = (data.motion.cyclePause.remainingMs / 1000).toFixed(1);
          
          pauseStatus.style.display = 'block';
          pauseRemaining.textContent = remainingSec + 's';
        } else if (pauseStatus) {
          pauseStatus.style.display = 'none';
        }
        
        // Sync UI to backend state (only if section is expanded)
        const section = document.querySelector('.section-collapsible:has(#cyclePauseHeaderText)');
        const headerText = document.getElementById('cyclePauseHeaderText');
        if (section && headerText) {
          const isEnabled = data.motion.cyclePause.enabled;
          const isCollapsed = section.classList.contains('collapsed');
          
          // Sync collapsed state with backend enabled state
          if (isEnabled && isCollapsed) {
            section.classList.remove('collapsed');
            headerText.textContent = 'â¸ï¸ Pause entre cycles - activÃ©e';
          } else if (!isEnabled && !isCollapsed) {
            section.classList.add('collapsed');
            headerText.textContent = 'â¸ï¸ Pause entre cycles - dÃ©sactivÃ©e';
          }
          
          // Sync radio buttons
          if (data.motion.cyclePause.isRandom) {
            document.getElementById('pauseModeRandom').checked = true;
            document.getElementById('pauseFixedControls').style.display = 'none';
            document.getElementById('pauseRandomControls').style.display = 'block';
          } else {
            document.getElementById('pauseModeFixed').checked = true;
            document.getElementById('pauseFixedControls').style.display = 'flex';
            document.getElementById('pauseRandomControls').style.display = 'none';
          }
          
          // Sync input values (avoid overwriting if user is editing)
          if (document.activeElement !== document.getElementById('cyclePauseDuration')) {
            document.getElementById('cyclePauseDuration').value = data.motion.cyclePause.pauseDurationSec.toFixed(1);
          }
          if (document.activeElement !== document.getElementById('cyclePauseMin')) {
            document.getElementById('cyclePauseMin').value = data.motion.cyclePause.minPauseSec.toFixed(1);
          }
          if (document.activeElement !== document.getElementById('cyclePauseMax')) {
            document.getElementById('cyclePauseMax').value = data.motion.cyclePause.maxPauseSec.toFixed(1);
          }
        }
      }
      
      // ===== UPDATE CYCLE PAUSE DISPLAY (MODE OSCILLATION) =====
      if (data.oscillation && data.oscillation.cyclePause) {
        const pauseStatusOsc = document.getElementById('cyclePauseStatusOsc');
        const pauseRemainingOsc = document.getElementById('cyclePauseRemainingOsc');
        
        if (data.oscillation.cyclePause.isPausing && pauseStatusOsc && pauseRemainingOsc) {
          // Use server-calculated remaining time
          const remainingSec = (data.oscillation.cyclePause.remainingMs / 1000).toFixed(1);
          
          pauseStatusOsc.style.display = 'block';
          pauseRemainingOsc.textContent = remainingSec + 's';
        } else if (pauseStatusOsc) {
          pauseStatusOsc.style.display = 'none';
        }
        
        // Sync UI to backend state (only if section is expanded)
        const sectionOsc = document.querySelector('.section-collapsible:has(#cyclePauseOscHeaderText)');
        const headerTextOsc = document.getElementById('cyclePauseOscHeaderText');
        if (sectionOsc && headerTextOsc) {
          const isEnabled = data.oscillation.cyclePause.enabled;
          const isCollapsed = sectionOsc.classList.contains('collapsed');
          
          // Sync collapsed state with backend enabled state
          if (isEnabled && isCollapsed) {
            sectionOsc.classList.remove('collapsed');
            headerTextOsc.textContent = 'â¸ï¸ Pause entre cycles - activÃ©e';
          } else if (!isEnabled && !isCollapsed) {
            sectionOsc.classList.add('collapsed');
            headerTextOsc.textContent = 'â¸ï¸ Pause entre cycles - dÃ©sactivÃ©e';
          }
          
          // Sync radio buttons
          if (data.oscillation.cyclePause.isRandom) {
            document.getElementById('pauseModeRandomOsc').checked = true;
            document.getElementById('pauseFixedControlsOsc').style.display = 'none';
            document.getElementById('pauseRandomControlsOsc').style.display = 'block';
          } else {
            document.getElementById('pauseModeFixedOsc').checked = true;
            document.getElementById('pauseFixedControlsOsc').style.display = 'flex';
            document.getElementById('pauseRandomControlsOsc').style.display = 'none';
          }
          
          // Sync input values (avoid overwriting if user is editing)
          if (document.activeElement !== document.getElementById('cyclePauseDurationOsc')) {
            document.getElementById('cyclePauseDurationOsc').value = data.oscillation.cyclePause.pauseDurationSec.toFixed(1);
          }
          if (document.activeElement !== document.getElementById('cyclePauseMinOsc')) {
            document.getElementById('cyclePauseMinOsc').value = data.oscillation.cyclePause.minPauseSec.toFixed(1);
          }
          if (document.activeElement !== document.getElementById('cyclePauseMaxOsc')) {
            document.getElementById('cyclePauseMaxOsc').value = data.oscillation.cyclePause.maxPauseSec.toFixed(1);
          }
        }
      }
      
      // Update chaos UI
      updateChaosUI(data);
      
      // Update Pause/Resume buttons for Simple, Oscillation, and Chaos modes
      const isPaused = (data.state === SystemState.PAUSED);
      const isRunningOrPaused = (isRunning || isPaused);
      const isError = (data.state === SystemState.ERROR);
      
      // Simple mode Pause button
      const btnPause = document.getElementById('btnPause');
      if (btnPause) {
        btnPause.disabled = !isRunningOrPaused;
        if (isPaused) {
          btnPause.innerHTML = 'â–¶ Reprendre';
        } else {
          btnPause.innerHTML = 'â¸ Pause';
        }
      }
      
      // Simple mode Stop button - ALSO enabled in ERROR state for recovery
      const btnStop = document.getElementById('btnStop');
      if (btnStop) {
        btnStop.disabled = !(isRunningOrPaused || isError);
      }
      
      // Oscillation mode Pause button
      const btnPauseOsc = document.getElementById('btnPauseOscillation');
      if (btnPauseOsc) {
        btnPauseOsc.disabled = !isRunningOrPaused;
        if (isPaused) {
          btnPauseOsc.innerHTML = 'â–¶ Reprendre';
        } else {
          btnPauseOsc.innerHTML = 'â¸ Pause';
        }
      }
      
      // Oscillation mode Stop button - ALSO enabled in ERROR state for recovery
      const btnStopOsc = document.getElementById('btnStopOscillation');
      if (btnStopOsc) {
        btnStopOsc.disabled = !(isRunningOrPaused || isError);
      }
      
      // Chaos mode Pause button
      const btnPauseChaos = document.getElementById('btnPauseChaos');
      if (btnPauseChaos) {
        btnPauseChaos.disabled = !isRunningOrPaused;
        if (isPaused) {
          btnPauseChaos.innerHTML = 'â–¶ Reprendre';
        } else {
          btnPauseChaos.innerHTML = 'â¸ Pause';
        }
      }
      
      // Chaos mode Stop button - ALSO enabled in ERROR state for recovery
      const btnStopChaos = document.getElementById('btnStopChaos');
      if (btnStopChaos) {
        btnStopChaos.disabled = !(isRunningOrPaused || isError);
      }
      
      // Note: Sequence start buttons are NOT managed here anymore
      // They are controlled ONLY by:
      // 1. User click (immediate disable)
      // 2. Backend sequenceStatus (re-enable when stopped)
      // This prevents flickering/desync issues
      
      // Update system stats
      if (data.system) {
        updateSystemStats(data.system);
      }
    }
    
    function updateSystemStats(system) {
      // Defense: Check system object exists before accessing fields
      if (!system) {
        console.warn('updateSystemStats: system object is undefined');
        return;
      }
      
      // CPU frequency
      if (system.cpuFreqMHz !== undefined) {
        document.getElementById('sysCpuFreq').textContent = system.cpuFreqMHz + ' MHz';
      }
      
      // Temperature
      if (system.temperatureC !== undefined) {
        const temp = parseFloat(system.temperatureC);
        const tempEl = document.getElementById('sysTemp');
        tempEl.textContent = temp.toFixed(1) + ' Â°C';
        // Color coding based on temperature
        if (temp > 80) {
          tempEl.style.color = '#f44336'; // Red - hot
        } else if (temp > 70) {
          tempEl.style.color = '#FF9800'; // Orange - warm
        } else {
          tempEl.style.color = '#333'; // Normal
        }
      }
      
      // RAM
      if (system.heapFree !== undefined && system.heapTotal !== undefined && system.heapUsedPercent !== undefined) {
        const ramFreeMB = (system.heapFree / 1024).toFixed(1);
        const ramTotalMB = (system.heapTotal / 1024).toFixed(1);
        const ramUsedPercent = parseFloat(system.heapUsedPercent);
        document.getElementById('sysRam').textContent = ramFreeMB + ' KB libre / ' + ramTotalMB + ' KB';
        document.getElementById('sysRamPercent').textContent = ramUsedPercent.toFixed(1) + '% utilisÃ©';
      }
      
      // PSRAM
      if (system.psramFree !== undefined && system.psramTotal !== undefined && system.psramUsedPercent !== undefined) {
        const psramFreeMB = (system.psramFree / 1024 / 1024).toFixed(1);
        const psramTotalMB = (system.psramTotal / 1024 / 1024).toFixed(1);
        const psramUsedPercent = parseFloat(system.psramUsedPercent);
        document.getElementById('sysPsram').textContent = psramFreeMB + ' MB libre / ' + psramTotalMB + ' MB';
        document.getElementById('sysPsramPercent').textContent = psramUsedPercent.toFixed(1) + '% utilisÃ©';
      }
      
      // WiFi
      if (system.wifiRssi !== undefined) {
        const rssi = system.wifiRssi;
        let quality = 'Inconnu';
        let qualityColor = '#666';
        if (rssi >= -50) {
          quality = 'Excellent';
          qualityColor = '#4CAF50';
        } else if (rssi >= -60) {
          quality = 'TrÃ¨s bon';
          qualityColor = '#8BC34A';
        } else if (rssi >= -70) {
          quality = 'Bon';
          qualityColor = '#FFC107';
        } else if (rssi >= -80) {
          quality = 'Faible';
          qualityColor = '#FF9800';
        } else {
          quality = 'TrÃ¨s faible';
          qualityColor = '#f44336';
        }
        document.getElementById('sysWifi').textContent = rssi + ' dBm';
        const qualityEl = document.getElementById('sysWifiQuality');
        qualityEl.textContent = quality;
        qualityEl.style.color = qualityColor;
      }
      
      // Uptime
      if (system.uptimeSeconds !== undefined) {
        const uptimeSec = system.uptimeSeconds;
        const hours = Math.floor(uptimeSec / 3600);
        const minutes = Math.floor((uptimeSec % 3600) / 60);
        const seconds = uptimeSec % 60;
        const uptimeStr = hours > 0 
          ? `${hours}h ${minutes}m ${seconds}s`
          : minutes > 0
            ? `${minutes}m ${seconds}s`
            : `${seconds}s`;
        document.getElementById('sysUptime').textContent = uptimeStr;
      }
    }
    
    // ============================================================================
    // PLAYLIST MANAGEMENT FUNCTIONS
    // ============================================================================
    
    function generatePresetName(mode, config) {
      if (mode === 'simple') {
        return `${config.startPositionMM}â†’${config.startPositionMM + config.distanceMM}mm v:${config.speedLevelForward}/${config.speedLevelBackward}`;
      } else if (mode === 'oscillation') {
        const waveNames = ['Sine', 'Triangle', 'Square'];
        return `${waveNames[config.waveform] || 'Sine'} ${config.frequencyHz}Hz Â±${config.amplitudeMM}mm`;
      } else if (mode === 'chaos') {
        return `Chaos ${config.durationSeconds}s (${config.crazinessPercent}%)`;
      }
      return 'Preset';
    }
    
    function generatePresetTooltip(mode, config) {
      if (mode === 'simple') {
        // Deceleration info
        let decelInfo = 'Aucune';
        if (config && (config.decelStartEnabled || config.decelEndEnabled)) {
          const parts = [];
          if (config.decelStartEnabled) parts.push('DÃ©part');
          if (config.decelEndEnabled) parts.push('Fin');
          const modeNames = ['Lin', 'Sin', 'Triâ»Â¹', 'Sinâ»Â¹'];
          decelInfo = parts.join('+') + ` (${config.decelZoneMM || 20}mm, ${config.decelEffectPercent || 50}%, ${modeNames[config.decelMode || 1]})`;
        }
        
        // Cycle pause info
        let cyclePauseInfo = 'Aucune';
        if (config && config.cyclePauseEnabled) {
          if (config.cyclePauseIsRandom) {
            cyclePauseInfo = `${config.cyclePauseMinSec || 0.5}s-${config.cyclePauseMaxSec || 3.0}s (alÃ©atoire)`;
          } else {
            cyclePauseInfo = `${config.cyclePauseDurationSec || 0}s (fixe)`;
          }
        }
        
        return `ğŸ“ DÃ©part: ${config.startPositionMM || 0}mm
ğŸ“ Distance: ${config.distanceMM || 50}mm
â¡ï¸ Vitesse aller: ${config.speedLevelForward || 5}/20
â¬…ï¸ Vitesse retour: ${config.speedLevelBackward || 5}/20
ğŸ›‘ DÃ©cel: ${decelInfo}
â¸ï¸ Pause/cycle: ${cyclePauseInfo}
â±ï¸ DurÃ©e estimÃ©e: ${((config.distanceMM / (config.speedLevelForward * 10)) * 60).toFixed(1)}s`;
      } else if (mode === 'oscillation') {
        const waveNames = ['ğŸŒŠ Sine', 'ğŸ“ Triangle', 'â¬œ CarrÃ©'];
        const ramps = [];
        if (config.enableRampIn) ramps.push('IN');
        if (config.enableRampOut) ramps.push('OUT');
        
        // Cycle pause info
        let cyclePauseInfo = 'Aucune';
        if (config && config.cyclePauseEnabled) {
          if (config.cyclePauseIsRandom) {
            cyclePauseInfo = `${config.cyclePauseMinSec || 0.5}s-${config.cyclePauseMaxSec || 3.0}s (alÃ©atoire)`;
          } else {
            cyclePauseInfo = `${config.cyclePauseDurationSec || 0}s (fixe)`;
          }
        }
        
        return `${waveNames[config.waveform] || 'ğŸŒŠ Sine'}
ğŸ“ Centre: ${config.centerPositionMM || 100}mm
â†”ï¸ Amplitude: Â±${config.amplitudeMM || 20}mm
âš¡ FrÃ©quence: ${config.frequencyHz || 1}Hz
ğŸ”„ Cycles: ${config.cycleCount === 0 ? 'âˆ' : config.cycleCount}
${ramps.length > 0 ? 'ğŸ“ˆ Rampes: ' + ramps.join(', ') : ''}
â¸ï¸ Pause/cycle: ${cyclePauseInfo}`;
      } else if (mode === 'chaos') {
        const enabledCount = config.patternsEnabled ? config.patternsEnabled.filter(p => p).length : 11;
        return `ğŸ“ Centre: ${config.centerPositionMM}mm
â†”ï¸ Amplitude: Â±${config.amplitudeMM}mm
âš¡ Vitesse max: ${config.maxSpeedLevel}/20
ğŸ² Folie: ${config.crazinessPercent}%
â±ï¸ DurÃ©e: ${config.durationSeconds === 0 ? 'âˆ' : config.durationSeconds + 's'}
ğŸ­ Patterns: ${enabledCount}/11 actifs`;
      }
      return 'Preset';
    }
    
    /**
     * Generate tooltip content for sequence line
     */
    function generateSequenceLineTooltip(line) {
      const movementType = line.movementType !== undefined ? line.movementType : 0;
      
      if (movementType === 0) {
        // VA-ET-VIENT
        const decelInfo = [];
        if (line.decelStartEnabled) decelInfo.push('DÃ©part');
        if (line.decelEndEnabled) decelInfo.push('Fin');
        const decelModes = ['LinÃ©aire', 'SinusoÃ¯dal', 'Triangleâ»Â¹', 'Sineâ»Â¹'];
        
        // Cycle pause info
        let cyclePauseInfo = 'Aucune';
        if (line.vaetCyclePauseEnabled) {
          if (line.vaetCyclePauseIsRandom) {
            cyclePauseInfo = `${line.vaetCyclePauseMinSec}s-${line.vaetCyclePauseMaxSec}s (alÃ©atoire)`;
          } else {
            cyclePauseInfo = `${line.vaetCyclePauseDurationSec}s (fixe)`;
          }
        }
        
        return `ğŸ”„ VA-ET-VIENT
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“ DÃ©part: ${line.startPositionMM}mm
ğŸ“ Distance: ${line.distanceMM}mm
â¡ï¸ Vitesse aller: ${line.speedForward.toFixed(1)}/20
â¬…ï¸ Vitesse retour: ${line.speedBackward.toFixed(1)}/20
${decelInfo.length > 0 ? 'ğŸ›‘ DÃ©cel: ' + decelInfo.join(' + ') + ' (' + line.decelZoneMM + 'mm, ' + line.decelEffectPercent + '%, ' + decelModes[line.decelMode] + ')' : 'ğŸ›‘ DÃ©cel: Aucune'}
ğŸ”„ Cycles: ${line.cycleCount}
â¸ï¸ Pause/cycle: ${cyclePauseInfo}
â±ï¸ Pause aprÃ¨s: ${line.pauseAfterMs > 0 ? (line.pauseAfterMs / 1000).toFixed(1) + 's' : 'Aucune'}`;
      } else if (movementType === 1) {
        // OSCILLATION
        const waveNames = ['ğŸŒŠ Sine', 'ğŸ“ Triangle', 'â¬œ CarrÃ©'];
        const ramps = [];
        if (line.oscEnableRampIn) ramps.push('IN (' + line.oscRampInDurationMs + 'ms)');
        if (line.oscEnableRampOut) ramps.push('OUT (' + line.oscRampOutDurationMs + 'ms)');
        
        const peakSpeed = (2 * Math.PI * line.oscFrequencyHz * line.oscAmplitudeMM).toFixed(1);
        
        // Cycle pause info
        let cyclePauseInfo = 'Aucune';
        if (line.oscCyclePauseEnabled) {
          if (line.oscCyclePauseIsRandom) {
            cyclePauseInfo = `${line.oscCyclePauseMinSec}s-${line.oscCyclePauseMaxSec}s (alÃ©atoire)`;
          } else {
            cyclePauseInfo = `${line.oscCyclePauseDurationSec}s (fixe)`;
          }
        }
        
        return `ã€°ï¸ OSCILLATION
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
${waveNames[line.oscWaveform] || 'ğŸŒŠ Sine'}
ğŸ“ Centre: ${line.oscCenterPositionMM}mm
â†”ï¸ Amplitude: Â±${line.oscAmplitudeMM}mm
âš¡ FrÃ©quence: ${line.oscFrequencyHz}Hz
âš¡ Vitesse pic: ${peakSpeed}mm/s
ğŸ”„ Cycles: ${line.cycleCount}
${ramps.length > 0 ? 'ğŸ“ˆ Rampes: ' + ramps.join(' + ') : 'ğŸ“ˆ Rampes: Aucune'}
â¸ï¸ Pause/cycle: ${cyclePauseInfo}
â±ï¸ Pause aprÃ¨s: ${line.pauseAfterMs > 0 ? (line.pauseAfterMs / 1000).toFixed(1) + 's' : 'Aucune'}`;
      } else if (movementType === 2) {
        // CHAOS
        const enabledCount = line.chaosPatternsEnabled ? line.chaosPatternsEnabled.filter(p => p).length : 11;
        
        return `ğŸŒ€ CHAOS
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
ğŸ“ Centre: ${line.chaosCenterPositionMM}mm
â†”ï¸ Amplitude: Â±${line.chaosAmplitudeMM}mm
âš¡ Vitesse max: ${line.chaosMaxSpeedLevel.toFixed(1)}/20
ğŸ² Folie: ${line.chaosCrazinessPercent}%
â±ï¸ DurÃ©e: ${line.chaosDurationSeconds}s
ğŸŒ± Seed: ${line.chaosSeed}
ğŸ­ Patterns: ${enabledCount}/11 actifs
â±ï¸ Pause aprÃ¨s: ${line.pauseAfterMs > 0 ? (line.pauseAfterMs / 1000).toFixed(1) + 's' : 'Aucune'}`;
      } else if (movementType === 4) {
        // CALIBRATION
        return `ğŸ“ CALIBRATION
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Recalibration complÃ¨te du systÃ¨me
RÃ©initialise la position Ã  0mm
DÃ©tecte la limite physique`;
      }
      
      return 'Ligne de sÃ©quence';
    }
    
    function getCurrentModeConfig(mode) {
      if (mode === 'simple') {
        // Check if cycle pause section is expanded (enabled)
        const cyclePauseSection = document.querySelector('.section-collapsible:has(#cyclePauseHeaderText)');
        const cyclePauseEnabled = cyclePauseSection && !cyclePauseSection.classList.contains('collapsed');
        
        // ğŸ†• Check if deceleration section is expanded (enabled)
        const decelSection = document.getElementById('decelSection');
        const decelSectionEnabled = decelSection && !decelSection.classList.contains('collapsed');
        
        // Determine if random mode is selected
        const isRandom = document.getElementById('pauseModeRandom')?.checked || false;
        
        return {
          startPositionMM: parseFloat(document.getElementById('startPosition').value) || 0,
          distanceMM: parseFloat(document.getElementById('distance').value) || 50,
          speedLevelForward: parseFloat(document.getElementById('speedForward')?.value || document.getElementById('speedUnified').value) || 5,
          speedLevelBackward: parseFloat(document.getElementById('speedBackward')?.value || document.getElementById('speedUnified').value) || 5,
          // ğŸ†• Deceleration parameters - ONLY if section is expanded
          decelStartEnabled: decelSectionEnabled ? (document.getElementById('decelZoneStart')?.checked || false) : false,
          decelEndEnabled: decelSectionEnabled ? (document.getElementById('decelZoneEnd')?.checked || false) : false,
          decelZoneMM: parseFloat(document.getElementById('decelZoneMM')?.value) || 20,
          decelEffectPercent: parseFloat(document.getElementById('decelEffectPercent')?.value) || 50,
          decelMode: parseInt(document.getElementById('decelModeSelect')?.value) || 1,
          // Cycle pause parameters
          cyclePauseEnabled: cyclePauseEnabled,
          cyclePauseIsRandom: isRandom,
          cyclePauseDurationSec: parseFloat(document.getElementById('cyclePauseDuration')?.value) || 0.0,
          cyclePauseMinSec: parseFloat(document.getElementById('cyclePauseMin')?.value) || 0.5,
          cyclePauseMaxSec: parseFloat(document.getElementById('cyclePauseMax')?.value) || 3.0
        };
      } else if (mode === 'oscillation') {
        // Check if cycle pause section is expanded (enabled)
        const cyclePauseOscSection = document.querySelector('.section-collapsible:has(#cyclePauseOscHeaderText)');
        const cyclePauseEnabled = cyclePauseOscSection && !cyclePauseOscSection.classList.contains('collapsed');
        
        // Determine if random mode is selected
        const isRandom = document.getElementById('pauseModeRandomOsc')?.checked || false;
        
        return {
          centerPositionMM: parseFloat(document.getElementById('oscCenter').value) || 100,
          amplitudeMM: parseFloat(document.getElementById('oscAmplitude').value) || 20,
          waveform: parseInt(document.getElementById('oscWaveform').value) || 0,
          frequencyHz: parseFloat(document.getElementById('oscFrequency').value) || 1.0,
          cycleCount: parseInt(document.getElementById('oscCycleCount').value) || 10,
          enableRampIn: document.getElementById('oscRampInEnable').checked,
          rampInDurationMs: parseInt(document.getElementById('oscRampInDuration').value) || 2000,
          enableRampOut: document.getElementById('oscRampOutEnable').checked,
          rampOutDurationMs: parseInt(document.getElementById('oscRampOutDuration').value) || 2000,
          returnToCenter: document.getElementById('oscReturnCenter').checked,
          // Cycle pause parameters
          cyclePauseEnabled: cyclePauseEnabled,
          cyclePauseIsRandom: isRandom,
          cyclePauseDurationSec: parseFloat(document.getElementById('cyclePauseDurationOsc')?.value) || 0.0,
          cyclePauseMinSec: parseFloat(document.getElementById('cyclePauseMinOsc')?.value) || 0.5,
          cyclePauseMaxSec: parseFloat(document.getElementById('cyclePauseMaxOsc')?.value) || 3.0
        };
      } else if (mode === 'chaos') {
        const patterns = [
          document.getElementById('patternZigzag').checked,
          document.getElementById('patternSweep').checked,
          document.getElementById('patternPulse').checked,
          document.getElementById('patternDrift').checked,
          document.getElementById('patternBurst').checked,
          document.getElementById('patternWave').checked,
          document.getElementById('patternPendulum').checked,
          document.getElementById('patternSpiral').checked,
          document.getElementById('patternCalm').checked,
          document.getElementById('patternBruteForce').checked,
          document.getElementById('patternLiberator').checked
        ];
        return {
          centerPositionMM: parseFloat(document.getElementById('chaosCenterPos').value) || 100,
          amplitudeMM: parseFloat(document.getElementById('chaosAmplitude').value) || 40,
          maxSpeedLevel: parseFloat(document.getElementById('chaosMaxSpeed').value) || 15,
          crazinessPercent: parseInt(document.getElementById('chaosCraziness').value) || 50,
          durationSeconds: parseInt(document.getElementById('chaosDuration').value) || 30,
          patternsEnabled: patterns
        };
      }
      return {};
    }
    
    function openPlaylistModal(mode) {
      const modal = document.getElementById('playlistModal');
      const titleEl = document.getElementById('playlistModalTitle');
      const configEl = document.getElementById('playlistCurrentConfigContent');
      
      modal.dataset.mode = mode;
      
      if (mode === 'simple') {
        titleEl.textContent = 'Mode Simple';
      } else if (mode === 'oscillation') {
        titleEl.textContent = 'Mode Oscillation';
      } else if (mode === 'chaos') {
        titleEl.textContent = 'Mode Chaos';
      }
      
      // Display current config
      const config = getCurrentModeConfig(mode);
      let configHTML = '';
      
      if (mode === 'simple') {
        configHTML = `
          â€¢ DÃ©part: ${config.startPositionMM} mm<br>
          â€¢ Distance: ${config.distanceMM} mm<br>
          â€¢ Vitesse aller: ${config.speedLevelForward}<br>
          â€¢ Vitesse retour: ${config.speedLevelBackward}
        `;
      } else if (mode === 'oscillation') {
        const waveNames = ['Sine', 'Triangle', 'Square'];
        configHTML = `
          â€¢ Centre: ${config.centerPositionMM} mm<br>
          â€¢ Amplitude: Â±${config.amplitudeMM} mm<br>
          â€¢ Forme: ${waveNames[config.waveform]}<br>
          â€¢ FrÃ©quence: ${config.frequencyHz} Hz<br>
          â€¢ Cycles: ${config.cycleCount === 0 ? 'âˆ (infini)' : config.cycleCount}
        `;
      } else if (mode === 'chaos') {
        const enabledCount = config.patternsEnabled.filter(p => p).length;
        configHTML = `
          â€¢ Centre: ${config.centerPositionMM} mm<br>
          â€¢ Amplitude: Â±${config.amplitudeMM} mm<br>
          â€¢ Vitesse max: ${config.maxSpeedLevel}<br>
          â€¢ Craziness: ${config.crazinessPercent}%<br>
          â€¢ DurÃ©e: ${config.durationSeconds === 0 ? 'âˆ (infini)' : config.durationSeconds + 's'}<br>
          â€¢ Patterns actifs: ${enabledCount}/11
        `;
      }
      
      configEl.innerHTML = configHTML;
      
      // Refresh presets list
      refreshPlaylistPresets(mode);
      
      modal.classList.add('active');
    }
    
    function closePlaylistModal() {
      document.getElementById('playlistModal').classList.remove('active');
    }
    
    function closePlaylistModalOnOverlayClick(event) {
      // Only close if clicking on the overlay itself (not the content)
      if (event.target.id === 'playlistModal') {
        closePlaylistModal();
      }
    }
    
    function refreshPlaylistPresets(mode) {
      const listEl = document.getElementById('playlistPresetsList');
      const countEl = document.getElementById('playlistCount');
      const presets = PlaylistState[mode] || [];
      
      console.log('ğŸ”„ refreshPlaylistPresets called for mode:', mode, 'presets count:', presets.length);
      
      countEl.textContent = presets.length;
      
      if (presets.length === 0) {
        console.log('âš ï¸ No presets found, displaying empty message');
        listEl.innerHTML = '<div style="color: #999; font-style: italic; padding: 20px; text-align: center;">Aucun preset sauvegardÃ©</div>';
        return;
      }
      
      // Sort by timestamp desc (most recent first)
      const sortedPresets = [...presets].sort((a, b) => b.timestamp - a.timestamp);
      
      console.log('âœ… Building HTML for', sortedPresets.length, 'presets');
      
      let html = '';
      sortedPresets.forEach(preset => {
        const tooltipContent = generatePresetTooltip(mode, preset.config);
        html += `
          <div class="preset-item" 
               data-tooltip="${tooltipContent.replace(/"/g, '&quot;')}"
               style="background: #f9f9f9; padding: 8px 10px; border-radius: 4px; margin-bottom: 6px; border: 1px solid #ddd;">
            <div style="display: flex; justify-content: space-between; align-items: center; gap: 6px;">
              <div style="flex: 1; min-width: 0;">
                <div style="font-weight: 500; font-size: 12px; margin-bottom: 2px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">${preset.name}</div>
                <div style="font-size: 10px; color: #888;">${new Date(preset.timestamp * 1000).toLocaleString('fr-FR', {dateStyle: 'short', timeStyle: 'short'})}</div>
              </div>
              <div style="display: flex; gap: 2px; flex-shrink: 0;">
                <button onclick="loadPresetInMode('${mode}', ${preset.id})" style="padding: 4px 6px; font-size: 11px; min-width: unset;" title="Charger dans le mode actuel">
                  â¬‡ï¸
                </button>
                <button onclick="quickAddToSequencer('${mode}', ${preset.id})" style="padding: 4px 6px; font-size: 11px; min-width: unset;" title="Ajouter direct au sÃ©quenceur">
                  â•ğŸ“‹
                </button>
                <button onclick="renamePlaylistPreset('${mode}', ${preset.id})" style="padding: 4px 6px; font-size: 11px; min-width: unset;" title="Renommer">
                  âœï¸
                </button>
                <button onclick="deleteFromPlaylist('${mode}', ${preset.id})" style="padding: 4px 6px; font-size: 11px; min-width: unset;" title="Supprimer">
                  ğŸ—‘ï¸
                </button>
                <button class="preset-tooltip-eye" data-preset-id="${preset.id}"
                  style="display: inline-block; padding: 4px 6px; cursor: pointer; font-size: 14px;"
                  title="Voir dÃ©tails">ğŸ‘ï¸</button>
              </div>
            </div>
          </div>
        `;
      });
      
      console.log('âœ… Setting HTML, length:', html.length);
      listEl.innerHTML = html;
      
      // Attach eye icon tooltip handlers after DOM insertion
      setTimeout(() => {
        document.querySelectorAll('.preset-tooltip-eye').forEach(eyeIcon => {
          eyeIcon.onmouseenter = function(e) {
            const presetItem = this.closest('.preset-item');
            if (presetItem) {
              showPlaylistTooltip(presetItem);
            }
          };
          eyeIcon.onmouseleave = function() {
            hidePlaylistTooltip();
          };
        });
      }, 0);
    }
    
    function showPlaylistTooltip(element) {
      const tooltipContent = element.getAttribute('data-tooltip');
      const overlay = document.getElementById('playlistTooltipOverlay');
      if (overlay && tooltipContent) {
        overlay.innerHTML = tooltipContent;
        overlay.classList.add('visible');
      }
    }
    
    function hidePlaylistTooltip() {
      const overlay = document.getElementById('playlistTooltipOverlay');
      if (overlay) {
        overlay.classList.remove('visible');
      }
    }
    
    /**
     * Show sequence line tooltip
     */
    function showSequenceTooltip(element) {
      const tooltipContent = element.getAttribute('data-tooltip');
      const lineNumber = element.getAttribute('data-line-number');
      const lineType = element.getAttribute('data-line-type');
      
      const overlay = document.getElementById('playlistTooltipOverlay');
      if (overlay && tooltipContent) {
        const header = `<div style="font-weight: 600; margin-bottom: 8px; font-size: 14px; border-bottom: 2px solid rgba(255,255,255,0.3); padding-bottom: 6px;">#${lineNumber} - ${lineType}</div>`;
        overlay.innerHTML = header + tooltipContent;
        overlay.classList.add('visible');
      }
    }
    
    function filterPlaylistPresets(searchTerm) {
      const items = document.querySelectorAll('.preset-item');
      const term = (searchTerm || '').toLowerCase().trim();
      let visibleCount = 0;
      
      items.forEach(item => {
        // Search in preset name
        const nameEl = item.querySelector('div > div:first-child');
        const name = nameEl ? nameEl.textContent.toLowerCase() : '';
        const visible = term === '' || name.includes(term);
        
        item.style.display = visible ? 'block' : 'none';
        if (visible) visibleCount++;
      });
      
      // Update count display
      const countEl = document.getElementById('playlistCount');
      if (countEl) {
        countEl.textContent = visibleCount;
      }
      
      console.log('ğŸ” Search:', term, 'â†’', visibleCount, 'results');
    }
    
    function addToPlaylist(mode) {
      const config = getCurrentModeConfig(mode);
      
      // Validation: refuse infinite durations
      if (mode === 'oscillation' && config.cycleCount === 0) {
        showNotification('âŒ Impossible d\'ajouter: cycles infinis non supportÃ©s dans la playlist', 'error', 5000);
        return;
      }
      if (mode === 'chaos' && config.durationSeconds === 0) {
        showNotification('âŒ Impossible d\'ajouter: durÃ©e infinie non supportÃ©e dans la playlist', 'error', 5000);
        return;
      }
      
      // Check limit
      if (PlaylistState[mode].length >= 20) {
        showNotification('âŒ Limite atteinte: maximum 20 presets par mode', 'error', 4000);
        return;
      }
      
      // Generate default name
      const defaultName = generatePresetName(mode, config);
      const name = prompt('Nom du preset:', defaultName);
      if (!name) return;
      
      // Send to backend
      fetch('/api/playlists/add', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({
          mode: mode,
          name: name,
          config: config
        })
      })
      .then(r => r.json())
      .then(data => {
        if (data.success) {
          showNotification('âœ… Preset ajoutÃ© Ã  la playlist', 'success', 3000);
          console.log('âœ… Preset added, reloading playlists...');
          // Reload playlists, then refresh modal display
          loadPlaylists(() => {
            console.log('âœ… Playlists reloaded, refreshing modal for mode:', mode);
            refreshPlaylistPresets(mode);
          });
        } else {
          showNotification('âŒ Erreur: ' + (data.error || 'Unknown'), 'error');
        }
      })
      .catch(error => {
        showNotification('âŒ Erreur rÃ©seau: ' + error, 'error');
      });
    }
    
    function deleteFromPlaylist(mode, id) {
      if (!confirm('Supprimer ce preset de la playlist?')) return;
      
      fetch('/api/playlists/delete', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({
          mode: mode,
          id: id
        })
      })
      .then(r => r.json())
      .then(data => {
        if (data.success) {
          showNotification('âœ… Preset supprimÃ©', 'success', 2000);
          // Reload playlists, then refresh modal display
          loadPlaylists(() => refreshPlaylistPresets(mode));
        } else {
          showNotification('âŒ Erreur: ' + (data.error || 'Unknown'), 'error');
        }
      })
      .catch(error => {
        showNotification('âŒ Erreur rÃ©seau: ' + error, 'error');
      });
    }
    
    function renamePlaylistPreset(mode, id) {
      const preset = PlaylistState[mode].find(p => p.id === id);
      if (!preset) return;
      
      const newName = prompt('Nouveau nom:', preset.name);
      if (!newName || newName === preset.name) return;
      
      fetch('/api/playlists/update', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({
          mode: mode,
          id: id,
          name: newName
        })
      })
      .then(r => r.json())
      .then(data => {
        if (data.success) {
          showNotification('âœ… Preset renommÃ©', 'success', 2000);
          // Reload playlists, then refresh modal display
          loadPlaylists(() => refreshPlaylistPresets(mode));
        } else {
          showNotification('âŒ Erreur: ' + (data.error || 'Unknown'), 'error');
        }
      })
      .catch(error => {
        showNotification('âŒ Erreur rÃ©seau: ' + error, 'error');
      });
    }
    
    function loadPresetInMode(mode, id) {
      const preset = PlaylistState[mode].find(p => p.id === id);
      if (!preset) {
        console.error('âŒ Preset not found:', mode, id);
        return;
      }
      
      console.log('ğŸ“¥ Loading preset:', preset.name, '| Config:', preset.config);
      
      const config = preset.config;
      
      if (mode === 'simple') {
        // Load basic parameters
        document.getElementById('startPosition').value = config.startPositionMM || 0;
        document.getElementById('distance').value = config.distanceMM || 50;
        
        // Check if unified or separate speed mode
        const isSeparate = document.getElementById('speedModeSeparate').checked;
        if (isSeparate) {
          document.getElementById('speedForward').value = config.speedLevelForward || 5;
          document.getElementById('speedBackward').value = config.speedLevelBackward || 5;
        } else {
          document.getElementById('speedUnified').value = config.speedLevelForward || 5;
        }
        
        // ğŸ†• Load DECELERATION parameters (if present)
        if (config.decelStartEnabled !== undefined) {
          const decelStartEl = document.getElementById('decelZoneStart');
          if (decelStartEl) decelStartEl.checked = config.decelStartEnabled;
        }
        if (config.decelEndEnabled !== undefined) {
          const decelEndEl = document.getElementById('decelZoneEnd');
          if (decelEndEl) decelEndEl.checked = config.decelEndEnabled;
        }
        if (config.decelZoneMM !== undefined) {
          const decelZoneEl = document.getElementById('decelZoneMM');
          if (decelZoneEl) decelZoneEl.value = config.decelZoneMM;
        }
        if (config.decelEffectPercent !== undefined) {
          const decelEffectEl = document.getElementById('decelEffectPercent');
          const decelValueEl = document.getElementById('effectValue');
          if (decelEffectEl) decelEffectEl.value = config.decelEffectPercent;
          if (decelValueEl) decelValueEl.textContent = config.decelEffectPercent + '%';
        }
        if (config.decelMode !== undefined) {
          const decelModeEl = document.getElementById('decelModeSelect');
          if (decelModeEl) decelModeEl.value = config.decelMode;
        }
        
        // Auto-expand deceleration section if enabled
        if (config.decelStartEnabled || config.decelEndEnabled) {
          const decelSection = document.getElementById('decelSection');
          if (decelSection?.classList.contains('collapsed')) {
            decelSection.classList.remove('collapsed');
            const chevron = decelSection.querySelector('.section-chevron');
            if (chevron) chevron.textContent = 'â–¼';
          }
        }
        
        // Load cycle pause parameters
        const pauseEnabled = config.cyclePauseEnabled || false;
        const pauseIsRandom = config.cyclePauseIsRandom || false;
        
        // Set radio buttons for pause mode
        const pauseModeFixedEl = document.getElementById('pauseModeFixed');
        const pauseModeRandomEl = document.getElementById('pauseModeRandom');
        if (pauseModeFixedEl && pauseModeRandomEl) {
          if (pauseIsRandom) {
            pauseModeRandomEl.checked = true;
            pauseModeFixedEl.checked = false;
          } else {
            pauseModeFixedEl.checked = true;
            pauseModeRandomEl.checked = false;
          }
        }
        
        // Set pause duration values
        const cyclePauseDurationEl = document.getElementById('cyclePauseDuration');
        const cyclePauseMinEl = document.getElementById('cyclePauseMin');
        const cyclePauseMaxEl = document.getElementById('cyclePauseMax');
        
        if (cyclePauseDurationEl) {
          cyclePauseDurationEl.value = config.cyclePauseDurationSec || 0.0;
        }
        if (cyclePauseMinEl) {
          cyclePauseMinEl.value = config.cyclePauseMinSec || 0.5;
        }
        if (cyclePauseMaxEl) {
          cyclePauseMaxEl.value = config.cyclePauseMaxSec || 3.0;
        }
        
        // Force toggle visibility (fixed/random)
        const fixedDiv = document.getElementById('pauseFixedControls');
        const randomDiv = document.getElementById('pauseRandomControls');
        if (fixedDiv && randomDiv) {
          if (pauseIsRandom) {
            fixedDiv.style.display = 'none';
            randomDiv.style.display = 'block';
          } else {
            fixedDiv.style.display = 'flex';
            randomDiv.style.display = 'none';
          }
        }
        
        // Auto-expand pause section if enabled
        if (pauseEnabled) {
          const pauseSection = document.querySelector('.section-collapsible:has(#cyclePauseHeaderText)');
          const pauseHeaderText = document.getElementById('cyclePauseHeaderText');
          if (pauseSection && pauseHeaderText) {
            if (pauseSection.classList.contains('collapsed')) {
              pauseSection.classList.remove('collapsed');
              const chevron = pauseSection.querySelector('.collapse-icon');
              if (chevron) chevron.textContent = 'â–¼';
            }
            pauseHeaderText.textContent = 'â¸ï¸ Pause entre cycles - activÃ©e';
          }
        }
        
        // Send commands to backend
        sendCommand(WS_CMD.SET_START_POSITION, {startPosition: config.startPositionMM || 0});
        sendCommand(WS_CMD.SET_DISTANCE, {distance: config.distanceMM || 50});
        sendCommand(WS_CMD.SET_SPEED_FORWARD, {speed: config.speedLevelForward || 5});
        sendCommand(WS_CMD.SET_SPEED_BACKWARD, {speed: config.speedLevelBackward || 5});
        
        // Send deceleration config to backend
        const decelCmd = {
          enabled: config.decelStartEnabled || config.decelEndEnabled,
          enableStart: config.decelStartEnabled || false,
          enableEnd: config.decelEndEnabled || false,
          zoneMM: config.decelZoneMM || 20,
          effectPercent: config.decelEffectPercent || 50,
          mode: config.decelMode || 1
        };
        console.log('ğŸ”§ Sending setDecelZone:', decelCmd);
        sendCommand(WS_CMD.SET_DECEL_ZONE, decelCmd);
        
        // Send cycle pause config to backend
        const pauseCmd = {
          mode: 'simple',
          enabled: pauseEnabled,
          isRandom: pauseIsRandom,
          durationSec: config.cyclePauseDurationSec || 0.0,
          minSec: config.cyclePauseMinSec || 0.5,
          maxSec: config.cyclePauseMaxSec || 3.0
        };
        console.log('ğŸ”§ Sending setCyclePause:', pauseCmd);
        sendCommand(WS_CMD.SET_CYCLE_PAUSE, pauseCmd);
        
        console.log('âœ… Simple preset loaded | Pause enabled:', pauseEnabled, '| Random:', pauseIsRandom);
        
      } else if (mode === 'oscillation') {
        document.getElementById('oscCenter').value = config.centerPositionMM || 100;
        document.getElementById('oscAmplitude').value = config.amplitudeMM || 20;
        document.getElementById('oscWaveform').value = config.waveform || 0;
        document.getElementById('oscFrequency').value = config.frequencyHz || 1.0;
        document.getElementById('oscCycleCount').value = config.cycleCount || 10;
        document.getElementById('oscRampInEnable').checked = config.enableRampIn || false;
        document.getElementById('oscRampInDuration').value = config.rampInDurationMs || 2000;
        document.getElementById('oscRampOutEnable').checked = config.enableRampOut || false;
        document.getElementById('oscRampOutDuration').value = config.rampOutDurationMs || 2000;
        document.getElementById('oscReturnCenter').checked = config.returnToCenter || false;
        
        // Load cycle pause parameters
        const pauseEnabled = config.cyclePauseEnabled || false;
        const pauseIsRandom = config.cyclePauseIsRandom || false;
        
        // Set radio buttons for pause mode
        const pauseModeFixedOscEl = document.getElementById('pauseModeFixedOsc');
        const pauseModeRandomOscEl = document.getElementById('pauseModeRandomOsc');
        if (pauseModeFixedOscEl && pauseModeRandomOscEl) {
          if (pauseIsRandom) {
            pauseModeRandomOscEl.checked = true;
            pauseModeFixedOscEl.checked = false;
          } else {
            pauseModeFixedOscEl.checked = true;
            pauseModeRandomOscEl.checked = false;
          }
        }
        
        // Set pause duration values
        const cyclePauseDurationOscEl = document.getElementById('cyclePauseDurationOsc');
        const cyclePauseMinOscEl = document.getElementById('cyclePauseMinOsc');
        const cyclePauseMaxOscEl = document.getElementById('cyclePauseMaxOsc');
        
        if (cyclePauseDurationOscEl) {
          cyclePauseDurationOscEl.value = config.cyclePauseDurationSec || 0.0;
        }
        if (cyclePauseMinOscEl) {
          cyclePauseMinOscEl.value = config.cyclePauseMinSec || 0.5;
        }
        if (cyclePauseMaxOscEl) {
          cyclePauseMaxOscEl.value = config.cyclePauseMaxSec || 3.0;
        }
        
        // Force toggle visibility (fixed/random)
        const fixedDiv = document.getElementById('pauseFixedControlsOsc');
        const randomDiv = document.getElementById('pauseRandomControlsOsc');
        if (fixedDiv && randomDiv) {
          if (pauseIsRandom) {
            fixedDiv.style.display = 'none';
            randomDiv.style.display = 'block';
          } else {
            fixedDiv.style.display = 'flex';
            randomDiv.style.display = 'none';
          }
        }
        
        // Auto-expand pause section if enabled
        if (pauseEnabled) {
          const pauseSection = document.querySelector('.section-collapsible:has(#cyclePauseOscHeaderText)');
          const pauseHeaderText = document.getElementById('cyclePauseOscHeaderText');
          if (pauseSection && pauseHeaderText) {
            if (pauseSection.classList.contains('collapsed')) {
              pauseSection.classList.remove('collapsed');
              const chevron = pauseSection.querySelector('.collapse-icon');
              if (chevron) chevron.textContent = 'â–¼';
            }
            pauseHeaderText.textContent = 'â¸ï¸ Pause entre cycles - activÃ©e';
          }
        }
        
        // Send command to backend
        sendCommand(WS_CMD.SET_OSCILLATION, {
          centerPositionMM: config.centerPositionMM || 100,
          amplitudeMM: config.amplitudeMM || 20,
          waveform: config.waveform || 0,
          frequencyHz: config.frequencyHz || 1.0,
          cycleCount: config.cycleCount || 10,
          enableRampIn: config.enableRampIn || false,
          rampInDurationMs: config.rampInDurationMs || 2000,
          enableRampOut: config.enableRampOut || false,
          rampOutDurationMs: config.rampOutDurationMs || 2000,
          returnToCenter: config.returnToCenter || false,
          // Cycle pause parameters
          cyclePauseEnabled: pauseEnabled,
          cyclePauseIsRandom: pauseIsRandom,
          cyclePauseDurationSec: config.cyclePauseDurationSec || 0.0,
          cyclePauseMinSec: config.cyclePauseMinSec || 0.5,
          cyclePauseMaxSec: config.cyclePauseMaxSec || 3.0
        });
        
        console.log('âœ… OSC preset loaded | Pause enabled:', pauseEnabled, '| Random:', pauseIsRandom);
        
      } else if (mode === 'chaos') {
        document.getElementById('chaosCenterPos').value = config.centerPositionMM || 100;
        document.getElementById('chaosAmplitude').value = config.amplitudeMM || 40;
        document.getElementById('chaosMaxSpeed').value = config.maxSpeedLevel || 15;
        document.getElementById('chaosCraziness').value = config.crazinessPercent || 50;
        document.getElementById('chaosDuration').value = config.durationSeconds || 30;
        document.getElementById('crazinessValue').textContent = config.crazinessPercent || 50;

        // Set pattern checkboxes (correct IDs)
        if (config.patternsEnabled && Array.isArray(config.patternsEnabled) && config.patternsEnabled.length >= 11) {
          document.getElementById('patternZigzag').checked = config.patternsEnabled[0];
          document.getElementById('patternSweep').checked = config.patternsEnabled[1];
          document.getElementById('patternPulse').checked = config.patternsEnabled[2];
          document.getElementById('patternDrift').checked = config.patternsEnabled[3];
          document.getElementById('patternBurst').checked = config.patternsEnabled[4];
          document.getElementById('patternWave').checked = config.patternsEnabled[5];
          document.getElementById('patternPendulum').checked = config.patternsEnabled[6];
          document.getElementById('patternSpiral').checked = config.patternsEnabled[7];
          document.getElementById('patternCalm').checked = config.patternsEnabled[8];
          document.getElementById('patternBruteForce').checked = config.patternsEnabled[9];
          document.getElementById('patternLiberator').checked = config.patternsEnabled[10];
        }
        
        // Send command to backend
        sendCommand(WS_CMD.SET_CHAOS_CONFIG, {
          centerPositionMM: config.centerPositionMM || 100,
          amplitudeMM: config.amplitudeMM || 40,
          maxSpeedLevel: config.maxSpeedLevel || 15,
          crazinessPercent: config.crazinessPercent || 50,
          durationSeconds: config.durationSeconds || 30,
          seed: 0,  // Use default seed
          patternsEnabled: config.patternsEnabled || []
        });
      }
      
      closePlaylistModal();
      showNotification('âœ… Preset chargÃ© dans le mode ' + mode, 'info', 2000);
    }
    
    function updateStartPresets(maxDist) {
      // Use cached NodeList for performance (called ~50 times/second via updateUI)
      DOM.presetStartButtons.forEach(btn => {
        const startPos = parseFloat(btn.getAttribute('data-start'));
        const isValid = startPos <= maxDist;
        btn.disabled = !isValid;
        btn.style.opacity = isValid ? '1' : '0.3';
        btn.style.cursor = isValid ? 'pointer' : 'not-allowed';
      });
    }
    
    function updateDistancePresets(maxAvailable) {
      // Use cached NodeList for performance (called ~50 times/second via updateUI)
      DOM.presetDistanceButtons.forEach(btn => {
        const distance = parseFloat(btn.getAttribute('data-distance'));
        const isValid = distance <= maxAvailable;
        btn.disabled = !isValid;
        btn.style.opacity = isValid ? '1' : '0.3';
        btn.style.cursor = isValid ? 'pointer' : 'not-allowed';
      });
    }
    
    // Note: canStartOperation, setButtonState, setupEditableInput, setupPresetButtons, sendCommand loaded from utils.js
    
    document.getElementById('btnCalibrateCommon').addEventListener('click', function() {
      sendCommand(WS_CMD.CALIBRATE);
    });
    
    // ============================================================================
    // MAX DISTANCE LIMIT CONFIGURATION
    // ============================================================================
    
    // Max Distance Limit: Helper function to update UI state
    function updateMaxDistLimitUI() {
      const isReady = AppState.system.currentState === SystemState.READY;
      const totalMM = AppState.pursuit.totalDistanceMM || 0;
      
      // Get current limit percent from AppState (or default to 100)
      const currentPercent = AppState.pursuit.maxDistLimitPercent || 100;
      
      // Only update slider value if user is NOT currently editing it
      if (!isEditingMaxDistLimit) {
        DOM.maxDistLimitSlider.value = currentPercent;
      }
      
      // Enable/disable controls based on state
      DOM.maxDistLimitSlider.disabled = !isReady;
      DOM.btnApplyMaxDistLimit.disabled = !isReady;
      
      // Show/hide warning
      DOM.maxDistLimitWarning.style.display = isReady ? 'none' : 'block';
      
      // Update slider value and display (only if not editing)
      if (!isEditingMaxDistLimit) {
        const effectiveMM = (totalMM * currentPercent / 100).toFixed(1);
        DOM.maxDistLimitValue.textContent = currentPercent + '%';
        DOM.maxDistLimitMM.textContent = '(' + effectiveMM + ' mm)';
      }
    }
    
    // Max Distance Limit: Initialize event listeners (called after initDOMCache)
    function initMaxDistLimitListeners() {
      // Toggle configuration panel
      DOM.btnConfigMaxDist.addEventListener('click', function() {
        const isVisible = DOM.maxDistConfigPanel.style.display !== 'none';
        DOM.maxDistConfigPanel.style.display = isVisible ? 'none' : 'block';
        
        if (!isVisible) {
          // Panel just opened - load current value and START blocking updates
          isEditingMaxDistLimit = true; // Block updates while panel is open
          updateMaxDistLimitUI();
        } else {
          // Panel closed - stop blocking updates
          isEditingMaxDistLimit = false;
        }
      });
      
      // Update slider display while dragging
      DOM.maxDistLimitSlider.addEventListener('input', function() {
        const percent = parseFloat(this.value);
        const totalMM = AppState.pursuit.totalDistanceMM || 0;
        const effectiveMM = (totalMM * percent / 100).toFixed(1);
        
        DOM.maxDistLimitValue.textContent = percent + '%';
        DOM.maxDistLimitMM.textContent = '(' + effectiveMM + ' mm)';
      });
      
      // Apply limit
      DOM.btnApplyMaxDistLimit.addEventListener('click', function() {
        const percent = parseFloat(DOM.maxDistLimitSlider.value);
        
        // Reset input fields to safe defaults when applying limit
        document.getElementById('startPosition').value = 0;
        document.getElementById('distance').value = 0;
        
        // Update oscillation and chaos centers with new effective max
        const totalMM = AppState.pursuit.totalDistanceMM || 0;
        const effectiveMax = totalMM * percent / 100;
        
        const oscCenterField = document.getElementById('oscCenter');
        if (oscCenterField && effectiveMax > 0) {
          oscCenterField.value = (effectiveMax / 2).toFixed(1);
          // Send to backend to update oscillation config
          sendCommand(WS_CMD.SET_OSCILLATION_CONFIG, {
            centerPositionMM: effectiveMax / 2,
            amplitudeMM: parseFloat(document.getElementById('oscAmplitude').value) || 50,
            frequencyHz: parseFloat(document.getElementById('oscFrequency').value) || 1,
            waveform: parseInt(document.getElementById('oscWaveform').value) || 0
          });
        }
        
        const chaosCenterField = document.getElementById('chaosCenterPos');
        if (chaosCenterField && effectiveMax > 0) {
          chaosCenterField.value = (effectiveMax / 2).toFixed(1);
        }
        
        sendCommand(WS_CMD.SET_MAX_DISTANCE_LIMIT, {percent: percent});
        DOM.maxDistConfigPanel.style.display = 'none';
        isEditingMaxDistLimit = false; // Allow updates after applying
      });
      
      // Cancel
      DOM.btnCancelMaxDistLimit.addEventListener('click', function() {
        DOM.maxDistConfigPanel.style.display = 'none';
        isEditingMaxDistLimit = false; // Allow updates after cancelling
      });
    }
    
    document.getElementById('btnStart').addEventListener('click', function() {
      const distance = parseFloat(document.getElementById('distance').value);
      const isSeparateMode = document.getElementById('speedModeSeparate')?.checked || false;
      
      let speedForward, speedBackward;
      if (isSeparateMode) {
        speedForward = parseFloat(document.getElementById('speedForward').value);
        speedBackward = parseFloat(document.getElementById('speedBackward').value);
      } else {
        const unifiedSpeed = parseFloat(document.getElementById('speedUnified').value);
        speedForward = unifiedSpeed;
        speedBackward = unifiedSpeed;
      }
      
      sendCommand(WS_CMD.START, {distance: distance, speed: speedForward});
      // Set backward speed separately after start
      setTimeout(() => {
        sendCommand(WS_CMD.SET_SPEED_BACKWARD, {speed: speedBackward});
      }, 100);
    });
    
    document.getElementById('btnPause').addEventListener('click', function() {
      sendCommand(WS_CMD.PAUSE);
    });
    
    document.getElementById('btnStop').addEventListener('click', function() {
      // Only show modal if motor has moved (currentStep > 0)
      if (currentPositionMM > 0.5) {
        showStopModal();
      } else {
        // Direct stop if at position 0
        sendCommand(WS_CMD.STOP);
      }
    });
    
    document.getElementById('btnResetDistanceCommon').addEventListener('click', function() {
      if (confirm('RÃ©initialiser le compteur de distance parcourue ?')) {
        sendCommand(WS_CMD.RESET_TOTAL_DISTANCE);
      }
    });
    
    // ========================================================================
    // PLAYLIST BUTTON EVENT LISTENERS
    // ========================================================================
    
    document.getElementById('btnManagePlaylistSimple').addEventListener('click', function() {
      openPlaylistModal('simple');
    });
    
    document.getElementById('btnManagePlaylistOscillation').addEventListener('click', function() {
      openPlaylistModal('oscillation');
    });
    
    document.getElementById('btnManagePlaylistChaos').addEventListener('click', function() {
      openPlaylistModal('chaos');
    });
    
    document.getElementById('btnAddCurrentToPlaylist').addEventListener('click', function() {
      const mode = document.getElementById('playlistModal').dataset.mode;
      if (mode) {
        addToPlaylist(mode);
      }
    });
    
    // Track when user starts editing an input
    // Use mousedown to catch spinner clicks BEFORE focus + force focus immediately
    document.getElementById('startPosition').addEventListener('mousedown', function() {
      AppState.editing.input = 'startPosition';
      this.focus();
    });
    document.getElementById('startPosition').addEventListener('focus', function() {
      AppState.editing.input = 'startPosition';
    });
    document.getElementById('startPosition').addEventListener('blur', function() {
      AppState.editing.input = null;
    });
    document.getElementById('startPosition').addEventListener('change', function() {
      const startPos = parseFloat(this.value);
      sendCommand(WS_CMD.SET_START_POSITION, {startPosition: startPos});
      AppState.editing.input = null;
    });
    
    document.getElementById('distance').addEventListener('mousedown', function() {
      AppState.editing.input = 'distance';
      this.focus();
    });
    document.getElementById('distance').addEventListener('focus', function() {
      AppState.editing.input = 'distance';
    });
    document.getElementById('distance').addEventListener('blur', function() {
      AppState.editing.input = null;
    });
    document.getElementById('distance').addEventListener('change', function() {
      const distance = parseFloat(this.value);
      sendCommand(WS_CMD.SET_DISTANCE, {distance: distance});
      AppState.editing.input = null;
    });
    
    // Unified speed control
    document.getElementById('speedUnified').addEventListener('mousedown', function() {
      AppState.editing.input = 'speedUnified';
      this.focus();
    });
    document.getElementById('speedUnified').addEventListener('focus', function() {
      AppState.editing.input = 'speedUnified';
    });
    document.getElementById('speedUnified').addEventListener('blur', function() {
      AppState.editing.input = null;
    });
    document.getElementById('speedUnified').addEventListener('change', function() {
      const speed = parseFloat(this.value);
      
      // Update hidden separate fields for consistency
      document.getElementById('speedForward').value = speed;
      document.getElementById('speedBackward').value = speed;
      
      // Send both commands to ESP32
      sendCommand(WS_CMD.SET_SPEED_FORWARD, {speed: speed});
      sendCommand(WS_CMD.SET_SPEED_BACKWARD, {speed: speed});
      
      AppState.editing.input = null;
    });
    
    // Separate speed controls
    document.getElementById('speedForward').addEventListener('mousedown', function() {
      AppState.editing.input = 'speedForward';
      this.focus();
    });
    document.getElementById('speedForward').addEventListener('focus', function() {
      AppState.editing.input = 'speedForward';
    });
    document.getElementById('speedForward').addEventListener('blur', function() {
      AppState.editing.input = null;
    });
    document.getElementById('speedForward').addEventListener('change', function() {
      const speed = parseFloat(this.value);
      sendCommand(WS_CMD.SET_SPEED_FORWARD, {speed: speed});
      AppState.editing.input = null;
    });
    
    document.getElementById('speedBackward').addEventListener('mousedown', function() {
      AppState.editing.input = 'speedBackward';
      this.focus();
    });
    document.getElementById('speedBackward').addEventListener('focus', function() {
      AppState.editing.input = 'speedBackward';
    });
    document.getElementById('speedBackward').addEventListener('blur', function() {
      AppState.editing.input = null;
    });
    document.getElementById('speedBackward').addEventListener('change', function() {
      const speed = parseFloat(this.value);
      sendCommand(WS_CMD.SET_SPEED_BACKWARD, {speed: speed});
      AppState.editing.input = null;
    });
    
    // Cycle Pause listeners (Simple mode)
    function sendSimpleCyclePauseConfig() {
      const enabled = document.getElementById('cyclePauseEnabled')?.checked || false;
      const isRandom = document.getElementById('cyclePauseRandom')?.checked || false;
      const durationSec = parseFloat(document.getElementById('cyclePauseDuration')?.value || 0);
      let minSec = parseFloat(document.getElementById('cyclePauseMin')?.value || 0.5);
      let maxSec = parseFloat(document.getElementById('cyclePauseMax')?.value || 3.0);
      
      // ğŸ†• VALIDATION: Min doit Ãªtre â‰¤ Max (seulement si random activÃ©)
      if (isRandom && minSec > maxSec) {
        showNotification('âš ï¸ Pause Min (' + minSec.toFixed(1) + 's) doit Ãªtre â‰¤ Max (' + maxSec.toFixed(1) + 's)', 'warning');
        // Auto-correction: ajuster Max = Min
        maxSec = minSec;
        document.getElementById('cyclePauseMax').value = maxSec;
      }
      
      sendCommand(WS_CMD.SET_CYCLE_PAUSE, {
        mode: 'simple',
        enabled: enabled,
        isRandom: isRandom,
        durationSec: durationSec,
        minSec: minSec,
        maxSec: maxSec
      });
    }
    
    if (document.getElementById('cyclePauseEnabled')) {
      document.getElementById('cyclePauseEnabled').addEventListener('change', sendSimpleCyclePauseConfig);
    }
    if (document.getElementById('cyclePauseRandom')) {
      document.getElementById('cyclePauseRandom').addEventListener('change', sendSimpleCyclePauseConfig);
    }
    if (document.getElementById('cyclePauseDuration')) {
      document.getElementById('cyclePauseDuration').addEventListener('change', sendSimpleCyclePauseConfig);
    }
    if (document.getElementById('cyclePauseMin')) {
      document.getElementById('cyclePauseMin').addEventListener('change', sendSimpleCyclePauseConfig);
    }
    if (document.getElementById('cyclePauseMax')) {
      document.getElementById('cyclePauseMax').addEventListener('change', sendSimpleCyclePauseConfig);
    }
    
    document.querySelectorAll('[data-start]').forEach(btn => {
      btn.addEventListener('click', function() {
        const startPos = parseFloat(this.getAttribute('data-start'));
        const maxStart = parseFloat(document.getElementById('startPosition').max);
        
        if (startPos <= maxStart) {
          document.getElementById('startPosition').value = startPos;
          sendCommand(WS_CMD.SET_START_POSITION, {startPosition: startPos});
          
          document.querySelectorAll('[data-start]').forEach(b => b.classList.remove('active'));
          this.classList.add('active');
        }
      });
    });
    
    document.querySelectorAll('[data-distance]').forEach(btn => {
      btn.addEventListener('click', function() {
        const distance = parseFloat(this.getAttribute('data-distance'));
        const maxDist = parseFloat(document.getElementById('distance').max);
        
        if (distance <= maxDist) {
          document.getElementById('distance').value = distance;
          sendCommand(WS_CMD.SET_DISTANCE, {distance: distance});
          
          document.querySelectorAll('[data-distance]').forEach(b => b.classList.remove('active'));
          this.classList.add('active');
        }
      });
    });
    
    // Unified speed presets
    document.querySelectorAll('[data-speed-unified]').forEach(btn => {
      btn.addEventListener('click', function() {
        const speed = parseFloat(this.getAttribute('data-speed-unified'));
        
        // Update visible unified field
        document.getElementById('speedUnified').value = speed;
        
        // Also update hidden separate fields for consistency when switching modes
        document.getElementById('speedForward').value = speed;
        document.getElementById('speedBackward').value = speed;
        
        // Send both commands to ESP32
        sendCommand(WS_CMD.SET_SPEED_FORWARD, {speed: speed});
        sendCommand(WS_CMD.SET_SPEED_BACKWARD, {speed: speed});
        
        // Update preset button highlighting
        document.querySelectorAll('[data-speed-unified]').forEach(b => b.classList.remove('active'));
        this.classList.add('active');
      });
    });
    
    // Separate speed presets
    document.querySelectorAll('[data-speed-forward]').forEach(btn => {
      btn.addEventListener('click', function() {
        const speed = parseFloat(this.getAttribute('data-speed-forward'));
        document.getElementById('speedForward').value = speed;
        sendCommand(WS_CMD.SET_SPEED_FORWARD, {speed: speed});
        
        document.querySelectorAll('[data-speed-forward]').forEach(b => b.classList.remove('active'));
        this.classList.add('active');
      });
    });
    
    document.querySelectorAll('[data-speed-backward]').forEach(btn => {
      btn.addEventListener('click', function() {
        const speed = parseFloat(this.getAttribute('data-speed-backward'));
        document.getElementById('speedBackward').value = speed;
        sendCommand(WS_CMD.SET_SPEED_BACKWARD, {speed: speed});
        
        document.querySelectorAll('[data-speed-backward]').forEach(b => b.classList.remove('active'));
        this.classList.add('active');
      });
    });
    
    // Toggle between unified and separate speed controls (RADIO BUTTONS)
    document.querySelectorAll('input[name="speedMode"]').forEach(radio => {
      radio.addEventListener('change', function() {
        const isSeparate = document.getElementById('speedModeSeparate').checked;
        const unifiedGroup = document.getElementById('speedUnifiedGroup');
        const separateGroup = document.getElementById('speedSeparateGroup');
      
      if (isSeparate) {
        // UNIFIED â†’ SEPARATE: Copy unified value to BOTH forward AND backward
        unifiedGroup.style.display = 'none';
        separateGroup.style.display = 'block';
        
        const unifiedSpeed = parseFloat(document.getElementById('speedUnified').value);
        document.getElementById('speedForward').value = unifiedSpeed;
        document.getElementById('speedBackward').value = unifiedSpeed;
        
        // Send both commands to ESP32 to ensure sync
        sendCommand(WS_CMD.SET_SPEED_FORWARD, {speed: unifiedSpeed});
        sendCommand(WS_CMD.SET_SPEED_BACKWARD, {speed: unifiedSpeed});
        
        // Update preset button highlighting
        document.querySelectorAll('[data-speed-forward]').forEach(btn => {
          if (parseFloat(btn.getAttribute('data-speed-forward')) === unifiedSpeed) {
            btn.classList.add('active');
          } else {
            btn.classList.remove('active');
          }
        });
        document.querySelectorAll('[data-speed-backward]').forEach(btn => {
          if (parseFloat(btn.getAttribute('data-speed-backward')) === unifiedSpeed) {
            btn.classList.add('active');
          } else {
            btn.classList.remove('active');
          }
        });
        
        console.log('Switched to SEPARATE mode: both speeds set to ' + unifiedSpeed);
        
      } else {
        // SEPARATE â†’ UNIFIED: Use forward speed value for both
        unifiedGroup.style.display = 'flex';
        separateGroup.style.display = 'none';
        
        const forwardSpeed = parseFloat(document.getElementById('speedForward').value);
        
        // Use forward speed as the unified value
        document.getElementById('speedUnified').value = forwardSpeed;
        
        // Also update backward to match forward
        document.getElementById('speedBackward').value = forwardSpeed;
        
        // Apply forward speed to BOTH directions immediately
        sendCommand(WS_CMD.SET_SPEED_FORWARD, {speed: forwardSpeed});
        sendCommand(WS_CMD.SET_SPEED_BACKWARD, {speed: forwardSpeed});
        
        // Update preset button highlighting
        document.querySelectorAll('[data-speed-unified]').forEach(btn => {
          if (parseFloat(btn.getAttribute('data-speed-unified')) === forwardSpeed) {
            btn.classList.add('active');
          } else {
            btn.classList.remove('active');
          }
        });
        
        console.log('Switched to UNIFIED mode: using forward speed ' + forwardSpeed + ' for both directions');
      }
      });
    });

    // ============================================================================
    // PURSUIT MODE - Interactive Gauge Control
    // ============================================================================
    
    let pursuitActive = false;
    // Pursuit mode constants and local state
    // Note: pursuitTargetMM migrated to AppState.pursuit.targetMM
    let pursuitMaxSpeedLevel = 10;
    const PURSUIT_COMMAND_INTERVAL = 20;  // Send command max every 20ms (50Hz)
    
    // Flag to prevent WebSocket updates while user is editing max distance limit
    let isEditingMaxDistLimit = false;
    
    function updateGaugePosition(positionMM) {
      if (AppState.pursuit.totalDistanceMM <= 0) return;
      
      const containerHeight = DOM.gaugeContainer.offsetHeight;
      
      // Calculate position (0mm = bottom, totalDistanceMM = top)
      const percent = positionMM / AppState.pursuit.totalDistanceMM;
      const pixelPosition = containerHeight - (percent * containerHeight);
      
      DOM.gaugePosition.style.top = pixelPosition + 'px';
      DOM.currentPositionMM.textContent = positionMM.toFixed(1);
      
      // Update error
      const error = Math.abs(AppState.pursuit.targetMM - positionMM);
      DOM.positionError.textContent = error.toFixed(1);
    }
    
    function setGaugeTarget(positionMM) {
      if (AppState.pursuit.totalDistanceMM <= 0) return;
      
      // Clamp to valid range
      if (positionMM < 0) positionMM = 0;
      if (positionMM > AppState.pursuit.totalDistanceMM) positionMM = AppState.pursuit.totalDistanceMM;
      
      AppState.pursuit.targetMM = positionMM;
      
      const containerHeight = DOM.gaugeContainer.offsetHeight;
      
      // Calculate position (0mm = bottom, totalDistanceMM = top)
      const percent = positionMM / AppState.pursuit.totalDistanceMM;
      const pixelPosition = containerHeight - (percent * containerHeight);
      
      DOM.gaugeCursor.style.top = pixelPosition + 'px';
      DOM.targetPositionMM.textContent = positionMM.toFixed(1);
      
      // Update error
      const error = Math.abs(AppState.pursuit.targetMM - AppState.pursuit.currentPositionMM);
      DOM.positionError.textContent = error.toFixed(1);
      
      // Send pursuit command if active and enough time has passed
      if (pursuitActive) {
        const now = Date.now();
        if (now - AppState.pursuit.lastCommandTime > PURSUIT_COMMAND_INTERVAL) {
          sendPursuitCommand();
          AppState.pursuit.lastCommandTime = now;
        }
      }
    }
    
    function sendPursuitCommand() {
      // Always send command - the ESP32 will handle when to stop (errorSteps == 0)
      sendCommand(WS_CMD.PURSUIT_MOVE, {
        targetPosition: AppState.pursuit.targetMM,
        maxSpeed: pursuitMaxSpeedLevel
      });
    }
    
    // Gauge mouse interaction
    document.getElementById('gaugeContainer').addEventListener('mousedown', function(e) {
      AppState.pursuit.isDragging = true;
      updateGaugeFromMouse(e);
    });
    
    document.addEventListener('mousemove', function(e) {
      if (AppState.pursuit.isDragging) {
        updateGaugeFromMouse(e);
      }
    });
    
    document.addEventListener('mouseup', function() {
      AppState.pursuit.isDragging = false;
    });
    
    function updateGaugeFromMouse(e) {
      const container = document.getElementById('gaugeContainer');
      const rect = container.getBoundingClientRect();
      const y = e.clientY - rect.top;
      const containerHeight = rect.height;
      
      // Convert y position to percentage (top = 100%, bottom = 0%)
      let percent = 1 - (y / containerHeight);
      if (percent < 0) percent = 0;
      if (percent > 1) percent = 1;
      
      // Convert to position in mm
      const positionMM = percent * AppState.pursuit.totalDistanceMM;
      setGaugeTarget(positionMM);
    }
    
    // Pursuit mode controls
    document.getElementById('pursuitActiveCheckbox').addEventListener('change', function() {
      pursuitActive = this.checked;
      
      if (pursuitActive) {
        // Check if system is calibrating
        if (AppState.system.currentState === SystemState.CALIBRATING) {
          this.checked = false;
          pursuitActive = false;
          alert('Veuillez attendre la fin de la calibration');
          return;
        }
        
        document.getElementById('btnActivatePursuit').textContent = 'â¸ Pause Poursuite';
        document.getElementById('btnActivatePursuit').classList.remove('btn-success');
        document.getElementById('btnActivatePursuit').classList.add('btn-warning');
        
        // Enable gauge interaction
        document.getElementById('gaugeContainer').style.opacity = '1';
        document.getElementById('gaugeContainer').style.cursor = 'crosshair';
        document.getElementById('gaugeContainer').style.pointerEvents = 'auto';
        
        // Use already set target position (from gauge clicks or current position)
        // Don't reset to current position - keep user's target choice
        if (AppState.pursuit.targetMM === undefined || isNaN(AppState.pursuit.targetMM)) {
          // Only initialize if never set before
          AppState.pursuit.targetMM = AppState.pursuit.currentPositionMM;
          setGaugeTarget(AppState.pursuit.currentPositionMM);
        }
        // else: Keep the target position that was set (even if 0 mm)
        
        // Enable pursuit mode on ESP32
        sendCommand(WS_CMD.ENABLE_PURSUIT_MODE, {});
        
        // Send initial position command after ESP32 mode switch completes
        setTimeout(function() {
          sendPursuitCommand();
          setTimeout(startPursuitLoop, PURSUIT_COMMAND_INTERVAL);
        }, 200);
      } else {
        document.getElementById('btnActivatePursuit').textContent = 'â–¶ DÃ©marrer';
        document.getElementById('btnActivatePursuit').classList.remove('btn-warning');
        document.getElementById('btnActivatePursuit').classList.add('btn-success');
        
        // Disable gauge interaction visually
        document.getElementById('gaugeContainer').style.opacity = '0.5';
        document.getElementById('gaugeContainer').style.cursor = 'not-allowed';
        document.getElementById('gaugeContainer').style.pointerEvents = 'none';
        
        // Disable pursuit mode on ESP32
        sendCommand(WS_CMD.DISABLE_PURSUIT_MODE, {});
        
        // NOTE: AppState.pursuit.targetMM is preserved for when user re-enables pursuit mode
      }
    });
    
    document.getElementById('btnActivatePursuit').addEventListener('click', function() {
      const checkbox = document.getElementById('pursuitActiveCheckbox');
      checkbox.checked = !checkbox.checked;
      checkbox.dispatchEvent(new Event('change'));
    });
    
    document.getElementById('pursuitMaxSpeed').addEventListener('change', function() {
      pursuitMaxSpeedLevel = parseFloat(this.value);
    });
    
    // Pursuit speed presets
    document.querySelectorAll('[data-pursuit-speed]').forEach(btn => {
      btn.addEventListener('click', function() {
        const speed = parseFloat(this.getAttribute('data-pursuit-speed'));
        document.getElementById('pursuitMaxSpeed').value = speed;
        pursuitMaxSpeedLevel = speed;
        
        document.querySelectorAll('[data-pursuit-speed]').forEach(b => b.classList.remove('active'));
        this.classList.add('active');
      });
    });
    
    // Pursuit loop - sends commands periodically
    function startPursuitLoop() {
      if (!pursuitActive) return;
      
      sendPursuitCommand();
      
      // Continue loop
      setTimeout(startPursuitLoop, PURSUIT_COMMAND_INTERVAL);
    }
    
    document.getElementById('btnStopPursuit').addEventListener('click', function() {
      // Disable pursuit mode
      document.getElementById('pursuitActiveCheckbox').checked = false;
      document.getElementById('pursuitActiveCheckbox').dispatchEvent(new Event('change'));
      
      // Return to start position to verify contact
      setTimeout(function() {
        console.log('Stopping pursuit - returning to start for contact verification');
        sendCommand(WS_CMD.RETURN_TO_START, {});
      }, 200);  // Small delay to let pursuit mode disable first
    });

    // ============================================================================
    // TAB MANAGEMENT & MODE SWITCHING
    // ============================================================================
    
    // Note: SystemState enum loaded from app.js
    // Note: Mode switching variables now in AppState.system
    // Access via: AppState.system.currentMode, AppState.system.pendingModeSwitch, etc.
    
    function switchTab(tabName) {
      // Save statistics before mode change
      sendCommand(WS_CMD.SAVE_STATS, {});
      
      // SAFETY: Stop any running movement before switching tabs
      // This prevents confusion when switching modes while paused
      const isRunningOrPaused = (AppState.system.currentState === SystemState.RUNNING || 
                                  AppState.system.currentState === SystemState.PAUSED);
      
      if (isRunningOrPaused) {
        console.log('Stopping movement before tab switch');
        sendCommand(WS_CMD.STOP);
        // Note: UI will update via WebSocket status message
      }
      
      // PRE-CHECK: If switching to sequencer with limit active, show modal and abort
      if (tabName === 'tableau') {
        const currentLimit = AppState.pursuit.maxDistLimitPercent || 100;
        
        if (currentLimit < 100) {
          const limitedCourse = AppState.pursuit.effectiveMaxDistMM || 0;
          const totalCourse = AppState.pursuit.totalDistanceMM || 0;
          
          // Update modal content with current values
          document.getElementById('seqModalCurrentLimit').textContent = 
            currentLimit.toFixed(0) + '% (' + limitedCourse.toFixed(1) + ' mm)';
          document.getElementById('seqModalAfterLimit').textContent = 
            '100% (' + totalCourse.toFixed(1) + ' mm)';
          
          // Show modal and ABORT tab switch
          document.getElementById('sequencerLimitModal').classList.add('active');
          return; // Don't switch tab yet!
        }
      }
      
      // Hide all tab contents
      document.querySelectorAll('.tab-content').forEach(content => {
        content.classList.remove('active');
      });
      
      // Remove active class from all tabs
      document.querySelectorAll('.tab').forEach(tab => {
        tab.classList.remove('active');
      });
      
      // Show selected tab content
      const tabMap = {
        'simple': 'tabSimple',
        'pursuit': 'tabPursuit',
        'oscillation': 'tabOscillation',
        'chaos': 'tabChaos',
        'tableau': 'tabTableau'
      };
      
      document.getElementById(tabMap[tabName]).classList.add('active');
      
      // Add active class to selected tab
      document.querySelector('[data-tab="' + tabName + '"]').classList.add('active');
      
      AppState.system.currentMode = tabName;
      console.log('Switched to mode: ' + tabName);
      
      // Handle mode-specific initialization
      if (tabName === 'pursuit') {
        // Switching TO pursuit mode
        setGaugeTarget(0);  // Start at 0mm
      } else if (tabName === 'simple') {
        // Switching TO simple mode - disable pursuit if active
        if (pursuitActive) {
          document.getElementById('pursuitActiveCheckbox').checked = false;
          document.getElementById('pursuitActiveCheckbox').dispatchEvent(new Event('change'));
        }
      } else if (tabName === 'oscillation') {
        // Switching TO oscillation mode - always update center with effective max
        const totalMM = AppState.pursuit.totalDistanceMM || 0;
        const effectiveMax = (AppState.pursuit.maxDistLimitPercent && AppState.pursuit.maxDistLimitPercent < 100)
          ? (totalMM * AppState.pursuit.maxDistLimitPercent / 100)
          : totalMM;
        
        const oscCenterField = document.getElementById('oscCenter');
        if (oscCenterField && effectiveMax > 0) {
          // Always set to effective center
          oscCenterField.value = (effectiveMax / 2).toFixed(1);
          // Also send to backend (use sendOscillationConfig function)
          sendOscillationConfig();
        }
        
        validateOscillationLimits();
        updateOscillationPresets();  // Update preset buttons state
      } else if (tabName === 'chaos') {
        // Switching TO chaos mode - always update center with effective max
        const totalMM = AppState.pursuit.totalDistanceMM || 0;
        const effectiveMax = (AppState.pursuit.maxDistLimitPercent && AppState.pursuit.maxDistLimitPercent < 100)
          ? (totalMM * AppState.pursuit.maxDistLimitPercent / 100)
          : totalMM;
        
        const chaosCenterField = document.getElementById('chaosCenterPos');
        if (chaosCenterField && effectiveMax > 0) {
          // Always set to effective center
          chaosCenterField.value = (effectiveMax / 2).toFixed(1);
        }
        
        validateChaosLimits();
        updateChaosPresets();  // Update preset buttons state
      }
      // Note: tableau (sequencer) pre-check is done at the start of switchTab()
    }
    
    function isSystemRunning() {
      // State 3 = RUNNING, 4 = PAUSED (for simple mode)
      // Also check if pursuit mode is active
      return AppState.system.currentState === SystemState.RUNNING || 
             AppState.system.currentState === SystemState.PAUSED || 
             pursuitActive;
    }
    
    function cancelModeChange() {
      document.getElementById('modeChangeModal').classList.remove('active');
      AppState.system.pendingModeSwitch = null;
      
      // Reset checkbox
      document.getElementById('bypassCalibrationCheckbox').checked = false;
      
      // Restore previous tab selection
      document.querySelectorAll('.tab').forEach(tab => {
        tab.classList.remove('active');
      });
      document.querySelector('[data-tab="' + AppState.system.currentMode + '"]').classList.add('active');
    }
    
    function confirmModeChange() {
      const bypassCalibration = document.getElementById('bypassCalibrationCheckbox').checked;
      document.getElementById('modeChangeModal').classList.remove('active');
      
      // If pursuit is active, disable it first
      if (pursuitActive) {
        console.log('Mode change: Disabling pursuit mode first');
        document.getElementById('pursuitActiveCheckbox').checked = false;
        document.getElementById('pursuitActiveCheckbox').dispatchEvent(new Event('change'));
      }
      
      // Stop movement (for simple mode)
      sendCommand(WS_CMD.STOP, {});
      
      // Wait a bit for stop to complete, then either quick return or full calibration
      setTimeout(function() {
        if (bypassCalibration) {
          // Quick return to start only
          console.log('Mode change: Quick return to start (bypass full calibration)');
          sendCommand(WS_CMD.RETURN_TO_START, {});
        } else {
          // Full calibration
          console.log('Mode change: Full calibration');
          sendCommand(WS_CMD.CALIBRATE, {});
        }
        
        // Reset checkbox for next time
        document.getElementById('bypassCalibrationCheckbox').checked = false;
        
        // Actually switch the tab after starting calibration/return
        if (AppState.system.pendingModeSwitch) {
          switchTab(AppState.system.pendingModeSwitch);
          AppState.system.pendingModeSwitch = null;
        }
      }, 500);
    }
    
    // ============================================================================
    // STOP CONFIRMATION MODAL FUNCTIONS
    // ============================================================================
    
    function showStopModal() {
      document.getElementById('stopModal').classList.add('active');
    }
    
    function cancelStopModal() {
      document.getElementById('stopModal').classList.remove('active');
      // Reset checkbox for next time (keep checked by default)
      document.getElementById('returnToStartCheckbox').checked = true;
    }
    
    function confirmStopModal() {
      const shouldReturnToStart = document.getElementById('returnToStartCheckbox').checked;
      document.getElementById('stopModal').classList.remove('active');
      
      // CRITICAL FIX: Detect current mode and send mode-specific stop command
      const currentMode = AppState.system.currentMode;
      
      if (currentMode === 'tableau') {  // 'tableau' is the sequencer tab name
        // SEQUENCER MODE FIX: Send stopSequence command
        console.log('Stop confirmed (Sequencer mode): Stopping sequence');
        sendCommand(WS_CMD.STOP_SEQUENCE, {});
        
        // Return to start if requested (same as other modes)
        if (shouldReturnToStart) {
          setTimeout(function() {
            console.log('Stop confirmed: Returning to start position');
            sendCommand(WS_CMD.RETURN_TO_START, {});
          }, 500);
        }
      } else if (currentMode === 'chaos') {
        // Chaos mode: send stopChaos command
        console.log('Stop confirmed (Chaos mode): Stopping chaos movement');
        sendCommand(WS_CMD.STOP_CHAOS, {});
        
        // Return to start if requested
        if (shouldReturnToStart) {
          setTimeout(function() {
            console.log('Stop confirmed: Returning to start position');
            sendCommand(WS_CMD.RETURN_TO_START, {});
          }, 500);
        }
      } else if (currentMode === 'oscillation') {
        // Oscillation mode: send stopOscillation command
        console.log('Stop confirmed (Oscillation mode): Stopping oscillation');
        sendCommand(WS_CMD.STOP_OSCILLATION, {});
        
        // Return to start if requested
        if (shouldReturnToStart) {
          setTimeout(function() {
            console.log('Stop confirmed: Returning to start position');
            sendCommand(WS_CMD.RETURN_TO_START, {});
          }, 500);
        }
      } else {
        // Simple mode or others: send generic stop
        console.log('Stop confirmed: Stopping movement');
        sendCommand(WS_CMD.STOP, {});
        
        // Return to start if requested
        if (shouldReturnToStart) {
          setTimeout(function() {
            console.log('Stop confirmed: Returning to start position');
            sendCommand(WS_CMD.RETURN_TO_START, {});
          }, 500);
        }
      }
      
      if (!shouldReturnToStart) {
        console.log('Stop confirmed: Staying at current position');
      }
      
      // Reset checkbox for next time (keep checked by default)
      document.getElementById('returnToStartCheckbox').checked = true;
    }
    
    // Sequencer Limit Modal Functions
    function cancelSequencerLimitChange() {
      document.getElementById('sequencerLimitModal').classList.remove('active');
      
      // Return to previous tab
      const prevTab = AppState.system.currentMode || 'simple';
      setTimeout(function() {
        // Restore previous tab selection
        document.querySelectorAll('.tab').forEach(tab => {
          tab.classList.remove('active');
        });
        document.querySelector('[data-tab="' + prevTab + '"]').classList.add('active');
        
        // Restore previous tab content
        document.querySelectorAll('.mode-content').forEach(content => {
          content.classList.remove('active');
        });
        document.getElementById(prevTab + '-content').classList.add('active');
      }, 10);
    }
    
    function confirmSequencerLimitChange() {
      document.getElementById('sequencerLimitModal').classList.remove('active');
      
      // Reset limit to 100%
      sendCommand(WS_CMD.SET_MAX_DISTANCE_LIMIT, { limitPercent: 100 });
      
      // Show confirmation notification
      setTimeout(function() {
        showNotification('âœ… Limite rÃ©initialisÃ©e Ã  100% (mode sÃ©quenceur)', 3000);
      }, 100);
      
      // Now actually switch to sequencer tab
      // We need to temporarily bypass the check by setting limit to 100 in AppState
      AppState.pursuit.maxDistLimitPercent = 100;
      switchTab('tableau');
    }
    
    // Tab click handlers
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', function() {
        const targetMode = this.getAttribute('data-tab');
        
        // Don't do anything if clicking on already active tab
        if (targetMode === AppState.system.currentMode) {
          return;
        }
        
        // Check if system is running
        if (isSystemRunning()) {
          // Update modal message based on current mode
          const modalMessage = document.getElementById('modalMessage');
          if (pursuitActive) {
            modalMessage.innerHTML = 
              'Le mode poursuite est actuellement actif. Le changement de mode va :<br>' +
              'â€¢ DÃ©sactiver le mode poursuite<br>' +
              'â€¢ Retourner au point de dÃ©part pour vÃ©rifier le contact<br>' +
              'â€¢ Lancer une calibration si nÃ©cessaire<br><br>' +
              '<strong>Voulez-vous continuer ?</strong>';
          } else {
            modalMessage.innerHTML = 
              'Une opÃ©ration est en cours. Le changement de mode va arrÃªter le mouvement et lancer une recalibration.<br><br>' +
              '<strong>Voulez-vous continuer ?</strong>';
          }
          
          // Show confirmation modal
          AppState.system.pendingModeSwitch = targetMode;
          document.getElementById('modeChangeModal').classList.add('active');
        } else {
          // Safe to switch immediately
          switchTab(targetMode);
        }
      });
    });
    
    // Force initial state on page load (prevent browser cache issues)
    window.addEventListener('load', function() {
      // Initialize DOM cache FIRST (performance optimization)
      initDOMCache();
      
      // Initialize speed limits based on maxSpeedLevel constant
      initSpeedLimits();
      
      // Initialize max distance limit event listeners
      initMaxDistLimitListeners();
      
      // Ensure pursuit checkbox is unchecked on fresh load
      DOM.pursuitActiveCheckbox.checked = false;
      pursuitActive = false;
      
      // Reset button text
      DOM.btnActivatePursuit.textContent = 'â–¶ DÃ©marrer';
      DOM.btnActivatePursuit.classList.remove('btn-warning');
      DOM.btnActivatePursuit.classList.add('btn-success');
      
      // Disable gauge interaction on page load (pursuit mode inactive)
      if (DOM.gaugeContainer) {
        DOM.gaugeContainer.style.opacity = '0.5';
        DOM.gaugeContainer.style.cursor = 'not-allowed';
        DOM.gaugeContainer.style.pointerEvents = 'none';
      }
      
      // Request sequence table on load (wait for WebSocket connection)
      function requestSequenceTableWhenReady() {
        if (AppState.ws && AppState.ws.readyState === WebSocket.OPEN) {
          sendCommand(WS_CMD.GET_SEQUENCE_TABLE, {});
        } else {
          setTimeout(requestSequenceTableWhenReady, 200);
        }
      }
      requestSequenceTableWhenReady();
    });
    
    // ============================================================================
    // MODE SÃ©quenceur - Event Listeners
    // ============================================================================
    
    document.getElementById('btnAddLine').addEventListener('click', addSequenceLine);
    document.getElementById('btnClearAll').addEventListener('click', clearSequence);
    document.getElementById('btnImportSeq').addEventListener('click', importSequence);
    document.getElementById('btnExportSeq').addEventListener('click', exportSequence);
    document.getElementById('btnDownloadTemplate').addEventListener('click', downloadTemplate);
    
    // Phase 2: Keyboard shortcuts for multi-select
    document.addEventListener('keydown', function(e) {
      // Only handle when on sequencer tab
      if (AppState.system.currentMode !== 'tableau') return;
      
      // Escape: Clear selection
      if (e.key === 'Escape' && selectedLineIds.size > 0) {
        clearSelection();
        e.preventDefault();
      }
      
      // Ctrl+A: Select all
      if ((e.ctrlKey || e.metaKey) && e.key === 'a' && sequenceLines.length > 0) {
        selectedLineIds.clear();
        sequenceLines.forEach(line => selectedLineIds.add(line.lineId));
        lastSelectedIndex = 0;
        updateBatchToolbar();
        renderSequenceTable({ lines: sequenceLines });
        e.preventDefault();
      }
      
      // Delete: Delete selected lines
      if (e.key === 'Delete' && selectedLineIds.size > 0) {
        batchDeleteLines();
        e.preventDefault();
      }
    });
    
    // ============================================================================
    // LOGS PANEL MANAGEMENT
    // ============================================================================
    
    document.getElementById('btnShowLogs').addEventListener('click', function() {
      const panel = document.getElementById('logsPanel');
      if (panel.style.display === 'none') {
        panel.style.display = 'block';
        this.innerHTML = 'ğŸ“‹ Logs';
        this.style.background = '#e74c3c';
        this.style.color = 'white';
        // Load log files list
        loadLogFilesList();
        // Load current debug level state
        fetch('/api/system/logging/preferences')
          .then(response => response.json())
          .then(data => {
            const chkDebug = document.getElementById('debugLevelCheckbox');
            if (chkDebug) {
              chkDebug.checked = (data.logLevel === 3); // DEBUG = 3
            }
          })
          .catch(error => {
            console.error('âŒ Error loading log level:', error);
          });
      } else {
        panel.style.display = 'none';
        this.innerHTML = 'ğŸ“‹ Logs';
        this.style.background = '#17a2b8';
        this.style.color = 'white';
      }
    });

    document.getElementById('btnCloseLogs').addEventListener('click', function() {
      document.getElementById('logsPanel').style.display = 'none';
      document.getElementById('btnShowLogs').innerHTML = 'ğŸ“‹ Logs';
      document.getElementById('btnShowLogs').style.background = '#17a2b8';
      document.getElementById('btnShowLogs').style.color = 'white';
    });

    document.getElementById('btnClearLogsPanel').addEventListener('click', function() {
      const logEl = document.getElementById('logConsolePanel');
      if (logEl) logEl.textContent = '(logs effacÃ©s)';
    });

    document.getElementById('debugLevelCheckbox').addEventListener('change', function() {
      // Save debug level preference to EEPROM via API
      const preferences = {
        loggingEnabled: true,  // Keep logging enabled
        logLevel: this.checked ? 3 : 2  // 3=DEBUG, 2=INFO
      };
      
      fetch('/api/system/logging/preferences', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(preferences)
      })
        .then(response => response.json())
        .then(data => {
          console.log('ğŸ’¾ Log level saved:', this.checked ? 'DEBUG' : 'INFO');
          
          // Also update the checkbox in Sys panel
          const chkDebug = document.getElementById('chkDebugLevel');
          if (chkDebug) {
            chkDebug.checked = this.checked;
          }
        })
        .catch(error => {
          console.error('âŒ Error saving log level:', error);
        });
    });

    document.getElementById('btnClearAllLogFiles').addEventListener('click', function() {
      if (confirm('Supprimer TOUS les fichiers de logs?\n\nCette action est irrÃ©versible.')) {
        fetch('/logs/clear', { method: 'POST' })
          .then(response => response.json())
          .then(data => {
            alert(data.message || 'Logs supprimÃ©s avec succÃ¨s!');
            loadLogFilesList();  // Refresh list
          })
          .catch(error => {
            console.error('Erreur suppression logs:', error);
            alert('Erreur: ' + error);
          });
      }
    });

    function loadLogFilesList() {
      fetch('/logs')
        .then(response => response.text())
        .then(html => {
          // Parse HTML to extract file links
          const parser = new DOMParser();
          const doc = parser.parseFromString(html, 'text/html');
          const links = doc.querySelectorAll('a');
          
          if (links.length === 0) {
            DOM.logFilesList.innerHTML = '<div style="color: #999; font-style: italic; font-size: 11px;">Aucun fichier de log</div>';
            return;
          }
          
          // Create container with DOM methods (XSS safe)
          const container = document.createElement('div');
          container.style.cssText = 'display: flex; flex-direction: column; gap: 5px;';
          
          links.forEach(link => {
            const filename = link.textContent;
            const url = link.href;
            
            // Create item div
            const itemDiv = document.createElement('div');
            itemDiv.style.cssText = 'display: flex; justify-content: space-between; align-items: center; padding: 6px; background: #f9f9f9; border-radius: 4px; border: 1px solid #ddd;';
            
            // Create filename span (safe from XSS with textContent)
            const filenameSpan = document.createElement('span');
            filenameSpan.style.cssText = 'font-family: monospace; font-size: 12px;';
            filenameSpan.textContent = filename;  // Safe: uses textContent instead of innerHTML
            
            // Create download link
            const downloadLink = document.createElement('a');
            downloadLink.href = url;
            downloadLink.target = '_blank';
            downloadLink.style.cssText = 'background: #2196F3; color: white; padding: 4px 10px; border-radius: 3px; text-decoration: none; font-size: 11px;';
            downloadLink.textContent = 'ğŸ“¥ TÃ©lÃ©charger';
            
            itemDiv.appendChild(filenameSpan);
            itemDiv.appendChild(downloadLink);
            container.appendChild(itemDiv);
          });
          
          DOM.logFilesList.innerHTML = '';  // Clear first
          DOM.logFilesList.appendChild(container);
        })
        .catch(error => {
          DOM.logFilesList.innerHTML = '<div style="color: #f44336; font-size: 11px;">Erreur de chargement</div>';
        });
    }
    
    // ============================================================================
    // STATISTICS PANEL MANAGEMENT
    // ============================================================================
    
    let statsChart = null;  // Chart.js instance
    
    // Day icons mapping (Monday = 0, Sunday = 6)
    const dayIcons = ['ğŸŒ™', 'ğŸ”¥', 'ğŸ’§', 'âš¡', 'ğŸŒŸ', 'â˜€ï¸', 'ğŸŒˆ'];
    const dayNames = ['Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi', 'Dimanche'];
    
    // Note: getISOWeek() loaded from utils.js
    
    document.getElementById('btnShowStats').addEventListener('click', function() {
      const panel = document.getElementById('statsPanel');
      const wasVisible = (panel.style.display !== 'none');
      
      if (!wasVisible) {
        // Opening panel
        panel.style.display = 'block';
        this.innerHTML = 'ğŸ“Š Stats';
        this.style.background = '#e74c3c';
        this.style.color = 'white';
        
        // Update state and signal backend
        AppState.statsPanel.isVisible = true;
        AppState.statsPanel.lastToggle = Date.now();
        
        // Send WebSocket command to backend (enable stats sending)
        if (AppState.ws && AppState.ws.readyState === WebSocket.OPEN) {
          AppState.ws.send(JSON.stringify({
            cmd: 'requestStats',
            enable: true
          }));
          console.log('ğŸ“Š Stats requested from backend');
        }
        
        // Load stats data
        loadStatsData();
      } else {
        // Closing panel
        panel.style.display = 'none';
        this.innerHTML = 'ğŸ“Š Stats';
        this.style.background = '#4CAF50';
        this.style.color = 'white';
        
        // Update state and signal backend
        AppState.statsPanel.isVisible = false;
        AppState.statsPanel.lastToggle = Date.now();
        
        // Send WebSocket command to backend (disable stats sending)
        if (AppState.ws && AppState.ws.readyState === WebSocket.OPEN) {
          AppState.ws.send(JSON.stringify({
            cmd: 'requestStats',
            enable: false
          }));
          console.log('ğŸ“Š Stats no longer needed');
        }
      }
    });

    document.getElementById('btnCloseStats').addEventListener('click', function() {
      document.getElementById('statsPanel').style.display = 'none';
      document.getElementById('btnShowStats').innerHTML = 'ğŸ“Š Stats';
      document.getElementById('btnShowStats').style.background = '#4CAF50';
      document.getElementById('btnShowStats').style.color = 'white';
      
      // Update state and signal backend
      AppState.statsPanel.isVisible = false;
      AppState.statsPanel.lastToggle = Date.now();
      
      // Send WebSocket command to backend (disable stats sending)
      if (AppState.ws && AppState.ws.readyState === WebSocket.OPEN) {
        AppState.ws.send(JSON.stringify({
          cmd: 'requestStats',
          enable: false
        }));
        console.log('ğŸ“Š Stats panel closed');
      }
    });

    document.getElementById('btnShowSystem').addEventListener('click', function() {
      const panel = document.getElementById('systemPanel');
      if (panel.style.display === 'none') {
        panel.style.display = 'block';
        this.innerHTML = 'âš™ï¸ Sys';
        this.style.background = '#e74c3c';
        this.style.color = 'white';
        
        // Enable system stats in backend (same as Stats panel)
        if (AppState.ws && AppState.ws.readyState === WebSocket.OPEN) {
          AppState.ws.send(JSON.stringify({
            cmd: 'requestStats',
            enable: true
          }));
          console.log('ğŸ“Š System stats requested from backend');
        }
        
        // Request system status to populate fields
        sendCommand(WS_CMD.GET_STATUS, {});
        
        // Load logging preferences when opening
        loadLoggingPreferences();
      } else {
        panel.style.display = 'none';
        this.innerHTML = 'âš™ï¸ Sys';
        this.style.background = '#2196F3';
        this.style.color = 'white';
        
        // Disable system stats when closing (optional optimization)
        if (AppState.ws && AppState.ws.readyState === WebSocket.OPEN) {
          AppState.ws.send(JSON.stringify({
            cmd: 'requestStats',
            enable: false
          }));
        }
      }
    });

    document.getElementById('btnCloseSystem').addEventListener('click', function() {
      document.getElementById('systemPanel').style.display = 'none';
      document.getElementById('btnShowSystem').innerHTML = 'âš™ï¸ Sys';
      document.getElementById('btnShowSystem').style.background = '#2196F3';
      document.getElementById('btnShowSystem').style.color = 'white';
    });

    document.getElementById('btnRefreshWifi').addEventListener('click', function() {
      if (confirm('ğŸ“¶ Reconnecter le WiFi?\n\nCela peut interrompre briÃ¨vement la connexion (~2-3 secondes).\n\nVoulez-vous continuer?')) {
        const btn = this;
        const originalText = btn.innerHTML;
        
        // Disable button and show loading
        btn.disabled = true;
        btn.innerHTML = 'â³';
        btn.style.opacity = '0.5';
        
        console.log('ğŸ“¶ Sending WiFi reconnect command...');
        
        // Send reconnect command (expect network error as WiFi disconnects)
        fetch('/api/system/wifi/reconnect', { method: 'POST' })
          .then(response => response.json())
          .then(data => {
            console.log('ğŸ“¶ WiFi reconnect command sent:', data);
          })
          .catch(error => {
            // Expected error: network will be interrupted during WiFi reconnect
            console.log('ğŸ“¶ WiFi reconnect in progress (network interruption expected)');
          });
        
        // Wait for WiFi to reconnect (3 seconds)
        setTimeout(function() {
          btn.disabled = false;
          btn.innerHTML = 'âœ…';
          btn.style.opacity = '1';
          
          // Reset button after 2 seconds
          setTimeout(function() {
            btn.innerHTML = originalText;
          }, 2000);
        }, 3000);
      }
    });

    document.getElementById('btnReboot').addEventListener('click', function() {
      if (confirm('âš ï¸ RedÃ©marrer l\'ESP32?\n\nLa connexion sera interrompue pendant ~10-15 secondes.\n\nVoulez-vous continuer?')) {
        // Show reboot overlay
        document.getElementById('rebootOverlay').style.display = 'flex';
        
        // Send reboot command
        fetch('/api/system/reboot', { method: 'POST' })
          .then(response => response.json())
          .then(data => {
            console.log('ğŸ”„ Reboot command sent:', data);
          })
          .catch(error => {
            console.log('ğŸ”„ Reboot initiated (connection lost as expected)');
          });
        
        // Close WebSocket properly
        if (AppState.ws && AppState.ws.readyState === WebSocket.OPEN) {
          AppState.ws.close();
        }
        
        // Wait 10 seconds then try to reconnect
        setTimeout(function() {
          reconnectAfterReboot();
        }, 10000);
      }
    });

    function reconnectAfterReboot() {
      let attempts = 0;
      const maxAttempts = 30; // Try for 30 seconds
      let httpConnected = false;
      let wsConnected = false;
      
      const updateRebootStatus = function(message, subMessage) {
        const msgEl = document.getElementById('rebootMessage');
        const statusEl = document.getElementById('rebootStatus');
        if (msgEl) msgEl.textContent = message;
        if (statusEl) statusEl.textContent = subMessage || '';
      };
      
      const tryReconnect = function() {
        attempts++;
        console.log('ğŸ”„ Reconnection attempt ' + attempts + '/' + maxAttempts);
        updateRebootStatus('Tentative de reconnexion...', 'Essai ' + attempts + '/' + maxAttempts);
        
        // Test HTTP connection first using ping endpoint
        fetch('/api/ping', { 
          method: 'GET',
          cache: 'no-cache'
        })
          .then(response => {
            if (!response.ok) throw new Error('HTTP not ready');
            return response.json();
          })
          .then(data => {
            console.log('âœ… HTTP connection restored! Uptime:', data.uptime, 'ms');
            httpConnected = true;
            updateRebootStatus('HTTP OK - Reconnexion WebSocket...', 'ğŸŒ Connexion en cours...');
            
            // Now try WebSocket connection
            if (!wsConnected) {
              console.log('ğŸ”Œ Attempting WebSocket reconnection...');
              
              // Try to reconnect WebSocket
              try {
                connectWebSocket();
                
                // Wait a bit to see if WebSocket connects
                setTimeout(function() {
                  if (AppState.ws && AppState.ws.readyState === WebSocket.OPEN) {
                    wsConnected = true;
                    console.log('âœ… WebSocket reconnected!');
                    updateRebootStatus('Connexion rÃ©tablie !', 'âœ… Rechargement de la page...');
                    
                    // Both HTTP and WS are connected - wait 2 more seconds for stability
                    console.log('â³ Waiting for system stability...');
                    setTimeout(function() {
                      console.log('âœ… System stable - reloading page...');
                      document.getElementById('rebootOverlay').style.display = 'none';
                      location.reload(true); // Force reload from server
                    }, 2000);
                  } else {
                    // WebSocket not ready yet, keep trying
                    console.log('âš ï¸ WebSocket not ready, retrying...');
                    if (attempts < maxAttempts) {
                      setTimeout(tryReconnect, 1000);
                    } else {
                      document.getElementById('rebootOverlay').style.display = 'none';
                      alert('âŒ HTTP OK mais WebSocket ne rÃ©pond pas.\n\nRecherger la page manuellement (F5).');
                    }
                  }
                }, 1500);
                
              } catch (err) {
                console.error('âŒ WebSocket connection error:', err);
                if (attempts < maxAttempts) {
                  setTimeout(tryReconnect, 1000);
                } else {
                  document.getElementById('rebootOverlay').style.display = 'none';
                  alert('âŒ Impossible de reconnecter le WebSocket.\n\nVeuillez recharger la page manuellement (F5).');
                }
              }
            }
          })
          .catch(error => {
            console.log('âš ï¸ ESP32 not ready yet:', error.message);
            if (attempts < maxAttempts) {
              setTimeout(tryReconnect, 1000);
            } else {
              document.getElementById('rebootOverlay').style.display = 'none';
              alert('âŒ Impossible de se reconnecter Ã  l\'ESP32.\n\nVeuillez recharger la page manuellement (F5).');
            }
          });
      };
      
      tryReconnect();
    }

    // ========================================================================
    // LOGGING PREFERENCES - EEPROM
    // ========================================================================
    
    // Load logging preferences from ESP32
    function loadLoggingPreferences() {
      fetch('/api/system/logging/preferences')
        .then(response => response.json())
        .then(data => {
          // Set checkboxes
          const chkEnabled = document.getElementById('chkLoggingEnabled');
          const chkDebug = document.getElementById('chkDebugLevel');
          const btnShowLogs = document.getElementById('btnShowLogs');
          
          chkEnabled.checked = data.loggingEnabled;
          chkDebug.checked = (data.logLevel === 3); // LOG_DEBUG = 3
          
          // Update AppState.logging for console wrapper FIRST
          AppState.logging.enabled = data.loggingEnabled;
          AppState.logging.debugEnabled = (data.logLevel === 3);
          
          // Hide/show Logs button based on logging enabled state
          if (!data.loggingEnabled) {
            btnShowLogs.style.display = 'none';
          } else {
            btnShowLogs.style.display = '';
          }
          
          // Debug log (only if enabled)
          if (data.loggingEnabled) {
            console.log('ğŸ“‚ Loaded logging preferences:', data);
          }
        })
        .catch(error => {
          console.error('âŒ Error loading logging preferences:', error);
        });
    }
    
    // Save logging preferences to ESP32 EEPROM
    function saveLoggingPreferences() {
      const chkEnabled = document.getElementById('chkLoggingEnabled');
      const chkDebug = document.getElementById('chkDebugLevel');
      
      const preferences = {
        loggingEnabled: chkEnabled.checked,
        logLevel: chkDebug.checked ? 3 : 2  // 3=DEBUG, 2=INFO
      };
      
      // Update AppState.logging for console wrapper
      AppState.logging.enabled = preferences.loggingEnabled;
      AppState.logging.debugEnabled = (preferences.logLevel === 3);
      
      fetch('/api/system/logging/preferences', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(preferences)
      })
        .then(response => response.json())
        .then(data => {
          console.log('ğŸ’¾ Logging preferences saved:', data);
          
          // Update Logs button visibility
          const btnShowLogs = document.getElementById('btnShowLogs');
          if (!preferences.loggingEnabled) {
            btnShowLogs.style.display = 'none';
          } else {
            btnShowLogs.style.display = '';
          }
        })
        .catch(error => {
          console.error('âŒ Error saving logging preferences:', error);
          alert('âŒ Erreur lors de la sauvegarde des prÃ©fÃ©rences de log');
        });
    }
    
    // Attach event handlers for checkboxes
    document.getElementById('chkLoggingEnabled').addEventListener('change', function() {
      saveLoggingPreferences();
      
      // Disable DEBUG checkbox if logging is disabled
      const chkDebug = document.getElementById('chkDebugLevel');
      chkDebug.disabled = !this.checked;
      
      if (!this.checked) {
        console.log('ğŸ”‡ Logging disabled - all logs (console + files) stopped');
      } else {
        console.log('ğŸ”Š Logging enabled');
      }
    });
    
    document.getElementById('chkDebugLevel').addEventListener('change', function() {
      saveLoggingPreferences();
      
      if (this.checked) {
        console.log('ğŸ“Š Log level: DEBUG (verbose mode)');
      } else {
        console.log('ğŸ“Š Log level: INFO (normal mode)');
      }
    });
    
    // Load preferences on startup
    loadLoggingPreferences();

    document.getElementById('btnClearStats').addEventListener('click', function() {
      if (confirm('âš ï¸ Supprimer TOUTES les statistiques?\n\nCette action est irrÃ©versible et ne supprime PAS le compteur de distance (RAZ).')) {
        fetch('/api/stats/clear', { method: 'POST' })
          .then(response => response.json())
          .then(data => {
            if (data.success) {
              alert('âœ… Statistiques effacÃ©es');
              loadStatsData();  // Refresh display
            } else {
              alert('âŒ Erreur: ' + (data.error || 'Unknown'));
            }
          })
          .catch(error => {
            alert('âŒ Erreur rÃ©seau: ' + error);
          });
      }
    });

    // Export Stats Button
    document.getElementById('btnExportStats').addEventListener('click', function() {
      fetch('/api/stats/export')
        .then(response => {
          if (!response.ok) throw new Error('Export failed');
          return response.json();
        })
        .then(data => {
          // Create JSON file and download
          const jsonStr = JSON.stringify(data, null, 2);
          const blob = new Blob([jsonStr], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          
          // Generate filename with current date
          const now = new Date();
          const dateStr = now.toISOString().split('T')[0]; // YYYY-MM-DD
          const filename = `stepper_stats_${dateStr}.json`;
          
          // Trigger download
          const a = document.createElement('a');
          a.href = url;
          a.download = filename;
          a.click();
          
          URL.revokeObjectURL(url);
          console.log(`âœ… Stats exported: ${filename}`);
        })
        .catch(error => {
          alert('âŒ Erreur export: ' + error.message);
          console.error('Export error:', error);
        });
    });

    // Import Stats Button
    document.getElementById('btnImportStats').addEventListener('click', function() {
      document.getElementById('statsFileInput').click();
    });

    // File input handler
    document.getElementById('statsFileInput').addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;
      
      if (!file.name.endsWith('.json')) {
        alert('âŒ Fichier invalide. Utilisez un fichier JSON exportÃ©.');
        return;
      }
      
      const reader = new FileReader();
      reader.onload = function(event) {
        try {
          const importData = JSON.parse(event.target.result);
          
          // Validate structure
          if (!importData.stats || !Array.isArray(importData.stats)) {
            throw new Error('Format JSON invalide (manque "stats" array)');
          }
          
          // Confirm import (show preview)
          const entryCount = importData.stats.length;
          const exportDate = importData.exportDate || 'inconnu';
          const totalKm = importData.totalDistanceMM ? (importData.totalDistanceMM / 1000000).toFixed(3) : '?';
          
          const confirmMsg = `ğŸ“¤ Importer les statistiques?\n\n` +
                           `ğŸ“… Date export: ${exportDate}\n` +
                           `ğŸ“Š EntrÃ©es: ${entryCount}\n` +
                           `ğŸ“ Distance totale: ${totalKm} km\n\n` +
                           `âš ï¸ Ceci va Ã‰CRASER les statistiques actuelles!`;
          
          if (!confirm(confirmMsg)) {
            e.target.value = ''; // Reset file input
            return;
          }
          
          // Send to backend
          fetch('/api/stats/import', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(importData)
          })
          .then(response => response.json())
          .then(data => {
            if (data.success) {
              alert(`âœ… Import rÃ©ussi!\n\nğŸ“Š ${data.entriesImported} entrÃ©es importÃ©es\nğŸ“ Total: ${(data.totalDistanceMM / 1000000).toFixed(3)} km`);
              loadStatsData();  // Refresh display
            } else {
              alert('âŒ Erreur import: ' + (data.error || 'Unknown'));
            }
            e.target.value = ''; // Reset file input
          })
          .catch(error => {
            alert('âŒ Erreur rÃ©seau: ' + error.message);
            console.error('Import error:', error);
            e.target.value = ''; // Reset file input
          });
          
        } catch (error) {
          alert('âŒ Erreur parsing JSON: ' + error.message);
          console.error('JSON parse error:', error);
          e.target.value = ''; // Reset file input
        }
      };
      
      reader.readAsText(file);
    });

    function loadStatsData() {
      fetch('/api/stats')
        .then(response => response.json())
        .then(data => {
          displayStatsTable(data);
          displayStatsChart(data);
        })
        .catch(error => {
          console.error('Error loading stats:', error);
          document.getElementById('statsTableBody').innerHTML = 
            '<tr><td colspan="3" style="padding: 20px; text-align: center; color: #f44336;">âŒ Erreur de chargement</td></tr>';
        });
    }

    function displayStatsTable(stats) {
      const tbody = document.getElementById('statsTableBody');
      const totalEl = document.getElementById('statsTotalDistance');
      
      if (!stats || stats.length === 0) {
        tbody.innerHTML = '<tr><td colspan="4" style="padding: 20px; text-align: center; color: #999; font-style: italic;">Aucune statistique disponible</td></tr>';
        totalEl.textContent = '0 km';
        return;
      }
      
      // Sort by date (newest first)
      stats.sort((a, b) => new Date(b.date) - new Date(a.date));
      
      let totalMM = 0;
      tbody.innerHTML = '';
      
      stats.forEach(entry => {
        const distanceMM = entry.distanceMM || 0;
        totalMM += distanceMM;
        
        const date = new Date(entry.date);
        const dayOfWeek = date.getDay();  // 0=Sunday, 1=Monday, ...
        const dayIndex = dayOfWeek === 0 ? 6 : dayOfWeek - 1;  // Convert to Monday=0
        const dayIcon = dayIcons[dayIndex];
        
        const distanceKM = (distanceMM / 1000000).toFixed(3);
        const distanceM = (distanceMM / 1000).toFixed(1);
        const displayDistance = distanceMM >= 1000000 ? `${distanceKM} km` : `${distanceM} m`;
        
        // Get milestone icon for this day's distance
        const distanceMeters = distanceMM / 1000;
        const milestoneInfo = getMilestoneInfo(distanceMeters);
        const milestoneIcon = milestoneInfo.current ? milestoneInfo.current.emoji : 'ğŸ';
        const milestoneName = milestoneInfo.current ? milestoneInfo.current.name : 'DÃ©marrage';
        
        // Build tooltip with milestone info (like main display)
        let milestoneTooltip = milestoneInfo.current 
          ? `${milestoneInfo.current.emoji} ${milestoneInfo.current.name} (${milestoneInfo.current.threshold}m)` 
          : 'ğŸ DÃ©marrage';
        if (milestoneInfo.current && milestoneInfo.current.location !== "-") {
          milestoneTooltip += ` - ${milestoneInfo.current.location}`;
        }
        
        const row = document.createElement('tr');
        row.style.borderBottom = '1px solid #f0f0f0';
        row.innerHTML = `
          <td style="padding: 8px;">${entry.date}</td>
          <td style="padding: 8px; text-align: center; font-size: 12px;">${dayNames[dayIndex]}</td>
          <td style="padding: 8px; text-align: center; font-size: 18px; cursor: help;" title="${milestoneTooltip}">${milestoneIcon}</td>
          <td style="padding: 8px; text-align: right; font-family: monospace;">${displayDistance}</td>
        `;
        tbody.appendChild(row);
      });
      
      // Update total
      const totalKM = (totalMM / 1000000).toFixed(3);
      const totalM = (totalMM / 1000).toFixed(1);
      const displayTotal = totalMM >= 1000000 ? `${totalKM} km` : `${totalM} m`;
      
      // Update total milestone icon with progress
      const totalMilestoneEl = document.getElementById('statsTotalMilestone');
      if (totalMilestoneEl && totalMM > 0) {
        const totalMeters = totalMM / 1000;
        const totalMilestoneInfo = getMilestoneInfo(totalMeters);
        const totalMilestoneIcon = totalMilestoneInfo.current ? totalMilestoneInfo.current.emoji : 'ğŸ';
        const totalMilestoneName = totalMilestoneInfo.current ? totalMilestoneInfo.current.name : 'DÃ©marrage';
        
        // Build tooltip with progress to next milestone
        let totalTooltip = `${totalMilestoneIcon} ${totalMilestoneName} (${totalMilestoneInfo.current.threshold}m)`;
        if (totalMilestoneInfo.current.location !== "-") {
          totalTooltip += ` - ${totalMilestoneInfo.current.location}`;
        }
        
        if (totalMilestoneInfo.next) {
          totalTooltip += `\n\nâ­ï¸ Prochain: ${totalMilestoneInfo.next.emoji} ${totalMilestoneInfo.next.name} (${totalMilestoneInfo.next.threshold}m)`;
          totalTooltip += `\nğŸ“Š Progression: ${totalMilestoneInfo.progressPercent}%`;
        } else {
          totalTooltip += '\n\nğŸ† Objectif final atteint!';
        }
        
        totalMilestoneEl.textContent = totalMilestoneIcon;
        totalMilestoneEl.setAttribute('title', totalTooltip);
        totalMilestoneEl.style.cursor = 'help';
      }
      
      // Add progress percentage to total distance display
      const totalMilestoneInfo = getMilestoneInfo(totalMM / 1000);
      if (totalMilestoneInfo.next) {
        totalEl.textContent = `${displayTotal} (${totalMilestoneInfo.progressPercent}%)`;
      } else {
        totalEl.textContent = displayTotal;
      }
    }

    function displayStatsChart(stats) {
      if (!stats || stats.length === 0) {
        if (statsChart) {
          statsChart.destroy();
          statsChart = null;
        }
        return;
      }
      
      // Filter last 90 days (3 months sliding window)
      const today = new Date();
      const threeMonthsAgo = new Date(today);
      threeMonthsAgo.setDate(today.getDate() - 90);
      
      const filteredStats = stats.filter(entry => {
        const entryDate = new Date(entry.date);
        return entryDate >= threeMonthsAgo;
      });
      
      // Sort by date (oldest first for chart)
      filteredStats.sort((a, b) => new Date(a.date) - new Date(b.date));
      
      // âœ¨ AgrÃ©gation par semaine (1 barre = 1 semaine)
      const weeklyData = {};  // Key: "2025-W43" (ISO week number)
      
      filteredStats.forEach(entry => {
        const date = new Date(entry.date);
        
        // Calculer numÃ©ro de semaine ISO 8601
        const weekNumber = getISOWeek(date);
        const year = date.getFullYear();
        const weekKey = `${year}-W${String(weekNumber).padStart(2, '0')}`;
        
        // Initialiser si nÃ©cessaire
        if (!weeklyData[weekKey]) {
          weeklyData[weekKey] = {
            totalMM: 0,
            startDate: null,
            endDate: null,
            days: []
          };
        }
        
        // Accumuler distance
        weeklyData[weekKey].totalMM += entry.distanceMM;
        weeklyData[weekKey].days.push(entry.date);
        
        // Tracker dates min/max de la semaine
        if (!weeklyData[weekKey].startDate || date < weeklyData[weekKey].startDate) {
          weeklyData[weekKey].startDate = date;
        }
        if (!weeklyData[weekKey].endDate || date > weeklyData[weekKey].endDate) {
          weeklyData[weekKey].endDate = date;
        }
      });
      
      // â­ Find milestone for each week's distance (not cumulative)
      const sortedWeeks = Object.keys(weeklyData).sort();
      
      sortedWeeks.forEach(weekKey => {
        const week = weeklyData[weekKey];
        const weekMeters = week.totalMM / 1000;  // mm to meters (distance of this week only)
        
        // Find the milestone corresponding to this week's distance
        week.currentMilestone = null;
        for (let i = MILESTONES.length - 1; i >= 0; i--) {
          if (weekMeters >= MILESTONES[i].threshold) {
            week.currentMilestone = MILESTONES[i];
            break;
          }
        }
      });
      
      // PrÃ©parer donnÃ©es pour Chart.js
      const labels = sortedWeeks.map(weekKey => {
        const week = weeklyData[weekKey];
        // Label: "21-27 Oct" (format compact)
        const start = week.startDate.getDate();
        const end = week.endDate.getDate();
        const month = week.startDate.toLocaleDateString('fr-FR', { month: 'short' });
        return `${start}-${end} ${month}`;
      });
      
      const distances = sortedWeeks.map(weekKey => {
        const totalMM = weeklyData[weekKey].totalMM;
        return (totalMM / 1000).toFixed(1);  // mm â†’ m
      });
      
      const ctx = document.getElementById('statsChart').getContext('2d');
      
      if (statsChart) {
        statsChart.destroy();
      }
      
      statsChart = new Chart(ctx, {
        type: 'bar',
        data: {
          labels: labels,
          datasets: [{
            label: 'Distance hebdomadaire (m)',
            data: distances,
            backgroundColor: 'rgba(76, 175, 80, 0.6)',
            borderColor: 'rgba(76, 175, 80, 1)',
            borderWidth: 1
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: true,
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              callbacks: {
                title: function(context) {
                  const weekKey = sortedWeeks[context[0].dataIndex];
                  const week = weeklyData[weekKey];
                  return `Semaine ${weekKey.split('-')[1]} (${labels[context[0].dataIndex]})`;
                },
                label: function(context) {
                  const value = parseFloat(context.parsed.y);
                  return value >= 1000 ? `${(value / 1000).toFixed(2)} km` : `${value.toFixed(1)} m`;
                },
                afterLabel: function(context) {
                  const weekKey = sortedWeeks[context.dataIndex];
                  const week = weeklyData[weekKey];
                  if (!week) return '';
                  
                  const lines = [`${week.days.length} jour(s) actif(s)`];
                  
                  // â­ Show current milestone based on cumulative distance
                  if (week.currentMilestone) {
                    lines.push(''); // Empty line for spacing
                    lines.push(`${week.currentMilestone.emoji} ${week.currentMilestone.name}`);
                  }
                  
                  return lines;
                }
              }
            }
          },
          scales: {
            y: {
              beginAtZero: true,
              title: {
                display: true,
                text: 'Distance (m)'
              }
            },
            x: {
              title: {
                display: true,
                text: 'Semaines (90 derniers jours)'
              },
              ticks: {
                maxRotation: 45,
                minRotation: 45
              }
            }
          }
        }
      });
    }
    
    document.getElementById('btnStartSequence').addEventListener('click', function() {
      // Disable both start buttons immediately (instant feedback)
      setButtonState(DOM.btnStartSequence, false);
      setButtonState(DOM.btnLoopSequence, false);
      sendCommand(WS_CMD.START_SEQUENCE, {});
    });
    
    document.getElementById('btnLoopSequence').addEventListener('click', function() {
      // Disable both start buttons immediately (instant feedback)
      setButtonState(DOM.btnStartSequence, false);
      setButtonState(DOM.btnLoopSequence, false);
      sendCommand(WS_CMD.LOOP_SEQUENCE, {});
    });
    
    document.getElementById('btnPauseSequence').addEventListener('click', function() {
      sendCommand(WS_CMD.TOGGLE_SEQUENCE_PAUSE, {});
    });
    
    document.getElementById('btnStopSequence').addEventListener('click', function() {
      // Only show modal if motor has moved (currentStep > 0)
      if (currentPositionMM > 0.5) {
        showStopModal();
      } else {
        // Direct stop if at position 0
        sendCommand(WS_CMD.STOP_SEQUENCE, {});
      }
    });
    
    // ============================================================================
    // ============================================================================
    // MODE OSCILLATION - Event Listeners
    // ============================================================================
    
    // Toggle help section
    function toggleOscHelp() {
      const helpSection = document.getElementById('oscHelpSection');
      helpSection.style.display = helpSection.style.display === 'none' ? 'block' : 'none';
    }
    
    function toggleChaosHelp() {
      const helpSection = document.getElementById('chaosHelpSection');
      helpSection.style.display = helpSection.style.display === 'none' ? 'block' : 'none';
    }
    
    // Debounce timer for validation
    let validationDebounceTimer = null;
    
    // Update limit validation on input change (with debouncing)
    function validateOscillationLimits() {
      const center = parseFloat(DOM.oscCenter.value) || 0;
      const amplitude = parseFloat(DOM.oscAmplitude.value) || 0;
      const minPos = center - amplitude;
      const maxPos = center + amplitude;
      
      const minLimit = 0;
      const maxLimit = AppState.pursuit.totalDistanceMM || 0;
      
      const warning = document.getElementById('oscLimitWarning');
      const statusSpan = document.getElementById('oscLimitStatus');
      const btnStart = DOM.btnStartOscillation;
      
      // If not calibrated yet (check both canStart and totalDistanceMM), show waiting message
      if (!AppState.system.canStart || !AppState.pursuit.totalDistanceMM || AppState.pursuit.totalDistanceMM === 0) {
        warning.style.display = 'none';
        statusSpan.textContent = 'â³ En attente calibration';
        statusSpan.style.color = '#ff9800';
        btnStart.disabled = true;
        btnStart.style.opacity = '0.5';
        btnStart.style.cursor = 'not-allowed';
        return false;
      }
      
      if (minPos < minLimit || maxPos > maxLimit) {
        warning.style.display = 'block';
        statusSpan.textContent = 'âŒ Invalide';
        statusSpan.style.color = '#e74c3c';
        btnStart.disabled = true;
        btnStart.style.opacity = '0.5';
        btnStart.style.cursor = 'not-allowed';
        return false;
      } else {
        warning.style.display = 'none';
        statusSpan.textContent = 'âœ… Valide';
        statusSpan.style.color = '#27ae60';
        btnStart.disabled = false;
        btnStart.style.opacity = '1';
        btnStart.style.cursor = 'pointer';
        updateOscillationPresets();  // Update preset buttons state
        return true;
      }
    }
    
    // Helper function to send oscillation config in real-time
    function sendOscillationConfig() {
      const amplitude = parseFloat(document.getElementById('oscAmplitude').value) || 0;
      const frequency = parseFloat(document.getElementById('oscFrequency').value) || 0.5;
      
      // ğŸš€ SAFETY: Check if frequency would exceed speed limit
      const MAX_SPEED_MM_S = maxSpeedLevel * 20.0; // 300 mm/s by default
      const theoreticalSpeed = 2 * Math.PI * frequency * amplitude;
      
      if (amplitude > 0 && theoreticalSpeed > MAX_SPEED_MM_S) {
        // Calculate max allowed frequency for this amplitude
        const maxAllowedFreq = MAX_SPEED_MM_S / (2.0 * Math.PI * amplitude);
        
        // Show notification
        showNotification(
          `âš ï¸ FrÃ©quence limitÃ©e: ${frequency.toFixed(2)} Hz â†’ ${maxAllowedFreq.toFixed(2)} Hz (vitesse max: ${MAX_SPEED_MM_S.toFixed(0)} mm/s)`,
          'error',
          4000
        );
        
        // Don't modify the input field - backend will handle limiting
        // User sees their requested value, but backend uses effective frequency
      }
      
      const config = {
        centerPositionMM: parseFloat(document.getElementById('oscCenter').value) || 0,
        amplitudeMM: amplitude,
        waveform: parseInt(document.getElementById('oscWaveform').value) || 0,
        frequencyHz: frequency,
        enableRampIn: document.getElementById('oscRampInEnable').checked,
        rampInDurationMs: parseFloat(document.getElementById('oscRampInDuration').value) || 2000,
        enableRampOut: document.getElementById('oscRampOutEnable').checked,
        rampOutDurationMs: parseFloat(document.getElementById('oscRampOutDuration').value) || 2000,
        cycleCount: parseInt(document.getElementById('oscCycleCount').value) || 0,
        returnToCenter: document.getElementById('oscReturnCenter').checked
      };
      sendCommand(WS_CMD.SET_OSCILLATION, config);
    }
    
    // Oscillation input editing protection + real-time update
    // Use mousedown to catch spinner clicks BEFORE focus + force focus immediately
    document.getElementById('oscCenter').addEventListener('mousedown', function() {
      AppState.editing.oscField = 'oscCenter';
      this.focus();
    });
    document.getElementById('oscCenter').addEventListener('focus', function() {
      AppState.editing.oscField = 'oscCenter';
    });
    document.getElementById('oscCenter').addEventListener('blur', function() {
      AppState.editing.oscField = null;
      validateOscillationLimits();
      sendOscillationConfig();  // Send on blur
    });
    document.getElementById('oscCenter').addEventListener('input', function() {
      // Debounce validation on input (300ms)
      clearTimeout(validationDebounceTimer);
      validationDebounceTimer = setTimeout(validateOscillationLimits, 300);
    });
    
    document.getElementById('oscAmplitude').addEventListener('mousedown', function() {
      AppState.editing.oscField = 'oscAmplitude';
      this.focus();
    });
    document.getElementById('oscAmplitude').addEventListener('focus', function() {
      AppState.editing.oscField = 'oscAmplitude';
    });
    document.getElementById('oscAmplitude').addEventListener('blur', function() {
      AppState.editing.oscField = null;
      validateOscillationLimits();
      sendOscillationConfig();  // Send on blur
    });
    document.getElementById('oscAmplitude').addEventListener('input', function() {
      // Debounce validation on input (300ms)
      clearTimeout(validationDebounceTimer);
      validationDebounceTimer = setTimeout(validateOscillationLimits, 300);
    });
    
    document.getElementById('oscWaveform').addEventListener('mousedown', function() {
      AppState.editing.oscField = 'oscWaveform';
      this.focus();
    });
    document.getElementById('oscWaveform').addEventListener('focus', function() {
      AppState.editing.oscField = 'oscWaveform';
    });
    document.getElementById('oscWaveform').addEventListener('change', function() {
      AppState.editing.oscField = null;
      sendOscillationConfig();  // Send immediately on change
    });
    
    document.getElementById('oscFrequency').addEventListener('mousedown', function() {
      AppState.editing.oscField = 'oscFrequency';
      this.focus();
    });
    document.getElementById('oscFrequency').addEventListener('focus', function() {
      AppState.editing.oscField = 'oscFrequency';
    });
    document.getElementById('oscFrequency').addEventListener('blur', function() {
      AppState.editing.oscField = null;
      validateOscillationLimits();  // Validate on blur
      sendOscillationConfig();  // Send on blur
    });
    document.getElementById('oscFrequency').addEventListener('input', function() {
      // Debounce validation on input (300ms)
      clearTimeout(validationDebounceTimer);
      validationDebounceTimer = setTimeout(() => {
        validateOscillationLimits();
        updateOscillationPresets(); // Update presets to gray out invalid ones
      }, 300);
    });
    
    document.getElementById('oscRampInDuration').addEventListener('mousedown', function() {
      AppState.editing.oscField = 'oscRampInDuration';
      this.focus();
    });
    document.getElementById('oscRampInDuration').addEventListener('focus', function() {
      AppState.editing.oscField = 'oscRampInDuration';
    });
    document.getElementById('oscRampInDuration').addEventListener('blur', function() {
      AppState.editing.oscField = null;
      sendOscillationConfig();  // Send on blur
    });
    
    document.getElementById('oscRampOutDuration').addEventListener('mousedown', function() {
      AppState.editing.oscField = 'oscRampOutDuration';
      this.focus();
    });
    document.getElementById('oscRampOutDuration').addEventListener('focus', function() {
      AppState.editing.oscField = 'oscRampOutDuration';
    });
    document.getElementById('oscRampOutDuration').addEventListener('blur', function() {
      AppState.editing.oscField = null;
      sendOscillationConfig();  // Send on blur
    });
    
    document.getElementById('oscCycleCount').addEventListener('mousedown', function() {
      AppState.editing.oscField = 'oscCycleCount';
      this.focus();
    });
    document.getElementById('oscCycleCount').addEventListener('focus', function() {
      AppState.editing.oscField = 'oscCycleCount';
    });
    document.getElementById('oscCycleCount').addEventListener('blur', function() {
      AppState.editing.oscField = null;
      sendOscillationConfig();  // Send on blur
    });
    
    // Toggle ramp config visibility + send config (compact mode: always visible)
    document.getElementById('oscRampInEnable').addEventListener('change', function() {
      // document.getElementById('oscRampInConfig').style.display = this.checked ? 'block' : 'none'; // Removed in compact mode
      sendOscillationConfig();  // Send on change
    });
    
    document.getElementById('oscRampOutEnable').addEventListener('change', function() {
      // document.getElementById('oscRampOutConfig').style.display = this.checked ? 'block' : 'none'; // Removed in compact mode
      sendOscillationConfig();  // Send on change
    });
    
    document.getElementById('oscReturnCenter').addEventListener('change', function() {
      sendOscillationConfig();  // Send on change
    });
    
    // Cycle Pause listeners (Oscillation mode)
    function sendOscCyclePauseConfig() {
      const enabled = document.getElementById('oscCyclePauseEnabled')?.checked || false;
      const isRandom = document.getElementById('oscCyclePauseRandom')?.checked || false;
      const durationSec = parseFloat(document.getElementById('oscCyclePauseDuration')?.value || 0);
      let minSec = parseFloat(document.getElementById('oscCyclePauseMin')?.value || 0.5);
      let maxSec = parseFloat(document.getElementById('oscCyclePauseMax')?.value || 3.0);
      
      // ğŸ†• VALIDATION: Min doit Ãªtre â‰¤ Max (seulement si random activÃ©)
      if (isRandom && minSec > maxSec) {
        showNotification('âš ï¸ Pause Min (' + minSec.toFixed(1) + 's) doit Ãªtre â‰¤ Max (' + maxSec.toFixed(1) + 's)', 'warning');
        // Auto-correction: ajuster Max = Min
        maxSec = minSec;
        document.getElementById('oscCyclePauseMax').value = maxSec;
      }
      
      sendCommand(WS_CMD.SET_CYCLE_PAUSE, {
        mode: 'oscillation',
        enabled: enabled,
        isRandom: isRandom,
        durationSec: durationSec,
        minSec: minSec,
        maxSec: maxSec
      });
    }
    
    if (document.getElementById('oscCyclePauseEnabled')) {
      document.getElementById('oscCyclePauseEnabled').addEventListener('change', sendOscCyclePauseConfig);
    }
    if (document.getElementById('oscCyclePauseRandom')) {
      document.getElementById('oscCyclePauseRandom').addEventListener('change', sendOscCyclePauseConfig);
    }
    if (document.getElementById('oscCyclePauseDuration')) {
      document.getElementById('oscCyclePauseDuration').addEventListener('change', sendOscCyclePauseConfig);
    }
    if (document.getElementById('oscCyclePauseMin')) {
      document.getElementById('oscCyclePauseMin').addEventListener('change', sendOscCyclePauseConfig);
    }
    if (document.getElementById('oscCyclePauseMax')) {
      document.getElementById('oscCyclePauseMax').addEventListener('change', sendOscCyclePauseConfig);
    }
    
    // Start oscillation
    document.getElementById('btnStartOscillation').addEventListener('click', function() {
      if (!validateOscillationLimits()) {
        showNotification('Limites invalides: ajustez le centre ou l\'amplitude', 'error');
        return;
      }
      
      // Send final config + start (config already sent in real-time, but ensure it's current)
      sendOscillationConfig();
      
      // Wait a bit then start
      setTimeout(function() {
        sendCommand(WS_CMD.START_OSCILLATION, {});
      }, 50);
    });
    
    // Stop oscillation
    document.getElementById('btnStopOscillation').addEventListener('click', function() {
      // Only show modal if motor has moved (currentStep > 0)
      if (currentPositionMM > 0.5) {
        showStopModal();
      } else {
        // Direct stop if at position 0
        sendCommand(WS_CMD.STOP_OSCILLATION, {});
      }
    });
    
    // Pause oscillation
    document.getElementById('btnPauseOscillation').addEventListener('click', function() {
      sendCommand(WS_CMD.PAUSE);
    });
    
    // Oscillation preset buttons handlers
    document.querySelectorAll('[data-osc-center]').forEach(btn => {
      btn.addEventListener('click', function() {
        if (!this.disabled) {
          document.getElementById('oscCenter').value = this.getAttribute('data-osc-center');
          sendOscillationConfig();
          validateOscillationLimits();
          updateOscillationPresets();
        }
      });
    });
    
    document.querySelectorAll('[data-osc-amplitude]').forEach(btn => {
      btn.addEventListener('click', function() {
        if (!this.disabled) {
          const newAmplitude = this.getAttribute('data-osc-amplitude');
          console.log('ğŸ¯ Preset amplitude clicked: ' + newAmplitude + 'mm');
          document.getElementById('oscAmplitude').value = newAmplitude;
          console.log('ğŸ“¤ Sending oscillation config with amplitude=' + newAmplitude);
          sendOscillationConfig();
          validateOscillationLimits();
          updateOscillationPresets();
        }
      });
    });
    
    document.querySelectorAll('[data-osc-frequency]').forEach(btn => {
      btn.addEventListener('click', function() {
        if (!this.disabled) {
          document.getElementById('oscFrequency').value = this.getAttribute('data-osc-frequency');
          sendOscillationConfig();
        }
      });
    });
    
    // Function to update visual state of oscillation preset buttons
    function updateOscillationPresets() {
      const effectiveMax = AppState.pursuit.effectiveMaxDistMM || AppState.pursuit.totalDistanceMM || 0;
      if (effectiveMax === 0) return;
      
      const currentCenter = parseFloat(document.getElementById('oscCenter').value) || 0;
      const currentAmplitude = parseFloat(document.getElementById('oscAmplitude').value) || 0;
      
      // ğŸš€ MAX_SPEED_LEVEL constant (must match backend)
      const MAX_SPEED_MM_S = maxSpeedLevel * 20.0; // 300 mm/s by default
      
      // Validate center presets (must allow current amplitude)
      document.querySelectorAll('[data-osc-center]').forEach(btn => {
        const centerValue = parseFloat(btn.getAttribute('data-osc-center'));
        const minPos = centerValue - currentAmplitude;
        const maxPos = centerValue + currentAmplitude;
        const isValid = minPos >= 0 && maxPos <= effectiveMax;
        
        btn.disabled = !isValid;
        btn.style.opacity = isValid ? '1' : '0.3';
        btn.style.cursor = isValid ? 'pointer' : 'not-allowed';
      });
      
      // Validate amplitude presets (must respect current center)
      document.querySelectorAll('[data-osc-amplitude]').forEach(btn => {
        const amplitudeValue = parseFloat(btn.getAttribute('data-osc-amplitude'));
        const minPos = currentCenter - amplitudeValue;
        const maxPos = currentCenter + amplitudeValue;
        const isValid = minPos >= 0 && maxPos <= effectiveMax;
        
        btn.disabled = !isValid;
        btn.style.opacity = isValid ? '1' : '0.3';
        btn.style.cursor = isValid ? 'pointer' : 'not-allowed';
      });
      
      // ğŸš€ Validate frequency presets (must not exceed speed limit)
      document.querySelectorAll('[data-osc-frequency]').forEach(btn => {
        const frequencyValue = parseFloat(btn.getAttribute('data-osc-frequency'));
        
        // Calculate theoretical speed for this frequency
        if (currentAmplitude > 0) {
          const theoreticalSpeed = 2 * Math.PI * frequencyValue * currentAmplitude;
          const isValid = theoreticalSpeed <= MAX_SPEED_MM_S;
          
          btn.disabled = !isValid;
          btn.style.opacity = isValid ? '1' : '0.3';
          btn.style.cursor = isValid ? 'pointer' : 'not-allowed';
          btn.title = isValid 
            ? `${frequencyValue} Hz (${theoreticalSpeed.toFixed(0)} mm/s)` 
            : `âš ï¸ ${frequencyValue} Hz dÃ©passerait ${MAX_SPEED_MM_S} mm/s (${theoreticalSpeed.toFixed(0)} mm/s calculÃ©)`;
        }
      });
    }
    
    // ============================================================================
    // CHAOS MODE HANDLERS
    // ============================================================================
    
    // Send chaos configuration
    // Send chaos configuration
    function sendChaosConfig() {
      const centerPos = parseFloat(document.getElementById('chaosCenterPos').value);
      const amplitude = parseFloat(document.getElementById('chaosAmplitude').value);
      const maxSpeed = parseFloat(document.getElementById('chaosMaxSpeed').value);
      const craziness = parseFloat(document.getElementById('chaosCraziness').value);
      const duration = parseInt(document.getElementById('chaosDuration').value);
      const seed = parseInt(document.getElementById('chaosSeed').value);
      
      // Collect pattern selections
      const patternsEnabled = [
        document.getElementById('patternZigzag').checked,
        document.getElementById('patternSweep').checked,
        document.getElementById('patternPulse').checked,
        document.getElementById('patternDrift').checked,
        document.getElementById('patternBurst').checked,
        document.getElementById('patternWave').checked,
        document.getElementById('patternPendulum').checked,
        document.getElementById('patternSpiral').checked,
        document.getElementById('patternCalm').checked,
        document.getElementById('patternBruteForce').checked,
        document.getElementById('patternLiberator').checked
      ];
      
      sendCommand(WS_CMD.SET_CHAOS_CONFIG, {
        centerPositionMM: centerPos,
        amplitudeMM: amplitude,
        maxSpeedLevel: maxSpeed,
        crazinessPercent: craziness,
        durationSeconds: duration,
        seed: seed,
        patternsEnabled: patternsEnabled
      });
    }
    
    // Validate chaos limits
    function validateChaosLimits() {
      const centerPos = parseFloat(document.getElementById('chaosCenterPos').value);
      const amplitude = parseFloat(document.getElementById('chaosAmplitude').value);
      
      if (centerPos - amplitude < 0 || centerPos + amplitude > AppState.pursuit.totalDistanceMM) {
        return false;
      }
      return true;
    }
    
    // Function to update visual state of chaos preset buttons
    function updateChaosPresets() {
      const effectiveMax = AppState.pursuit.effectiveMaxDistMM || AppState.pursuit.totalDistanceMM || 0;
      if (effectiveMax === 0) return;
      
      const currentCenter = parseFloat(document.getElementById('chaosCenterPos').value) || 0;
      const currentAmplitude = parseFloat(document.getElementById('chaosAmplitude').value) || 0;
      
      // Validate center presets (must allow current amplitude)
      document.querySelectorAll('[data-chaos-center]').forEach(btn => {
        const centerValue = parseFloat(btn.getAttribute('data-chaos-center'));
        const minPos = centerValue - currentAmplitude;
        const maxPos = centerValue + currentAmplitude;
        const isValid = minPos >= 0 && maxPos <= effectiveMax;
        
        btn.disabled = !isValid;
        btn.style.opacity = isValid ? '1' : '0.3';
        btn.style.cursor = isValid ? 'pointer' : 'not-allowed';
      });
      
      // Validate amplitude presets (must respect current center)
      document.querySelectorAll('[data-chaos-amplitude]').forEach(btn => {
        const amplitudeValue = parseFloat(btn.getAttribute('data-chaos-amplitude'));
        const minPos = currentCenter - amplitudeValue;
        const maxPos = currentCenter + amplitudeValue;
        const isValid = minPos >= 0 && maxPos <= effectiveMax;
        
        btn.disabled = !isValid;
        btn.style.opacity = isValid ? '1' : '0.3';
        btn.style.cursor = isValid ? 'pointer' : 'not-allowed';
      });
    }
    
    // Function to update pattern toggle button text (Tout/Aucun)
    function updatePatternToggleButton() {
      const patterns = [
        'patternZigzag', 'patternSweep', 'patternPulse', 'patternDrift',
        'patternBurst', 'patternWave', 'patternPendulum', 'patternSpiral',
        'patternCalm', 'patternBruteForce', 'patternLiberator'
      ];
      
      const checkedCount = patterns.filter(id => document.getElementById(id).checked).length;
      const btn = document.getElementById('btnEnableAllPatterns');
      
      if (checkedCount === patterns.length) {
        // All checked â†’ show "Aucun" (next action will uncheck all)
        btn.textContent = 'âŒ Aucun';
      } else {
        // Some or none checked â†’ show "Tout" (next action will check all)
        btn.textContent = 'âœ… Tout';
      }
    }
    
    // Update chaos UI with live data
    function updateChaosUI(data) {
      if (!data.chaosState) return;
      
      const isRunning = data.chaosState.isRunning;
      const wasRunning = DOM.chaosStats.style.display === 'block';  // Track previous state
      const isCalibrating = data.state === SystemState.CALIBRATING;
      
      // Show/hide stats panel
      DOM.chaosStats.style.display = isRunning ? 'block' : 'none';
      
      // CRITICAL FIX: Reset patterns flag when chaos stops
      // This allows patterns to be re-synced from backend after each run
      if (wasRunning && !isRunning) {
        console.log('ğŸ”„ Chaos stopped - resetting patterns flag for next sync');
        AppState.flags.patternsInitialized = false;
      }
      
      // Update button states (disable if not calibrated or calibrating)
      const canStart = canStartOperation() && !isRunning;
      setButtonState(DOM.btnStartChaos, canStart);
      DOM.btnStopChaos.disabled = !isRunning;
      
      // Allow live config changes while running (except seed)
      // Config inputs remain enabled for real-time adjustments
      document.getElementById('chaosCenterPos').disabled = false;
      document.getElementById('chaosAmplitude').disabled = false;
      document.getElementById('chaosMaxSpeed').disabled = false;
      document.getElementById('chaosCraziness').disabled = false;
      document.getElementById('chaosDuration').disabled = false;
      document.getElementById('chaosSeed').disabled = isRunning;  // Only disable seed while running
      
      // Enable/disable pattern checkboxes and preset buttons based on running state
      // Checkboxes: ALWAYS disabled while running, ALWAYS enabled when stopped
      document.getElementById('patternZigzag').disabled = isRunning || isCalibrating;
      document.getElementById('patternSweep').disabled = isRunning || isCalibrating;
      document.getElementById('patternPulse').disabled = isRunning || isCalibrating;
      document.getElementById('patternDrift').disabled = isRunning || isCalibrating;
      document.getElementById('patternBurst').disabled = isRunning || isCalibrating;
      document.getElementById('patternWave').disabled = isRunning || isCalibrating;
      document.getElementById('patternPendulum').disabled = isRunning || isCalibrating;
      document.getElementById('patternSpiral').disabled = isRunning || isCalibrating;
      document.getElementById('btnEnableAllPatterns').disabled = isRunning || isCalibrating;
      document.getElementById('btnEnableSoftPatterns').disabled = isRunning || isCalibrating;
      document.getElementById('btnEnableDynamicPatterns').disabled = isRunning || isCalibrating;
      
      // Restore pattern states from backend ONLY on first load (not on every status update)
      // This prevents user's checkbox changes from being overwritten during runtime config changes
      if (!AppState.flags.patternsInitialized && !isRunning && data.chaos && data.chaos.patternsEnabled) {
        document.getElementById('patternZigzag').checked = data.chaos.patternsEnabled[0];
        document.getElementById('patternSweep').checked = data.chaos.patternsEnabled[1];
        document.getElementById('patternPulse').checked = data.chaos.patternsEnabled[2];
        document.getElementById('patternDrift').checked = data.chaos.patternsEnabled[3];
        document.getElementById('patternBurst').checked = data.chaos.patternsEnabled[4];
        document.getElementById('patternWave').checked = data.chaos.patternsEnabled[5];
        document.getElementById('patternPendulum').checked = data.chaos.patternsEnabled[6];
        document.getElementById('patternSpiral').checked = data.chaos.patternsEnabled[7];
        AppState.flags.patternsInitialized = true;  // Mark as initialized
      }
      
      if (isRunning) {
        // Update stats
        document.getElementById('statPattern').textContent = data.chaosState.patternName;
        document.getElementById('statPosition').textContent = data.positionMM.toFixed(2) + ' mm';
        
        const range = data.chaosState.maxReachedMM - data.chaosState.minReachedMM;
        document.getElementById('statRange').textContent = 
          data.chaosState.minReachedMM.toFixed(1) + ' - ' + 
          data.chaosState.maxReachedMM.toFixed(1) + ' mm (' + 
          range.toFixed(1) + ' mm)';
        
        document.getElementById('statCount').textContent = data.chaosState.patternsExecuted;
        
        // Update timer
        if (data.chaos.durationSeconds > 0 && data.chaosState.elapsedSeconds !== undefined) {
          document.getElementById('statTimer').style.display = 'block';
          document.getElementById('statElapsed').textContent = 
            data.chaosState.elapsedSeconds + ' / ' + data.chaos.durationSeconds;
        } else if (data.chaosState.elapsedSeconds !== undefined) {
          document.getElementById('statTimer').style.display = 'block';
          document.getElementById('statElapsed').textContent = data.chaosState.elapsedSeconds;
        } else {
          document.getElementById('statTimer').style.display = 'none';
        }
      }
      
      // Update preset buttons visual state
      updateChaosPresets();
    }
    
    // Start chaos
    document.getElementById('btnStartChaos').addEventListener('click', function() {
      if (!validateChaosLimits()) {
        showNotification('Limites invalides: la zone chaos dÃ©passe les limites calibrÃ©es', 'error');
        return;
      }
      
      const centerPos = parseFloat(document.getElementById('chaosCenterPos').value);
      const amplitude = parseFloat(document.getElementById('chaosAmplitude').value);
      const maxSpeed = parseFloat(document.getElementById('chaosMaxSpeed').value);
      const craziness = parseFloat(document.getElementById('chaosCraziness').value);
      const duration = parseInt(document.getElementById('chaosDuration').value);
      const seed = parseInt(document.getElementById('chaosSeed').value);
      
      // Collect pattern selections (11 patterns: ZIGZAG, SWEEP, PULSE, DRIFT, BURST, WAVE, PENDULUM, SPIRAL, BREATHING, BRUTE_FORCE, LIBERATOR)
      const patternsEnabled = [
        document.getElementById('patternZigzag').checked,
        document.getElementById('patternSweep').checked,
        document.getElementById('patternPulse').checked,
        document.getElementById('patternDrift').checked,
        document.getElementById('patternBurst').checked,
        document.getElementById('patternWave').checked,
        document.getElementById('patternPendulum').checked,
        document.getElementById('patternSpiral').checked,
        document.getElementById('patternCalm').checked,
        document.getElementById('patternBruteForce').checked,
        document.getElementById('patternLiberator').checked
      ];
      
      // Validate at least one pattern selected
      if (!patternsEnabled.some(p => p)) {
        showNotification('âš ï¸ Au moins un pattern doit Ãªtre activÃ©', 'error');
        return;
      }
      
      sendCommand(WS_CMD.START_CHAOS, {
        centerPositionMM: centerPos,
        amplitudeMM: amplitude,
        maxSpeedLevel: maxSpeed,
        crazinessPercent: craziness,
        durationSeconds: duration,
        seed: seed,
        patternsEnabled: patternsEnabled
      });
    });
    
    // Stop chaos
    document.getElementById('btnStopChaos').addEventListener('click', function() {
      // Only show modal if motor has moved (currentStep > 0)
      if (currentPositionMM > 0.5) {
        showStopModal();
      } else {
        // Direct stop if at position 0
        sendCommand(WS_CMD.STOP_CHAOS, {});
      }
    });
    
    // Pause chaos
    document.getElementById('btnPauseChaos').addEventListener('click', function() {
      sendCommand(WS_CMD.PAUSE);
    });
    
    // Chaos preset buttons
    document.querySelectorAll('[data-chaos-center]').forEach(btn => {
      btn.addEventListener('click', function() {
        if (!this.disabled) {
          document.getElementById('chaosCenterPos').value = this.dataset.chaosCenter;
          sendChaosConfig();  // Send on preset click
          updateChaosPresets();  // Update visual state
        }
      });
    });
    
    document.querySelectorAll('[data-chaos-amplitude]').forEach(btn => {
      btn.addEventListener('click', function() {
        if (!this.disabled) {
          document.getElementById('chaosAmplitude').value = this.dataset.chaosAmplitude;
          sendChaosConfig();  // Send on preset click
          updateChaosPresets();  // Update visual state
        }
      });
    });
    
    document.querySelectorAll('[data-chaos-speed]').forEach(btn => {
      btn.addEventListener('click', function() {
        document.getElementById('chaosMaxSpeed').value = this.dataset.chaosSpeed;
        sendChaosConfig();  // Send on preset click
      });
    });
    
    document.querySelectorAll('[data-chaos-duration]').forEach(btn => {
      btn.addEventListener('click', function() {
        document.getElementById('chaosDuration').value = this.dataset.chaosDuration;
        sendChaosConfig();  // Send on preset click
      });
    });
    
    document.querySelectorAll('[data-chaos-craziness]').forEach(btn => {
      btn.addEventListener('click', function() {
        document.getElementById('chaosCraziness').value = this.dataset.chaosCraziness;
        document.getElementById('crazinessValue').textContent = this.dataset.chaosCraziness;
        sendChaosConfig();  // Send on preset click
      });
    });
    
    // Update craziness value display and send config
    document.getElementById('chaosCraziness').addEventListener('input', function() {
      document.getElementById('crazinessValue').textContent = this.value;
    });
    
    // Send config on blur (when user finishes editing)
    document.getElementById('chaosCenterPos').addEventListener('blur', function() {
      sendChaosConfig();
      updateChaosPresets();  // Update visual state after manual edit
    });
    document.getElementById('chaosAmplitude').addEventListener('blur', function() {
      sendChaosConfig();
      updateChaosPresets();  // Update visual state after manual edit
    });
    document.getElementById('chaosMaxSpeed').addEventListener('blur', function() {
      sendChaosConfig();
    });
    document.getElementById('chaosCraziness').addEventListener('blur', function() {
      sendChaosConfig();
    });
    document.getElementById('chaosDuration').addEventListener('blur', function() {
      sendChaosConfig();
    });
    document.getElementById('chaosSeed').addEventListener('blur', function() {
      sendChaosConfig();
    });
    
    // Pattern preset buttons
    document.getElementById('btnEnableAllPatterns').addEventListener('click', function() {
      // Get all pattern checkboxes
      const patterns = [
        'patternZigzag', 'patternSweep', 'patternPulse', 'patternDrift',
        'patternBurst', 'patternWave', 'patternPendulum', 'patternSpiral',
        'patternCalm', 'patternBruteForce', 'patternLiberator'
      ];
      
      // Check if all are currently checked
      const allChecked = patterns.every(id => document.getElementById(id).checked);
      
      // Toggle: if all checked â†’ uncheck all, otherwise check all
      const newState = !allChecked;
      patterns.forEach(id => {
        document.getElementById(id).checked = newState;
      });
      
      // Update button text immediately
      updatePatternToggleButton();
    });
    
    document.getElementById('btnEnableSoftPatterns').addEventListener('click', function() {
      // Doux (45%): WAVE, PENDULUM, SPIRAL, BREATHING
      document.getElementById('patternZigzag').checked = false;
      document.getElementById('patternSweep').checked = false;
      document.getElementById('patternPulse').checked = false;
      document.getElementById('patternDrift').checked = false;
      document.getElementById('patternBurst').checked = false;
      document.getElementById('patternWave').checked = true;
      document.getElementById('patternPendulum').checked = true;
      document.getElementById('patternSpiral').checked = true;
      document.getElementById('patternCalm').checked = true;
      document.getElementById('patternBruteForce').checked = false;
      document.getElementById('patternLiberator').checked = false;
      updatePatternToggleButton();
    });
    
    document.getElementById('btnEnableDynamicPatterns').addEventListener('click', function() {
      // Dynamiques (55%): ZIGZAG, SWEEP, PULSE, DRIFT, BURST, BRUTE_FORCE, LIBERATOR
      document.getElementById('patternZigzag').checked = true;
      document.getElementById('patternSweep').checked = true;
      document.getElementById('patternPulse').checked = true;
      document.getElementById('patternDrift').checked = true;
      document.getElementById('patternBurst').checked = true;
      document.getElementById('patternWave').checked = false;
      document.getElementById('patternPendulum').checked = false;
      document.getElementById('patternSpiral').checked = false;
      document.getElementById('patternCalm').checked = false;
      document.getElementById('patternBruteForce').checked = true;
      document.getElementById('patternLiberator').checked = true;
      updatePatternToggleButton();
    });
    
    // Add listeners to individual pattern checkboxes to update toggle button
    const patternIds = [
      'patternZigzag', 'patternSweep', 'patternPulse', 'patternDrift',
      'patternBurst', 'patternWave', 'patternPendulum', 'patternSpiral',
      'patternCalm', 'patternBruteForce', 'patternLiberator'
    ];
    patternIds.forEach(id => {
      document.getElementById(id).addEventListener('change', updatePatternToggleButton);
    });
    
    document.getElementById('btnSkipLine').addEventListener('click', function() {
      sendCommand(WS_CMD.SKIP_SEQUENCE_LINE, {});
    });
    
    // Modal handlers
    document.getElementById('editLineForm').addEventListener('submit', saveLineEdit);
    document.getElementById('btnCancelEdit').addEventListener('click', closeEditModal);
    document.getElementById('btnCloseModal').addEventListener('click', closeEditModal);
    
    // Movement type radio buttons
    document.getElementById('editTypeVaet').addEventListener('change', updateMovementTypeFields);
    document.getElementById('editTypeOsc').addEventListener('change', updateMovementTypeFields);
    document.getElementById('editTypeChaos').addEventListener('change', updateMovementTypeFields);
    document.getElementById('editTypeCalibration').addEventListener('change', updateMovementTypeFields);
    
    // Cycle Pause toggles (VA-ET-VIENT)
    document.getElementById('editVaetPauseEnabled').addEventListener('change', function() {
      const enabled = this.checked;
      document.getElementById('vaetPauseFixedDiv').style.display = enabled ? 'grid' : 'none';
      document.getElementById('vaetPauseRandomDiv').style.display = (enabled && document.getElementById('editVaetPauseRandom').checked) ? 'grid' : 'none';
    });
    document.getElementById('editVaetPauseRandom').addEventListener('change', function() {
      const isRandom = this.checked;
      const enabled = document.getElementById('editVaetPauseEnabled').checked;
      document.getElementById('vaetPauseFixedDiv').style.display = (enabled && !isRandom) ? 'grid' : 'none';
      document.getElementById('vaetPauseRandomDiv').style.display = (enabled && isRandom) ? 'grid' : 'none';
    });
    
    // Cycle Pause toggles (OSCILLATION)
    document.getElementById('editOscPauseEnabled').addEventListener('change', function() {
      const enabled = this.checked;
      document.getElementById('oscPauseFixedDiv').style.display = enabled ? 'grid' : 'none';
      document.getElementById('oscPauseRandomDiv').style.display = (enabled && document.getElementById('editOscPauseRandom').checked) ? 'grid' : 'none';
    });
    document.getElementById('editOscPauseRandom').addEventListener('change', function() {
      const isRandom = this.checked;
      const enabled = document.getElementById('editOscPauseEnabled').checked;
      document.getElementById('oscPauseFixedDiv').style.display = (enabled && !isRandom) ? 'grid' : 'none';
      document.getElementById('oscPauseRandomDiv').style.display = (enabled && isRandom) ? 'grid' : 'none';
    });
    
    // Enforce numeric input constraints on all number fields (includes real-time validation)
    function enforceNumericConstraints(input) {
      // Filter invalid characters after input AND trigger validation
      input.addEventListener('input', function(e) {
        const oldValue = this.value;
        // Allow: digits, decimal point, minus sign
        // Remove all non-numeric characters except . and -
        let newValue = this.value.replace(/[^\d.-]/g, '');
        
        // Ensure only one decimal point
        const parts = newValue.split('.');
        if (parts.length > 2) {
          newValue = parts[0] + '.' + parts.slice(1).join('');
        }
        
        // Ensure minus only at start
        if (newValue.indexOf('-') > 0) {
          newValue = newValue.replace(/-/g, '');
        }
        
        // Update value if changed
        if (newValue !== oldValue) {
          this.value = newValue;
        }
        
        // Trigger real-time validation (red border + error messages)
        // Use setTimeout to ensure value is updated before validation
        setTimeout(function() {
          if (typeof validateEditForm === 'function') {
            validateEditForm();
          }
        }, 10);
      });
      
      // Enforce min/max on blur
      input.addEventListener('blur', function() {
        const min = parseFloat(this.getAttribute('min'));
        const max = parseFloat(this.getAttribute('max'));
        const val = parseFloat(this.value);
        
        if (!isNaN(min) && val < min) {
          this.value = min;
          validateEditForm();
        }
        if (!isNaN(max) && val > max) {
          this.value = max;
          validateEditForm();
        }
      });
    }
    
    // Apply numeric constraints to all number inputs in edit modal
    const numericInputs = [
      'editStartPos', 'editDistance', 'editSpeedFwd', 'editSpeedBack', 'editDecelZone',
      'editOscCenter', 'editOscAmplitude', 'editOscFrequency',
      'editOscRampInDur', 'editOscRampOutDur',
      'editChaosCenter', 'editChaosAmplitude', 'editChaosSpeed', 'editChaosCraziness',
      'editChaosDuration', 'editChaosSeed',
      'editCycles', 'editPause'
    ];
    numericInputs.forEach(id => {
      const input = document.getElementById(id);
      if (input) enforceNumericConstraints(input);
    });
    
    // Apply same numeric constraints to MAIN CONTROLS (classic modes)
    const mainNumericInputs = [
      // VA-ET-VIENT
      'startPosition', 'distance', 'speedUnified', 'speedForward', 'speedBackward',
      'decelZone', 'decelEffect',
      // OSCILLATION
      'oscCenterPosition', 'oscAmplitude', 'oscFrequency', 'oscSpeed',
      'oscRampInDuration', 'oscRampOutDuration',
      // CHAOS
      'chaosCenter', 'chaosAmplitude', 'chaosSpeed', 'chaosCraziness',
      'chaosDuration', 'chaosSeed'
    ];
    mainNumericInputs.forEach(id => {
      const input = document.getElementById(id);
      if (input) enforceNumericConstraints(input);
    });
    
    // Close modal on outside click
    document.getElementById('editLineModal').addEventListener('click', function(e) {
      if (e.target === this) {
        closeEditModal();
      }
    });
    
    // Update effect value display in modal
    document.getElementById('editDecelEffect').addEventListener('input', function() {
      document.getElementById('editEffectValue').textContent = this.value;
    });
    
    // ============================================================================
    // DECELERATION ZONE HANDLERS
    // ============================================================================
    
    // ============================================================================
    // DECELERATION ZONE HELPERS
    // ============================================================================
    
    // JavaScript implementation of C++ calculateSlowdownFactor()
    // Matches the exact curve formulas from the firmware
    function calculateSlowdownFactorJS(zoneProgress, maxSlowdown, mode) {
      let factor = 1.0;
      
      switch(mode) {
        case 0: // DECEL_LINEAR
          factor = 1.0 + (1.0 - zoneProgress) * (maxSlowdown - 1.0);
          break;
          
        case 1: // DECEL_SINE
          const smoothProgress = (1.0 - Math.cos(zoneProgress * Math.PI)) / 2.0;
          factor = 1.0 + (1.0 - smoothProgress) * (maxSlowdown - 1.0);
          break;
          
        case 2: // DECEL_TRIANGLE_INV
          const invProgressTri = 1.0 - zoneProgress;
          const curvedTri = invProgressTri * invProgressTri;
          factor = 1.0 + curvedTri * (maxSlowdown - 1.0);
          break;
          
        case 3: // DECEL_SINE_INV
          const invProgressSin = 1.0 - zoneProgress;
          const curvedSin = Math.sin(invProgressSin * Math.PI / 2.0);
          factor = 1.0 + curvedSin * (maxSlowdown - 1.0);
          break;
          
        default:
          factor = 1.0 + (1.0 - zoneProgress) * (maxSlowdown - 1.0);
      }
      
      return factor;
    }
    
    // ============================================================================
    // DECELERATION ZONE EVENT LISTENERS
    // ============================================================================
    
    // Show/hide decel zone options
    // Deceleration section toggle (replaces checkbox)
    function toggleDecelSection() {
      const section = document.getElementById('decelSection');
      const headerText = document.getElementById('decelHeaderText');
      const isCollapsed = section.classList.contains('collapsed');
      
      section.classList.toggle('collapsed');
      
      if (isCollapsed) {
        // Expanding = activating
        headerText.textContent = 'ğŸ¯ DÃ©cÃ©lÃ©ration - activÃ©e';
        sendDecelConfig();
        drawDecelPreview();
      } else {
        // Collapsing = deactivating
        headerText.textContent = 'ğŸ¯ DÃ©cÃ©lÃ©ration - dÃ©sactivÃ©e';
        // Send config with zones disabled
        sendCommand(WS_CMD.SET_DECEL_ZONE, {
          enabled: false
        });
      }
    }
    
    // ===== CYCLE PAUSE SECTION (MODE SIMPLE) =====
    function toggleCyclePauseSection() {
      const section = document.querySelector('.section-collapsible:has(#cyclePauseHeaderText)');
      const headerText = document.getElementById('cyclePauseHeaderText');
      const isCollapsed = section.classList.contains('collapsed');
      
      section.classList.toggle('collapsed');
      
      if (isCollapsed) {
        // Expanding = activating
        headerText.textContent = 'â¸ï¸ Pause entre cycles - activÃ©e';
        sendCyclePauseConfig();
      } else {
        // Collapsing = deactivating
        headerText.textContent = 'â¸ï¸ Pause entre cycles - dÃ©sactivÃ©e';
        sendCommand(WS_CMD.UPDATE_CYCLE_PAUSE, {
          enabled: false
        });
      }
    }
    
    // Radio button change handlers (Mode Simple)
    document.querySelectorAll('input[name="cyclePauseMode"]').forEach(radio => {
      radio.addEventListener('change', function() {
        const isFixed = this.value === 'fixed';
        document.getElementById('pauseFixedControls').style.display = isFixed ? 'flex' : 'none';
        document.getElementById('pauseRandomControls').style.display = isFixed ? 'none' : 'block';
        
        // Send updated config
        const section = document.querySelector('.section-collapsible:has(#cyclePauseHeaderText)');
        if (!section.classList.contains('collapsed')) {
          sendCyclePauseConfig();
        }
      });
    });
    
    // Preset buttons for fixed duration (Mode Simple)
    document.querySelectorAll('[data-pause-duration]').forEach(btn => {
      btn.addEventListener('click', function() {
        const value = this.getAttribute('data-pause-duration');
        document.getElementById('cyclePauseDuration').value = value;
        
        // Update active state
        document.querySelectorAll('[data-pause-duration]').forEach(b => b.classList.remove('active'));
        this.classList.add('active');
        
        sendCyclePauseConfig();
      });
    });
    
    // Preset buttons for min (Mode Simple)
    document.querySelectorAll('[data-pause-min]').forEach(btn => {
      btn.addEventListener('click', function() {
        const value = this.getAttribute('data-pause-min');
        document.getElementById('cyclePauseMin').value = value;
        
        // Update active state
        document.querySelectorAll('[data-pause-min]').forEach(b => b.classList.remove('active'));
        this.classList.add('active');
        
        sendCyclePauseConfig();
      });
    });
    
    // Preset buttons for max (Mode Simple)
    document.querySelectorAll('[data-pause-max]').forEach(btn => {
      btn.addEventListener('click', function() {
        const value = this.getAttribute('data-pause-max');
        document.getElementById('cyclePauseMax').value = value;
        
        // Update active state
        document.querySelectorAll('[data-pause-max]').forEach(b => b.classList.remove('active'));
        this.classList.add('active');
        
        sendCyclePauseConfig();
      });
    });
    
    // Input change listeners (Mode Simple)
    ['cyclePauseDuration', 'cyclePauseMin', 'cyclePauseMax'].forEach(id => {
      const input = document.getElementById(id);
      if (input) {
        input.addEventListener('change', function() {
          const section = document.querySelector('.section-collapsible:has(#cyclePauseHeaderText)');
          if (!section.classList.contains('collapsed')) {
            sendCyclePauseConfig();
          }
        });
      }
    });
    
    // Send cycle pause config (Mode Simple)
    function sendCyclePauseConfig() {
      const section = document.querySelector('.section-collapsible:has(#cyclePauseHeaderText)');
      const enabled = !section.classList.contains('collapsed');
      const isRandom = document.getElementById('pauseModeRandom').checked;
      
      const config = {
        enabled: enabled,
        isRandom: isRandom,
        pauseDurationSec: parseFloat(document.getElementById('cyclePauseDuration').value),
        minPauseSec: parseFloat(document.getElementById('cyclePauseMin').value),
        maxPauseSec: parseFloat(document.getElementById('cyclePauseMax').value)
      };
      
      sendCommand(WS_CMD.UPDATE_CYCLE_PAUSE, config);
    }
    
    // ===== CYCLE PAUSE SECTION (MODE OSCILLATION) =====
    function toggleCyclePauseOscSection() {
      const section = document.querySelector('.section-collapsible:has(#cyclePauseOscHeaderText)');
      const headerText = document.getElementById('cyclePauseOscHeaderText');
      const isCollapsed = section.classList.contains('collapsed');
      
      section.classList.toggle('collapsed');
      
      if (isCollapsed) {
        // Expanding = activating
        headerText.textContent = 'â¸ï¸ Pause entre cycles - activÃ©e';
        sendCyclePauseConfigOsc();
      } else {
        // Collapsing = deactivating
        headerText.textContent = 'â¸ï¸ Pause entre cycles - dÃ©sactivÃ©e';
        sendCommand(WS_CMD.UPDATE_CYCLE_PAUSE_OSC, {
          enabled: false
        });
      }
    }
    
    // Radio button change handlers (Mode Oscillation)
    document.querySelectorAll('input[name="cyclePauseModeOsc"]').forEach(radio => {
      radio.addEventListener('change', function() {
        const isFixed = this.value === 'fixed';
        document.getElementById('pauseFixedControlsOsc').style.display = isFixed ? 'flex' : 'none';
        document.getElementById('pauseRandomControlsOsc').style.display = isFixed ? 'none' : 'block';
        
        // Send updated config
        const section = document.querySelector('.section-collapsible:has(#cyclePauseOscHeaderText)');
        if (!section.classList.contains('collapsed')) {
          sendCyclePauseConfigOsc();
        }
      });
    });
    
    // Preset buttons for fixed duration (Mode Oscillation)
    document.querySelectorAll('[data-pause-duration-osc]').forEach(btn => {
      btn.addEventListener('click', function() {
        const value = this.getAttribute('data-pause-duration-osc');
        document.getElementById('cyclePauseDurationOsc').value = value;
        
        // Update active state
        document.querySelectorAll('[data-pause-duration-osc]').forEach(b => b.classList.remove('active'));
        this.classList.add('active');
        
        sendCyclePauseConfigOsc();
      });
    });
    
    // Preset buttons for min (Mode Oscillation)
    document.querySelectorAll('[data-pause-min-osc]').forEach(btn => {
      btn.addEventListener('click', function() {
        const value = this.getAttribute('data-pause-min-osc');
        document.getElementById('cyclePauseMinOsc').value = value;
        
        // Update active state
        document.querySelectorAll('[data-pause-min-osc]').forEach(b => b.classList.remove('active'));
        this.classList.add('active');
        
        sendCyclePauseConfigOsc();
      });
    });
    
    // Preset buttons for max (Mode Oscillation)
    document.querySelectorAll('[data-pause-max-osc]').forEach(btn => {
      btn.addEventListener('click', function() {
        const value = this.getAttribute('data-pause-max-osc');
        document.getElementById('cyclePauseMaxOsc').value = value;
        
        // Update active state
        document.querySelectorAll('[data-pause-max-osc]').forEach(b => b.classList.remove('active'));
        this.classList.add('active');
        
        sendCyclePauseConfigOsc();
      });
    });
    
    // Input change listeners (Mode Oscillation)
    ['cyclePauseDurationOsc', 'cyclePauseMinOsc', 'cyclePauseMaxOsc'].forEach(id => {
      const input = document.getElementById(id);
      if (input) {
        input.addEventListener('change', function() {
          const section = document.querySelector('.section-collapsible:has(#cyclePauseOscHeaderText)');
          if (!section.classList.contains('collapsed')) {
            sendCyclePauseConfigOsc();
          }
        });
      }
    });
    
    // Send cycle pause config (Mode Oscillation)
    function sendCyclePauseConfigOsc() {
      const section = document.querySelector('.section-collapsible:has(#cyclePauseOscHeaderText)');
      const enabled = !section.classList.contains('collapsed');
      const isRandom = document.getElementById('pauseModeRandomOsc').checked;
      
      const config = {
        enabled: enabled,
        isRandom: isRandom,
        pauseDurationSec: parseFloat(document.getElementById('cyclePauseDurationOsc').value),
        minPauseSec: parseFloat(document.getElementById('cyclePauseMinOsc').value),
        maxPauseSec: parseFloat(document.getElementById('cyclePauseMaxOsc').value)
      };
      
      sendCommand(WS_CMD.UPDATE_CYCLE_PAUSE_OSC, config);
    }
    
    // Decel zone presets
    document.querySelectorAll('[data-decel-zone]').forEach(btn => {
      btn.addEventListener('click', function() {
        const value = this.getAttribute('data-decel-zone');
        document.getElementById('decelZoneMM').value = value;
        
        // Update active state
        document.querySelectorAll('[data-decel-zone]').forEach(b => b.classList.remove('active'));
        this.classList.add('active');
        
        sendDecelConfig();
        drawDecelPreview();
      });
    });
    
    // Decel zone start/end checkboxes
    document.getElementById('decelZoneStart').addEventListener('change', function() {
      sendDecelConfig();
      drawDecelPreview();
    });
    
    document.getElementById('decelZoneEnd').addEventListener('change', function() {
      sendDecelConfig();
      drawDecelPreview();
    });
    
    // Zone size input
    document.getElementById('decelZoneMM').addEventListener('input', function() {
      sendDecelConfig();
      drawDecelPreview();
    });
    
    // Effect percent slider
    document.getElementById('decelEffectPercent').addEventListener('input', function() {
      document.getElementById('effectValue').textContent = this.value + '%';
      sendDecelConfig();
      drawDecelPreview();
    });
    
    // Deceleration mode select dropdown
    document.getElementById('decelModeSelect').addEventListener('change', function() {
      sendDecelConfig();
      drawDecelPreview();
    });
    
    // Send deceleration configuration to ESP32
    function sendDecelConfig() {
      const section = document.getElementById('decelSection');
      const isEnabled = !section.classList.contains('collapsed');
      
      const zoneMM = parseFloat(document.getElementById('decelZoneMM').value) || 50;
      
      const config = {
        enabled: isEnabled,
        enableStart: document.getElementById('decelZoneStart').checked,
        enableEnd: document.getElementById('decelZoneEnd').checked,
        zoneMM: zoneMM,
        effectPercent: parseFloat(document.getElementById('decelEffectPercent').value) || 75,
        mode: parseInt(document.getElementById('decelModeSelect')?.value || 1)
      };
      
      // Store requested zone value for comparison
      AppState.lastDecelZoneRequest = zoneMM;
      
      sendCommand(WS_CMD.SET_DECEL_ZONE, config);
    }
    
    // Draw deceleration curve preview on canvas
    function drawDecelPreview() {
      const canvas = document.getElementById('decelPreview');
      if (!canvas) return;
      
      const ctx = canvas.getContext('2d');
      const width = canvas.width;
      const height = canvas.height;
      const padding = 20;
      const plotWidth = width - 2 * padding;
      const plotHeight = height - 2 * padding;
      
      // Clear canvas
      ctx.clearRect(0, 0, width, height);
      
      // Get current config
      const section = document.getElementById('decelSection');
      const enabled = !section.classList.contains('collapsed');
      const enableStart = document.getElementById('decelZoneStart').checked;
      const enableEnd = document.getElementById('decelZoneEnd').checked;
      const zoneMM = parseFloat(document.getElementById('decelZoneMM').value) || 50;
      const effectPercent = parseFloat(document.getElementById('decelEffectPercent').value) || 75;
      const mode = parseInt(document.getElementById('decelModeSelect')?.value || 1);
      
      if (!enabled) {
        ctx.font = '14px Arial';
        ctx.fillStyle = '#999';
        ctx.textAlign = 'center';
        ctx.fillText('DÃ©cÃ©lÃ©ration dÃ©sactivÃ©e', width / 2, height / 2);
        return;
      }
      
      // Assume a movement amplitude of 150mm for preview
      const movementAmplitude = 150;
      const maxSlowdown = 1.0 + (effectPercent / 100.0) * 9.0;  // 1Ã— to 10Ã—
      
      // Draw axes
      ctx.strokeStyle = '#ccc';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(padding, padding);
      ctx.lineTo(padding, height - padding);
      ctx.lineTo(width - padding, height - padding);
      ctx.stroke();
      
      // Draw curve
      ctx.strokeStyle = '#4CAF50';
      ctx.lineWidth = 2;
      ctx.beginPath();
      
      for (let x = 0; x <= plotWidth; x++) {
        const positionMM = (x / plotWidth) * movementAmplitude;
        let speedFactor = 1.0;  // Normal speed
        
        // Check START zone
        if (enableStart && positionMM <= zoneMM) {
          const zoneProgress = positionMM / zoneMM;
          speedFactor = calculateSlowdownFactorJS(zoneProgress, maxSlowdown, mode);
        }
        // Check END zone
        if (enableEnd && positionMM >= (movementAmplitude - zoneMM)) {
          const distanceFromEnd = movementAmplitude - positionMM;
          const zoneProgress = distanceFromEnd / zoneMM;
          speedFactor = calculateSlowdownFactorJS(zoneProgress, maxSlowdown, mode);
        }
        
        // Convert speed factor to Y coordinate (inverted: slower = higher on graph)
        const normalizedSpeed = 1.0 / speedFactor;  // 1.0 = normal, 0.1 = 10Ã— slower
        const y = height - padding - (normalizedSpeed * plotHeight);
        
        if (x === 0) {
          ctx.moveTo(padding + x, y);
        } else {
          ctx.lineTo(padding + x, y);
        }
      }
      
      ctx.stroke();
      
      // Draw zone boundaries
      if (enableStart || enableEnd) {
        ctx.setLineDash([5, 3]);
        ctx.strokeStyle = '#FF9800';
        ctx.lineWidth = 1;
        
        if (enableStart) {
          const startX = padding + (zoneMM / movementAmplitude) * plotWidth;
          ctx.beginPath();
          ctx.moveTo(startX, padding);
          ctx.lineTo(startX, height - padding);
          ctx.stroke();
        }
        
        if (enableEnd) {
          const endX = padding + ((movementAmplitude - zoneMM) / movementAmplitude) * plotWidth;
          ctx.beginPath();
          ctx.moveTo(endX, padding);
          ctx.lineTo(endX, height - padding);
          ctx.stroke();
        }
        
        ctx.setLineDash([]);
      }
      
      // Draw labels
      ctx.font = '10px Arial';
      ctx.fillStyle = '#666';
      ctx.textAlign = 'center';
      ctx.fillText('DÃ©part', padding, height - 5);
      ctx.fillText('ArrivÃ©e', width - padding, height - 5);
      
      // Draw speed indicators
      ctx.textAlign = 'left';
      ctx.fillText('Rapide', padding + 5, padding + 10);
      ctx.fillText('Lent', padding + 5, height - padding - 5);
    }
    
    connectWebSocket();
    loadPlaylists();  // Load playlist presets from backend
  </script>
</body>
</html>
